{
  "control_objectives": [
    {
      "id": "1.1",
      "description": "All sensitive data stored, processed, or transmitted by the software is identified.",
      "requirements": [
        {
          "id": "1.1.a",
          "description": "The assessor shall examine evidence to confirm that information is maintained that details all sensitive data that is stored, processed, and/or transmitted by the software. At a minimum, this shall include all payment data; authentication credentials; cryptographic keys and related data (such as IVs and seed data for random number generators); and system configuration data (such as registry entries, platform environment variables, prompts for plaintext data in software allowing for the entry of PIN data, or configuration scripts).",
          "function_names": []
        },
        {
          "id": "1.1.b",
          "description": "The assessor shall examine evidence to confirm that information is maintained that describes where sensitive data is stored. This includes the storage of sensitive data in temporary storage (such as volatile memory), semi-permanent storage (such as RAM disks), non-volatile storage (such as magnetic and flash storage media), or in specific locations or form factors (such as with an embedded system that is only capable of local storage).",
          "function_names": []
        },
        {
          "id": "1.1.c",
          "description": "The assessor shall examine evidence to confirm that information is maintained that describes the security controls that are implemented to protect sensitive data.",
          "function_names": []
        },
        {
          "id": "1.1.d",
          "description": "The assessor shall test the software to validate the evidence obtained in Test Requirements 1.1.a through 1.1.c.",
          "function_names": []
        },
        {
          "id": "1.1.e",
          "description": "The assessor shall examine evidence and test the software to identify the transaction types and/or card data elements that are supported by the software, and to confirm that the data for all of these is supported by the evidence examined in Test Requirements 1.1.a through 1.1.c.",
          "function_names": []
        },
        {
          "id": "1.1.f",
          "description": "The assessor shall examine evidence and test the software to identify the cryptographic implementations that are supported by the software (including cryptography used for storage, transport, and authentication), and to confirm that the cryptographic data for all of these implementations is supported by the evidence examined in Test Requirements 1.1.a through 1.1.c, and that the evidence describes whether these are implemented by the software itself, through third-party software, or as functions of the execution environment.",
          "function_names": []
        },
        {
          "id": "1.1.g",
          "description": "The assessor shall examine evidence and test the software to identify the accounts and authentication credentials supported by the software (including both default and user-created accounts) and to confirm that these accounts and credentials are supported by the evidence examined in Test Requirements 1.1.a through 1.1.c.",
          "function_names": []
        },
        {
          "id": "1.1.h",
          "description": "The assessor shall examine evidence and test the software to identify the configuration options provided by the software that can impact sensitive data (including those provided through separate files or scripts, internal functions, or menus and options), and to confirm that these are supported by the evidence examined in Test Requirements 1.1.a through 1.1.c.",
          "function_names": []
        }
      ],
      "guidance": "Software security controls are designed and implemented to protect the confidentiality and/or integrity of critical assets. To make sure these controls are effective and appropriate, the software vendor should identify all sensitive data the software collects, stores, processes, or transmits, as well as all sensitive functions and resources it either provides or uses."
    },
    {
      "id": "1.2",
      "description": "All sensitive functions and sensitive resources provided or used by the software are identified.",
      "requirements": [
        {
          "id": "1.2.a",
          "description": "The assessor shall examine evidence to confirm that information is maintained that details all sensitive functions and sensitive resources provided or used by the software. At a minimum, this shall include all functions that are designed to store, process, or transmit sensitive data and those services, configuration files, or other information necessary for the normal and secure operation of those functions.",
          "function_names": []
        },
        {
          "id": "1.2.b",
          "description": "The assessor shall examine evidence to confirm that information is maintained that clearly describes how and where the sensitive data associated with these functions and resources is stored. This includes the storage of sensitive data in temporary storage (such as volatile memory), semi-permanent storage (such as RAM disks), and non-volatile storage (such as magnetic and flash storage media). The assessor shall confirm that this information is supported by the evidence examined in Test Requirement 1.1.a through 1.1.c.",
          "function_names": []
        },
        {
          "id": "1.2.c",
          "description": "Where the sensitive functions or sensitive resources are provided by third-party software or systems, the assessor shall examine evidence and test the software to confirm that the software correctly follows available guidance for the third-party software.",
          "note": "For example, by reviewing the security policy of a PTS or FIPS140-2 or 140-3 approved cryptographic system.",
          "function_names": []
        }
      ],
      "guidance": ""
    },
    {
      "id": "1.3",
      "description": "Critical assets are classified.",
      "requirements": [
        {
          "id": "1.3",
          "description": "The assessor shall examine evidence to confirm that:\n• The software vendor defines criteria for classifying critical assets in accordance with the confidentiality, integrity, and resiliency requirements for each critical asset.\n• An inventory of all critical assets with appropriate classifications is maintained.",
          "function_names": []
        }
      ],
      "guidance": "Critical assets represent the sensitive data, functions, and resources that have business value and require confidentiality, integrity, or resiliency protection.\n\nThere are numerous analysis techniques that can be used to identify critical assets, including Mission Impact Analysis (MIA), Functional Dependency Network Analysis (FDNA), and Mission Threat Analysis. Additional information and techniques can be found in publications such as the appendices of NIST Special Publication 800-160 or in other publications from industry standards bodies such as EMVCo, ISO or ANSI."
    },
    {
      "id": "2.1",
      "description": "All functions exposed by the software are enabled by default only when and where it is a documented and justified part of the software architecture. ",
      "requirements": [
        {
          "id": "2.1.a",
          "description": "The assessor shall examine evidence and test the software to identify any software APIs or other interfaces that are provided or exposed by default upon installation, initialization, or first use. For each of these interfaces, the assessor shall confirm that the vendor has documented and justified its use as part of the software architecture. Testing shall include methods to reveal any exposed interfaces or other software functionality (such as scanning for listening services where applicable).",
          "note": "This includes functions that are auto-enabled as required during operation of the software.",
          "function_names": []
        },
        {
          "id": "2.1.b",
          "description": "The assessor shall test the software to determine whether any of the interfaces identified in Test Requirement 2.1.a rely on external resources for authentication. Where such resources are relied upon, the assessor shall examine evidence to confirm that methods are implemented to ensure that proper authentication remains in place and that these methods are included in the assessment of other applicable requirements in this standard.",
          "function_names": []
        },
        {
          "id": "2.1.c",
          "description": "The assessor shall test the software to determine whether any of the interfaces identified in Test Requirement 2.1.a rely on external resources for the protection of sensitive data during transmission. Where such resources are relied upon, the assessor shall examine evidence to confirm that methods are implemented to ensure proper protection remains in place and that these methods are included in the assessment of other applicable requirements in this standard.",
          "function_names": []
        },
        {
          "id": "2.1.d",
          "description": "The assessor shall test the software to determine whether any of the interfaces identified in Test Requirement 2.1.a expose functions or services that have publicly disclosed vulnerabilities by conducting a search on the exposed protocols, methods, or services in public vulnerability repositories such as that maintained within the National Vulnerability Database.",
          "function_names": []
        },
        {
          "id": "2.1.e",
          "description": "Where known vulnerabilities in exposed interfaces exist, the assessor shall examine evidence and test the software to confirm the following:\n• Methods are implemented to mitigate the exploitation of these weaknesses.\n• The risks posed by the use of known vulnerable protocols, functions, or ports are documented.\n• Clear and sufficient guidance on how to correctly implement sufficient security to meet applicable control objectives in this standard is provided to stakeholders in accordance with Control Objective 12.1.",
          "note": "The assessor should reference the vendor threat information defined in Control Objective 4.1 for this item.",
          "function_names": []
        },
        {
          "id": "2.1.f",
          "description": "The assessor shall examine evidence to identify any third-party modules used by the software and to confirm that any such functions exposed by each module are disabled, unable to be accessed through mitigation methods implemented by the software, or formally documented and justified by the software vendor. Where access to third-party functions is prevented through implemented protection methods, the assessor shall test the software to confirm that it does not rely on a lack of knowledge of such functions as a security mitigation method by simply not documenting an otherwise accessible API interface, and to confirm that the protection methods are effective at preventing the insecure use of such third-party functions.",
          "function_names": []
        }
      ],
      "guidance": "Software often contains functionality (for example, web services, administrative interface, application heartbeat, etc.) that is optional and is generally unused by many users. This functionality typically does not receive the same attention as standard or essential software functions and services, and often contains security weaknesses that can be exploited by malicious users to bypass security controls. To ensure a secure software deployment, the software’s default configuration should only expose functionality that has been reviewed, justified, and approved. This should include the default configuration for all software APIs, protocols, daemons, listeners, components, etc. Any unnecessary services, protocols, or ports should be disabled or removed. For guidance on services, protocols, or ports considered to be insecure, refer to industry standards and guidance (for example, NIST, ENISA, etc.)."
    },
    {
      "id": "2.2",
      "description": "All software security controls, features, and functions are enabled upon software installation, initialization, or first use.",
      "requirements": [
        {
          "id": "2.2.a",
          "description": "The assessor shall examine evidence and test the software to identify all software security controls, features and functions relied upon by the software for the protection of critical assets and to confirm that all are enabled upon installation, initialization, or first use of the software.",
          "function_names": []
        },
        {
          "id": "2.2.b",
          "description": "Where any software security controls, features and functions are enabled only upon initialization or first use, the assessor shall test the software to confirm that sensitive data is processed only after this initialization process is complete.",
          "function_names": []
        },
        {
          "id": "2.2.c",
          "description": "Where user input or interaction is required to enable software security controls, features, or functions (such as the installation of certificates), the assessor shall examine evidence to confirm that clear and sufficient guidance on configuring these options is provided to stakeholders in accordance with Control Objective 12.1.",
          "function_names": []
        }
      ],
      "guidance": "Software security controls are designed and implemented to protect the confidentiality and integrity of critical assets. Examples of such software security controls include authentication and authorization mechanisms, cryptographic controls, and controls to prevent leakage of sensitive data. Default software settings should result in a secure software configuration and should not rely on the end-user being a subject-matter expert to ensure a secure configuration. To that effect, all available software security controls should be active upon software installation, initialization, or first use, depending upon how the software is deployed."
    },
    {
      "id": "2.3",
      "description": "Default authentication credentials or keys for built-in accounts are not used after installation, initialization, or first use.",
      "requirements": [
        {
          "id": "2.3.a",
          "description": "The assessor shall examine evidence to identify the default credentials, keys, certificates, and other critical assets used for authentication by the software.",
          "note": "The assessor should refer to evidence obtained in the testing of Control Objectives 1, 5, and 7 to determine the authentication and access control mechanisms, keys, and other critical assets used for authentication.",
          "function_names": []
        },
        {
          "id": "2.3.b",
          "description": "The assessor shall test the software to confirm that all default credentials, keys, certificates, and other critical assets used for authentication by the software are supported by the evidence examined.",
          "note": "It is expected that this analysis will include, but not necessarily be limited to, the use of entropy analysis tools to look for hardcoded cryptographic keys, searches for common cryptographic function call and structures such as S-Boxes and big-number library functions (and tracing these functions backwards to search for hardcoded keys), as well as checking for strings containing common user account names or password values.",
          "function_names": []
        },
        {
          "id": "2.3.c",
          "description": "Where user input or interaction is required to disable or change any authentication credentials or keys for built-in accounts, the assessor shall examine evidence to confirm that guidance on configuring these options is provided to stakeholders in accordance with Control Objective 12.1.",
          "function_names": []
        },
        {
          "id": "2.3.d",
          "description": "The assessor shall test the software to confirm that default authentication credentials or keys for built-in accounts are not used by the authentication and access control mechanisms implemented by the software after software installation, initialization, or first use.",
          "note": "The assessor should refer to evidence obtained in the testing of Control Objective 5 to determine the authentication and access control mechanisms implemented by the software.",
          "function_names": []
        },
        {
          "id": "2.3.e",
          "description": "The assessor shall test the software to confirm that cryptographic keys used for authentication are not used for other purposes, such as protecting sensitive data during storage and transmission.",
          "note": "The assessor should refer to evidence obtained in the testing of Control Objective 6 to determine the software security controls implemented to protect sensitive data.",
          "function_names": []
        }
      ],
      "guidance": "To protect against unauthorized access, payment software should prevent the use of built-in accounts until the default authentication credentials can be changed. Built-in accounts with known credentials such as default or empty passwords, or default keys are often overlooked during installation, initial configuration, or use, and can be used by a malicious user to bypass access controls. Therefore, the software should not use or rely on the default credentials for its operation upon installation, initialization, or first use."
    },
    {
      "id": "2.4",
      "description": "The privileges and resources requested by the software from its execution environment are limited to those necessary for the operation of the software.",
      "requirements": [
        {
          "id": "2.4.a",
          "description": "The assessor shall examine evidence to identify the privileges and resources required by the software and to confirm that information is maintained that describes and reasonably justifies all privileges and resources required, including explicit permissions for access to resources, such as cameras, contacts, etc.",
          "function_names": []
        },
        {
          "id": "2.4.b",
          "description": "Where limiting access is not possible due to the architecture of the solution or the execution environment in which the software is executed, the assessor shall examine evidence to identify all mechanisms implemented by the software to prevent unauthorized access, exposure, or modification of critical assets, and to confirm that guidance on properly implementing and configuring these mechanisms is provided to stakeholders in accordance with Control Objective 12.1.",
          "function_names": []
        },
        {
          "id": "2.4.c",
          "description": "The assessor shall test the software to confirm that access permissions and privileges are assigned according to the evidence examined in Test Requirement 2.4.a. The assessor shall, where possible, use suitable tools for the platform on which the software is installed to review the permissions and privileges of the software itself, as well as the permissions and privileges of any resources, files, or additional elements generated or loaded by the software during use.",
          "note": "Where the above testing is not possible, the assessor shall justify why this is the case and that the testing that has been performed is sufficient.",
          "function_names": []
        },
        {
          "id": "2.4.d",
          "description": "Where the software execution environment provides legacy features for use by older versions of the software, the assessor shall examine evidence and test the software to confirm that these are not used, and that only recent and secured functionality is implemented. For example, software should 'target' the latest versions of APIs provided by the environment on which they run, where available.",
          "function_names": []
        }
      ],
      "guidance": "In many attacks on software or underlying systems, the software is often used to execute functions on the underlying operating systems or to abuse accessible external resources. When the software requires excessive permissions, such permissions may be exploited by a malicious user. To minimize the software’s attack surface, the software should only request and be granted the minimum required privileges for its intended operation. The same concept applies to resources used by the software. The software should be granted access to only the minimum required resources for its expected operation. For example, mobile applications that do not require access to the camera or photographs should not request such access unless they are a necessary part of the software architecture."
    },
    {
      "id": "2.5",
      "description": "Default privileges for built-in accounts are limited to those necessary for their intended purpose and function.",
      "requirements": [
        {
          "id": "2.5.a",
          "description": "The assessor shall examine the evidence to identify all default accounts provided by the software and to confirm that the privileges assigned to these accounts are justified and reasonable.",
          "function_names": []
        },
        {
          "id": "2.5.b",
          "description": "The assessor shall test the software to confirm that all default accounts provided or used by the software are supported by the evidence examined in Test Requirement 2.5.a.",
          "function_names": []
        },
        {
          "id": "2.5.c",
          "description": "The assessor shall examine evidence and test the software to confirm that exposed interfaces, such as APIs, are protected from attempts by unauthorized users to modify account privileges and elevate user access rights.",
          "function_names": []
        }
      ],
      "guidance": "In support of the principle of “least privilege,” built-in accounts should only have the privileges required for the intended function of the account, including access to sensitive data and resources as well as the ability to execute sensitive functions. For example, a built-in administrator account may require the ability to configure the software and associated user accounts, but not the ability to access areas containing sensitive data. Applying the principle of least privilege to user accounts helps prevent users without sufficient knowledge about the software from incorrectly or accidentally changing the software configuration or its security settings. Enforcing least privilege also helps to minimize the effects of unauthorized access to software user accounts. To limit access to sensitive data, functions, and resources to only those accounts that require such access, the level of privilege and access required should be defined and documented for each built-in account in an access matrix such that its assigned functions may be performed, but no additional or unnecessary access or privileges are granted."
    },
    {
      "id": "3.1",
      "description": "The software only retains the sensitive data absolutely necessary for the software to provide its intended functionality.",
      "requirements": [
        {
          "id": "3.1.a",
          "description": "The assessor shall examine evidence to identify the sensitive data that is collected by the software for use beyond any one transaction, the default time period for which it is retained, and whether the retention period is user-configurable, and to confirm that the purpose for retaining the sensitive data in this manner is justified and reasonable.  Note: The assessor should refer to evidence obtained in the testing of Control Objective 1.1 to determine the sensitive data retained by the software.",
          "function_names": []
        },
        {
          "id": "3.1.b",
          "description": "The assessor shall test the software to confirm that all available functions or services designed for the retention of sensitive data are supported by the evidence examined in Test Requirement 3.1.a.  Note: The assessor should refer to evidence obtained in the testing of Control Objective 1.2 to determine the sensitive functions and services provided or used by the software.",
          "function_names": []
        },
        {
          "id": "3.1.c",
          "description": "The assessor shall examine evidence and test the software to determine whether the software facilitates the storage of persistent sensitive data for the purposes of debugging, error finding or testing of systems, and to confirm that such data is protected during storage in accordance with Control Objective 6.1. Any function that allows for the storage of sensitive data for these purposes must be explicitly enabled through an interface that requires interaction and authorization by the user and retains the data only for the duration necessary in accordance with reasonable vendor criteria. Closure of the software must result in termination of this debugging state, such that it requires explicit re-enablement when the software is next executed, and any sensitive data is securely deleted per Control Objective 3.4.",
          "function_names": []
        },
        {
          "id": "3.1.d",
          "description": "Where user input or interaction is required to configure the retention period of sensitive data, the assessor shall examine evidence to confirm that guidance on configuring these options is provided to stakeholders in accordance with Control Objective 12.1.",
          "function_names": []
        }
      ],
      "guidance": "To prevent the unauthorized disclosure of sensitive data to unauthorized parties, the software should retain sensitive data only for the duration necessary to perform the specific operation for which sensitive data is collected. Retaining sensitive data longer than required presents opportunity for the data to be mishandled, misused, or accidentally disclosed. This control objective differentiates between transient sensitive data retained temporarily and persistent sensitive data that is retained on a more permanent basis. Examples of transient sensitive data include the retention account data in memory until payment authorization is received. Examples of persistent sensitive data include the storage of account data on disk to support recurrent payment transactions."
    },
    {
      "id": "3.2",
      "description": "Transient sensitive data is retained only for the duration necessary to fulfill a legitimate business purpose.",
      "requirements": [
        {
          "id": "3.2.a",
          "description": "Using information obtained in Test Requirement 1.1.a, the assessor shall examine evidence to identify all sensitive data that is retained by the software for transient use, what triggers the secure deletion of this data, and to confirm that the purposes for retaining the data are justified and reasonable. This includes data that is stored only in memory during the operation of the software.",
          "function_names": []
        },
        {
          "id": "3.2.b",
          "description": "Using information obtained in Test Requirement 1.2.a, the assessor shall test the software to confirm that all available functions or services that retain transient sensitive data are supported by evidence examined in Test Requirement 3.2.a and do not use immutable objects.",
          "function_names": []
        },
        {
          "id": "3.2.c",
          "description": "The assessor shall examine evidence and test the software to determine whether the software facilitates the storage of transient sensitive data for the purposes of debugging, error finding or testing of systems, and to confirm that such data is protected in accordance with Control Objective 6.1. Any function that allows for the storage of transient sensitive data for these purposes must be explicitly enabled through an interface that requires interaction and authorization by the user. Closure of the software must result in the termination of this debugging state, such that it requires explicit re-enablement when the software is next executed, and any transient sensitive data is securely deleted in accordance with Control Objective 3.5.",
          "function_names": []
        },
        {
          "id": "3.2.d",
          "description": "Where the retention of transient sensitive data requires user input or interaction, the assessor shall examine evidence to confirm that guidance on configuring these options is provided to stakeholders in accordance with Control Objective 12.1.",
          "function_names": []
        }
      ],
      "guidance": "Sensitive data elements collected in conjunction with software operations should only be retained for as long as required to complete that operation or related transaction.  After payment processing is complete, all transient sensitive data should be securely deleted from all locations where it has been retained such that any subsequent process, component, function, application, or user within the environment may not access or capture the sensitive data.  Software vendors should also be aware of and account for how other aspects of the software architecture (such as the software-development language and operating environment) may affect how and where transient sensitive data is retained. For example, operating-system usage of swap partitions or virtual memory files can cause information that should have been transient to persist longer than intended. If any sensitive data must be used for debugging or troubleshooting purposes, the software should only capture the minimum amount of data necessary and store it securely in a known location."
    },
    {
      "id": "3.3",
      "description": "The software protects the confidentiality and integrity of sensitive data (both transient and persistent) during retention.",
      "requirements": [
        {
          "id": "3.3.a",
          "description": "The assessor shall examine the evidence to identify the methods implemented to protect sensitive data during storage.",
          "function_names": []
        },
        {
          "id": "3.3.b",
          "description": "Where sensitive data is stored outside of temporary variables within the code itself, the assessor shall test the software to confirm that sensitive data is protected using either strong cryptography or other methods that provide an equivalent level of security.",
          "function_names": []
        },
        {
          "id": "3.3.c",
          "description": "Where protection methods use cryptography, the assessor shall examine evidence and test the software to confirm that the cryptographic implementation complies with Control Objective 7 of this standard.",
          "function_names": []
        },
        {
          "id": "3.3.d",
          "description": "Where sensitive data is protected using methods other than strong cryptography, the assessor shall examine evidence and test the software to confirm that the protections are present in all environments where the software is designed to be executed and are implemented correctly.",
          "function_names": []
        },
        {
          "id": "3.3.e",
          "description": "Where user input or interaction is required to configure protection methods, the assessor shall examine evidence to confirm that guidance on configuring these options is provided to stakeholders in accordance with Control Objective 12.1.",
          "function_names": []
        }
      ],
      "guidance": "The software should maintain security controls and mechanisms to protect all sensitive data while it is retained by the software. Examples of software security controls include writing to a secure memory location or using cryptography to render the data unreadable."
    },
    {
      "id": "3.4",
      "description": "The software securely deletes persistent sensitive data when it is no longer required.",
      "requirements": [
        {
          "id": "3.4.a",
          "description": "The assessor shall examine evidence to identify the methods implemented to render persistent sensitive data irretrievable and to confirm that sensitive data is rendered unrecoverable after the process is complete.",
          "function_names": []
        },
        {
          "id": "3.4.b",
          "description": "The assessor shall examine evidence and test the software to identify any platform or implementation level issues that complicate the secure deletion of non-transient sensitive data and to confirm that any non-transient sensitive data is securely deleted using a method that ensures that the data is rendered unrecoverable. Methods may include (but are not necessarily limited to) overwriting the data, deletion of cryptographic keys (of sufficient strength) that have been used to encrypt the data, or platform-specific functions that provide for secure deletion. Methods must accommodate for platform specific issues, such as flash wear-levelling algorithms or SSD over-provisioning, which may complicate simple over-writing methods.",
          "function_names": []
        },
        {
          "id": "3.4.c",
          "description": "The assessor shall test the software using forensic tools to identify any non-transient sensitive data residue in the execution environment, and to confirm that the methods attested by the software vendor are correctly implemented and applied to all sensitive data. This analysis should accommodate for the data structures and methods used to store the sensitive data (for example, by examining file systems at the allocation level and translating data formats to identify sensitive data elements) and cover all non-transient sensitive data types.",
          "note": "Where forensic testing of some or all aspects of the platform is not possible, the assessor should examine additional evidence to confirm secure deletion of sensitive data. Such evidence may include (but is not necessarily limited to) memory and storage dumps from development systems, evidence from memory traces from emulated systems, or evidence from physical extraction of data performed on-site by the software vendor.",
          "function_names": []
        }
      ],
      "guidance": "Secure deletion is the process of rendering data irretrievable to other people, processes, or systems. Secure deletion may be required at the end of a software-specific operation or upon completion of user-specified retention requirements. In the latter case, the software should be able to securely delete the sensitive data after expiry of the user-specified retention period. Only in circumstances where the retention of sensitive data is explicitly permitted should the data be retained after transaction processing is complete."
    },
    {
      "id": "3.5",
      "description": "Transient sensitive data is securely deleted from temporary storage facilities automatically by the software once the purpose for which it is retained is satisfied.",
      "requirements": [
        {
          "id": "3.5.a",
          "description": "The assessor shall examine evidence to identify the methods implemented to render transient sensitive data irretrievable and to confirm that sensitive data is unrecoverable after the process is complete.",
          "note": "This includes data which may be stored only temporarily in program memory / variables during operation of the software.",
          "function_names": []
        },
        {
          "id": "3.5.b",
          "description": "The assessor shall examine evidence and test the software to identify any platform or implementation level issues that complicate the erasure of such transient sensitive data such as abstraction layers between the code and the hardware execution environment and to confirm that methods have been implemented to minimize the risk posed by these complications.",
          "function_names": []
        },
        {
          "id": "3.5.c",
          "description": "The assessor shall test the software to identify any sensitive data residue in the execution environment and to confirm that the methods implemented are implemented correctly and enforced for all transient sensitive data. This analysis should accommodate for the data structures and methods used to store the sensitive data (for example, by examining file systems at the allocation level and translating data formats to identify sensitive data elements) and cover all non-transient sensitive data types.",
          "note": "Where forensic testing of some or all aspects of the platform is not possible, the assessor should examine additional evidence to confirm secure deletion of sensitive data. Such evidence may include (but is not necessarily limited to) memory and storage dumps from development systems, evidence from memory traces from emulated systems, or evidence from physical extraction of data performed on-site by the software vendor.",
          "function_names": []
        }
      ],
      "guidance": "Where sensitive data is only retained temporarily to perform a specific function (such as a payment transaction), mechanisms are required to securely delete the sensitive data once the specific function has completed. Transient sensitive data is often erased from temporary storage locations after processing is complete. However, that data may remain resident in volatile memory (RAM) or in other storage locations for longer periods than anticipated (such as in swap files/partitions or log files). Software vendors should account for all locations where sensitive data is stored, regardless of the intended duration of storage, and ensure that such data is securely deleted once the purpose for which the software collected the data has been satisfied."
    },
    {
      "id": "3.6",
      "description": "The software does not disclose sensitive data through unintended channels.",
      "requirements": [
        {
          "id": "3.6.a",
          "description": "The assessor shall examine evidence to confirm the software vendor has performed a thorough analysis to account for all sensitive data disclosure attack vectors including, but not limited to: • Error messages, error logs, or memory dumps. • Execution environments that may be vulnerable to remote side-channel attacks to expose sensitive data, such as attacks that exploit cache timing or branch prediction within the platform processor. • Automatic storage or exposure of sensitive data by the underlying execution environment, such as through swap files, system error logging, keyboard spelling, and auto correct features. • Sensors or services provided by the execution environment that may be used to extract or leak sensitive data, such as through use of an accelerometer to capture input of a passphrase to be used as a seed for a cryptographic key, or through capture of sensitive data through use of cameras or near-field communication (NFC) interfaces.",
          "function_names": []
        },
        {
          "id": "3.6.b",
          "description": "The assessor shall examine evidence, including the results of the analysis described in Test Requirement 3.6.a, and test the software to confirm that methods are implemented to protect against unintended disclosure of sensitive data. Such methods may include usage of cryptography to protect the data, or the use of blinding or masking of cryptographic operations (where supported by the execution environment).",
          "function_names": []
        },
        {
          "id": "3.6.c",
          "description": "Where protection methods require user input or interaction, the assessor shall examine evidence to confirm that guidance on the proper configuration and use of such methods is provided to stakeholders in accordance with Control Objective 12.1.",
          "function_names": []
        },
        {
          "id": "3.6.d",
          "description": "The assessor shall test the software to identify any sensitive data residue in the execution environment, and to confirm that protection methods are implemented correctly and the software does not expose or otherwise reveal sensitive data to unauthorized users.",
          "function_names": []
        }
      ],
      "guidance": "Proactive measures to ensure that sensitive data is not inadvertently “leaked” should be implemented by the software vendor or within the software. Disclosure of sensitive data to unauthorized parties often occurs through unknown or unintended outputs or channels. For example: sensitive data could be unintentionally disclosed through error- or exception-handling routines, logging or debugging channels, third-party services and/or components, or through the use of shared resources such as memory, disk, files, keyboards, displays, and functions. Protective mechanisms, whether process or programmatic in nature, should be implemented to ensure that sensitive data is not accidentally disclosed through such means."
    },
    {
      "id": "4.1",
      "description": "Attack scenarios applicable to the software are identified.",
      "note": "This control objective is an extension of Control Objective 10.1. Validation of both control objectives should be performed at the same time.",
      "requirements": [
        {
          "id": "4.1.a",
          "description": "The assessor shall examine evidence to confirm that the software vendor has identified and documented relevant attack scenarios for the software.",
          "function_names": []
        },
        {
          "id": "4.1.b",
          "description": "The assessor shall examine evidence to determine whether any specific industry-standard methods or guidelines were used to identify relevant attack scenarios. Where such industry standards are not used, the assessor shall confirm that the methodology used provides equivalent coverage for the attack scenarios applicable to the software under evaluation.",
          "function_names": []
        },
        {
          "id": "4.1.c",
          "description": "The assessor shall examine evidence to confirm the following: • A formal owner of the software is assigned. This may be a role for a specific individual or a specific name, but evidence must clearly show an individual who is accountable for the security of the software. • A methodology is defined for measuring the likelihood and impact for any exploit of the system. • Generic threat methods and types that may be applicable to the software are documented. • All critical assets managed, and all sensitive resources used by the system are documented. • All entry and egress points for sensitive data, as well as the authentication and trust model applied to each of these entry/egress points, are documented. • All data flows, network segments, and authentication/privilege boundaries are documented. • All static IPs, domains, URLs, or ports required by the software for operation are documented. • Considerations for cryptography elements like cipher modes, and protecting against relevant attacks such as timing attacks, padded oracles, brute force, “rainbow table” attacks, and dictionary attacks against the input domain are documented. • Execution environment implementation specifics or assumptions, such as network configurations and operating system security configurations, are documented. • Considerations for the software execution environment, the size of the install base, and the attack surfaces that must be mitigated are documented. Examples of such attack surfaces may include insecure user prompts or protocol stacks, or the storage of sensitive data post authorization or using insecure methods.",
          "function_names": []
        }
      ],
      "guidance": "Software vendors should evaluate the design of their payment software to identify attack scenarios applicable to the software and should document the results of that analysis. Documentation should describe the various aspects of the code that could be attacked (including tasks or actions that frameworks and libraries do on the software’s behalf), the difficulty in mounting a successful attack, the mitigation techniques used to protect against such attacks, and the methodology used for measuring the likelihood and impact of each potential attack method. When the software relies on execution environment security controls, the software vendor should review and reference the implementation documentation for the platform (such as Security Policies for PCI approved POI devices or FIPS140-2 or 140-3 approved cryptographic modules) and should confirm that the software and its associated documentation correctly and completely accommodate the guidance in these documents."
    },
    {
      "id": "4.2",
      "description": "Software security controls are implemented to mitigate software attacks.",
      "requirements": [
        {
          "id": "4.2.a",
          "description": "The assessor shall examine evidence to confirm that one or more mitigation methods are defined for each of the threats identified in Test Requirement 4.1.a or that justification for the lack of mitigations is provided.",
          "function_names": []
        },
        {
          "id": "4.2.b",
          "description": "Where any mitigations rely on settings within the software, the assessor shall test the software to confirm that such settings are applied by default upon installation, initialization, or first use of the software.",
          "function_names": []
        },
        {
          "id": "4.2.c",
          "description": "Where user input or interaction can disable, remove, or bypass any such mitigations, the assessor shall examine evidence and test the software to confirm that such action requires authentication and authorization and that guidance on the risk of such actions is provided to stakeholders in accordance with Control Objective 12.1.",
          "function_names": []
        },
        {
          "id": "4.2.d",
          "description": "When any mitigations rely on features of the execution environment, the assessor shall examine evidence to confirm that guidance is provided to stakeholders on how to enable such settings in accordance with Control Objective 12.1.",
          "function_names": []
        },
        {
          "id": "4.2.e",
          "description": "Where the execution environment provides APIs to query the status of mitigation controls, the assessor shall test the software to confirm that software checks for these mitigations are in place and active prior to being launched and periodically throughout execution.",
          "function_names": []
        }
      ],
      "guidance": "Once attack scenarios are identified, the risk of their occurrence should be mitigated. Software vendors should define and implement mechanisms to protect the software from attacks and reduce the likelihood and impact of successful execution. Any attack scenarios left unmitigated or insufficiently mitigated should be reasonably justified. The exact nature of the protection mechanism(s) will depend on the attack scenarios, the development platform, and the software-development languages, frameworks, libraries, and APIs used by the software, as well as the execution environment where the software is intended to be deployed. To minimize the software attack surface, the software should be developed using secure design principles such as layered defense, application segmentation and isolation (logical), and adaptive response. Examples of software security controls include input and output validation, authentication, parameterization, escaping, segmentation, logging, etc. For guidance on implementing cyber resiliency techniques and approaches, refer to industry standards and guidance such as the current version of NIST Special Publication 800-160."
    },
    {
      "id": "5.1",
      "description": "Access to critical assets is authenticated.",
      "requirements": [
        {
          "id": "5.1.a",
          "description": "The assessor shall examine evidence to confirm that authentication requirements are defined (i.e., type and number of factors) for all roles based on critical asset classification, the type of access (e.g., local, non-console, remote) and level of privilege. Note: The assessor should refer to evidence obtained in the testing of Control Objective 1.3 to determine the classifications for all critical assets.",
          "function_names": []
        },
        {
          "id": "5.1.b",
          "description": "The assessor shall examine evidence and test the software to confirm that access to critical assets is authenticated and authentication mechanisms are implemented correctly.",
          "function_names": []
        },
        {
          "id": "5.1.c",
          "description": "Where the software recommends, suggests, relies on, or otherwise supports the use of external mechanisms (such as third-party VPNs, remote desktop features, etc.) to provide secure non-console access to the system on which the software is executed or directly to the software itself, the assessor shall examine evidence to confirm that guidance on how to configure authentication mechanisms correctly is provided to stakeholders in accordance with Control Objective 12.1.",
          "function_names": []
        },
        {
          "id": "5.1.d",
          "description": "The assessor shall examine evidence to confirm that sensitive data associated with authentication credentials, including public keys, is identified as a critical asset.",
          "function_names": []
        }
      ],
      "guidance": "Secure authentication ensures individual responsibility for actions and allows the software to maintain an effective audit trail of user activity. This expedites issue resolution and containment when the software is misused for malicious purposes. Authentication mechanisms should cover all non-public resources managed by or accessible through the software, as well as sensitive functions that can alter the software operation or impact the security of sensitive data and sensitive resources. Examples of authentication methods include: • Something you know, such as a password or passphrase. • Something you have, such as a token device or smart card. • Something you are, such as a biometric. To ensure that the implemented authentication mechanisms are adequate to address the risk of unauthorized access to sensitive data or sensitive resources, or misuse of a sensitive function, the vendor should analyze threats and identify the required level of authentication for all types of users and roles. For example, a user with limited access to sensitive data and sensitive resources could be required to perform authentication using a single authentication factor (for example, a password or a passphrase) while a user that is able to export the entire database might be required to perform multi-factor authentication. Other factors such as the type of access (for example, local, non-console, or remote access) and the level of privilege (for example, the ability to invoke sensitive functions such as pause logging or change access privileges) may influence the level of authentication that should be required."
    },
    {
      "id": "5.2",
      "description": "Access to critical assets requires unique identification.",
      "requirements": [
        {
          "id": "5.2.a",
          "description": "The assessor shall examine evidence and test the software to confirm that all implemented authentication methods require unique identification.",
          "function_names": []
        },
        {
          "id": "5.2.b",
          "description": "Where interfaces, such as APIs, allow for automated access to critical assets, the assessor shall examine evidence and test the software to confirm that unique identification of different programs or systems accessing the critical assets is required (for example, through use of multiple public keys) and that guidance on configuring a unique credential for each program or system is provided to stakeholders in accordance with Control Objective 12.1.",
          "function_names": []
        },
        {
          "id": "5.2.c",
          "description": "Where identification is supplied across a non-console interface, the assessor shall test the software to confirm that authentication credentials are protected from attacks that attempt to intercept them in transit.",
          "function_names": []
        },
        {
          "id": "5.2.d",
          "description": "The assessor shall examine evidence to confirm that the guidance provided to stakeholders per Control Objective 12.1 specifically notes that identification and authentication parameters must not be shared between individuals, programs, or in any way that prevents the unique identification of each access to a critical asset.",
          "function_names": []
        }
      ],
      "guidance": "The software should not require the use of any group, shared, or generic accounts. The use of group or shared accounts makes it more difficult to determine which individuals execute specific actions since a given action could have been performed by anyone that has knowledge of the group or shared accounts’ authentication credentials."
    },
    {
      "id": "5.3",
      "description": "Authentication methods (including session credentials) are sufficiently strong and robust to protect authentication credentials from being forged, spoofed, leaked, guessed, or circumvented.",
      "requirements": [
        {
          "id": "5.3.a",
          "description": "Using information obtained in Test Requirement 4.1.a, the assessor shall examine evidence to confirm that authentication methods implemented by the software are evaluated to identify known vulnerabilities or attack methods involving the authentication method and how the implementation of these methods mitigates against such attacks. The assessor shall also confirm that the evidence examined demonstrates the implementation used in the software was considered. For example, a fingerprint may be uniquely identifiable to an individual, but the ability to spoof or otherwise bypass such technology can be highly dependent on the way the solution is implemented.",
          "function_names": []
        },
        {
          "id": "5.3.b",
          "description": "The assessor shall examine evidence to confirm that the implemented authentication methods are robust and the robustness of the authentication methods was evaluated using industry-accepted methods. Note: The vendor assessment and robustness justification include consideration of the full path of the user credentials, from any input source (such as a Human Machine Interface or other program), through transition to the execution environment of the software (including any switched/network transmissions and traversal through the execution environment’s software stack before being processed by the software itself).",
          "function_names": []
        },
        {
          "id": "5.3.c",
          "description": "The assessor shall test the software to confirm that the authentication methods are implemented correctly and do not expose vulnerabilities.",
          "function_names": []
        }
      ],
      "guidance": "The software vendor must evaluate, document, and justify the usage of implemented authentication methods to demonstrate that they are sufficiently strong to protect authentication credentials in the software’s intended specific use case or deployment scenario. For example, if the software uses biometric authentication, the vendor may want to identify all points at which a malicious user may attack the authenticator and implement mitigations to address those risks. The authentication mechanism implemented in the software could rely on additional sensors to ensure the provided biometric sample is from a living human and not a forged or spoofed sample. In some use cases or deployment scenarios, an authentication mechanism that relies on a single authentication method may not be sufficient. In such circumstances, the software vendor may want to implement additional mitigation strategies (for example, multi-factor authentication mechanism). To support a claim that the implemented authentication mechanism is sufficiently strong and robust, a vendor should adopt an industry-accepted methodology for assigning assurance levels (for example, NIST SP800-63-3 and NIST SP800-63B)."
    },
    {
      "id": "5.4",
      "description": "By default, all access to critical assets is restricted to only those accounts and services that require such access.",
      "requirements": [
        {
          "id": "5.4.a",
          "description": "The assessor shall examine evidence to confirm that information is maintained that identifies and justifies the required access for all critical assets.",
          "function_names": []
        },
        {
          "id": "5.4.b",
          "description": "The assessor shall examine evidence and test the software to identify the level of access that is provided to critical assets and to confirm that such access correlates with the evidence examined in Test Requirement 5.4.a. Testing to confirm access to critical assets is properly restricted should include attempts to access critical assets through user accounts, roles, or services which should not have the required privileges.",
          "function_names": []
        }
      ],
      "guidance": "To ensure the software protects the confidentiality and integrity of critical assets, access privileges to those critical assets should be restricted based on vendor-defined access requirements. There are various approaches to implementing privilege restriction, such as trust-based privilege management, attribute-based usage restriction, and dynamic privileges. To reduce the attack surface of the software, the software authorization mechanisms might limit access to critical assets to only those accounts that need such access (the principle of “least privilege”). Other techniques include implementation of Role-Based Access Control (RBAC), Attribute-Based Access Control (ABAC), time-based adjustment to privilege, and dynamic revocation of access authorization."
    },
    {
      "id": "6.1",
      "description": "Sensitive data is secured anywhere it is stored.",
      "requirements": [
        {
          "id": "6.1.a",
          "description": "The assessor shall examine evidence to confirm that protection requirements for all sensitive data are defined, including requirements for rendering sensitive data with confidentiality considerations unreadable anywhere it is stored persistently.",
          "function_names": []
        },
        {
          "id": "6.1.b",
          "description": "The assessor shall examine evidence and test the software to confirm that security controls are implemented to protect sensitive data during storage and that they address all defined protection requirements and identified attack scenarios.",
          "note": "The assessor should refer to evidence obtained in the testing of Control Objective 1.1 to determine all sensitive data retained by the software, and Control Objective 4.1 to identify all attack scenarios applicable to the software.",
          "function_names": []
        },
        {
          "id": "6.1.c",
          "description": "Where cryptography is used for securing sensitive data, the assessor shall examine evidence and test the software to confirm that methods implementing cryptography for securing sensitive data comply with Control Objective 7.",
          "function_names": []
        },
        {
          "id": "6.1.d",
          "description": "Where index tokens are used for securing sensitive data, the assessor shall examine evidence and test the software to confirm that these are generated in a way that ensures there is no correlation between the value and the sensitive data that is being referenced (without access to the software to perform the correlation as part of a formally defined and assessed feature of that software, such as “de-tokenization”).",
          "function_names": []
        },
        {
          "id": "6.1.e",
          "description": "Where protection methods rely on the security properties of the execution environment, the assessor shall examine evidence and test the software to confirm that these security properties are valid for all platforms where the software is intended to be deployed.",
          "function_names": []
        },
        {
          "id": "6.1.f",
          "description": "Where protection methods rely on the security properties of third-party software, the assessor shall examine evidence and test the software to confirm that there are no unmitigated vulnerabilities or issues with the software providing the security properties.",
          "function_names": []
        }
      ],
      "guidance": "Sensitive data must be protected wherever it is stored. In some cases, the integrity may be the primary concern. In other cases, it may be the confidentiality of the sensitive data that must be protected. Sometimes, both the integrity and confidentiality must be secured. The type of data and the purpose for which it is generated will often determine the need for integrity or confidentiality protection. In all cases, those protection requirements must be clearly defined. In cases where the confidentiality of sensitive data is a concern, it is imperative to know where and for how long the data is retained. The vendor must have details of all locations where the software may store sensitive data, including in any underlying software or systems, and documentation detailing the security controls used to protect the data. Sensitive data requiring confidentiality protection, when stored persistently, must be protected to prevent malicious or accidental access. Examples of methods to render sensitive data unreadable include usage of a one-way hash or the use of strong cryptography with associated key-management processes. Where the integrity of sensitive data is a concern, strong cryptography with appropriate key-management practices is one method that could be used to satisfy integrity protection requirements during storage."
    },
    {
      "id": "6.2",
      "description": "Sensitive data is secured during transmission.",
      "requirements": [
        {
          "id": "6.2.a",
          "description": "The assessor shall examine evidence to identify the locations within the software where sensitive data is transmitted outside of the physical execution environment and to confirm protection requirements for the transmission of all sensitive data are defined.",
          "function_names": []
        },
        {
          "id": "6.2.b",
          "description": "The assessor shall examine evidence and test the software to confirm that for each of the ingress and egress methods that allow for transmission of sensitive data outside of the physical execution environment, the data is encrypted with strong cryptography prior to transmission or is transmitted over an encrypted channel using strong cryptography.",
          "note": "The assessor should refer to evidence obtained in the testing of Control Objective 1.1 to determine the sensitive data stored, processed, or transmitted by the software.",
          "function_names": []
        },
        {
          "id": "6.2.c",
          "description": "Where third-party or execution-environment features are relied upon for the security of the transmitted data, the assessor shall examine evidence to confirm that guidance on how to configure such features is provided to stakeholders in accordance with Control Objective 12.1.",
          "function_names": []
        },
        {
          "id": "6.2.d",
          "description": "Where transport layer encryption is used to secure the transmission of sensitive data, the assessor shall examine evidence and test the software to confirm that all ingress and egress methods enforce a secure version of the protocol with end-point authentication prior to transmission.",
          "function_names": []
        },
        {
          "id": "6.2.e",
          "description": "Where the methods implemented for encrypting sensitive data allow for the use of different types of cryptography or different levels of security, the assessor shall examine evidence and test the software, including capturing software transmissions, to confirm the software enforces the use of strong cryptography at all times during transmission.",
          "function_names": []
        }
      ],
      "guidance": "To prevent malicious individuals from intercepting or diverting sensitive data while in transit, it must be protected during transmission. One method to protect sensitive data in transit is to encrypt it using strong cryptography prior to transmission. Alternatively, the software could establish an authenticated and encrypted channel using only trusted keys and certificates (for authentication) and appropriate encryption strength for the selected protocols."
    },
    {
      "id": "6.3",
      "description": "Use of cryptography meets all applicable cryptography requirements within this standard.",
      "requirements": [
        {
          "id": "6.3.a",
          "description": "Where cryptography is relied upon (in whole or in part) for the security of critical assets, the assessor shall examine evidence and test the software to confirm that the use of cryptography is compliant to Control Objective 7.",
          "note": "The assessor should refer to Control Objective 7 to identify all requirements for appropriate and correct implementation of cryptography.",
          "function_names": []
        },
        {
          "id": "6.3.b",
          "description": "Where cryptographic methods provided by third-party software or aspects of the execution environment or platform on which the application is run are relied upon for the protection of sensitive data, the assessor shall examine evidence and test the software to confirm that guidance on configuring these methods during the installation, initialization, or first use of the software is provided to stakeholders in accordance with Control Objective 12.1.",
          "function_names": []
        },
        {
          "id": "6.3.c",
          "description": "Where asymmetric cryptography such as RSA or ECC is used for protecting the confidentiality of sensitive data, the assessor shall examine evidence and test the software to confirm that private keys are not used for providing confidentiality protection to the data.",
          "function_names": []
        }
      ],
      "guidance": "Wherever cryptography is used to meet software security requirements in this standard, it must be done in accordance with the specific security requirements related to the use of cryptography (including those in Control Objective 7). For example, storing a cryptographic key used for protecting sensitive data in a plaintext file would not be considered sufficient security unless additional controls are implemented to prevent the file containing the cryptographic key from being accessed or modified by, or exposed to unauthorized parties. Further guidance on appropriate uses of cryptographic algorithms can be found in current versions of NIST SP 800-175 or in other related industry guidance from ISO or ANSI."
    },
    {
      "id": "7.1",
      "description": "Industry-standard cryptographic algorithms and methods are used for securing critical assets. Industry standard cryptographic algorithms and methods are those recognized by industry-accepted standards bodies such as NIST, ANSI, ISO, and EMVCo. Cryptographic algorithms and parameters that are known to be vulnerable are not used.",
      "tests": [
        {
          "id": "7.1.a",
          "description": "The assessor shall examine evidence to determine how cryptography is used for the protection of critical assets and to confirm that:",
          "bullets": [
            "Industry-standard cryptographic algorithms and modes of operation are used.",
            "The use of any other algorithms is in conjunction with industry-standard algorithms.",
            "The implementation of non-standard algorithms does not reduce the equivalent cryptographic key strength provided by the industry-standard algorithms."
          ]
        },
        {
          "guidance": "Not all cryptographic algorithms are sufficient to protect sensitive data. It is a well-established principle in software security to utilize only recognized cryptographic implementations based on current, industry-accepted standards such as those from industry bodies like NIST, ANSI, ISO, and EMVCo. The use of proprietary cryptographic implementations may increase the risk of data compromise as proprietary implementations are often not subjected to the same level of testing that industry-accepted implementations have undergone. Only those implementations that have been subjected to sufficient testing (for example, by NIST, ANSI, or other recognized industry bodies) should be used."
        },
        {
          "id": "7.1.b",
          "description": "The assessor shall examine evidence, including the vendor threat information obtained in Test Requirement 4.1.a, and test the software to confirm that:",
          "bullets": [
            "Only documented cryptographic algorithms and modes of operation are used in the software, and",
            "Protection methods are implemented to mitigate common attacks on cryptographic implementations (for example, the use of the software as a decryption oracle, brute-force or dictionary attacks against the input domain of the sensitive data, the re-use of security parameters such as IVs, or the re-encryption of multiple datasets using linearly applied key values, such as XOR’d key values in stream ciphers or one-time pads)."
          ]
        },
        {
          "id": "7.1.c",
          "description": "Where cryptographic implementations require a unique value per encryption operation or session, the assessor shall examine evidence and test the software to confirm that the cryptographic implementations do not expose vulnerabilities.",
          "example": "For example, this may include the use of a unique IV for a stream cipher mode of operation or a unique and random “k” value for a digital signature."
        },
        {
          "id": "7.1.d",
          "description": "Where padding is used prior to or during encryption, the assessor shall examine evidence and test the software to confirm that the encryption operation always incorporates an industry-accepted standard padding method."
        },
        {
          "id": "7.1.e",
          "description": "Where hash functions are used to protect sensitive data, the assessor shall examine evidence and test the software to confirm that:",
          "bullets": [
            "Only approved, collision-resistant hash algorithms and methods are used for this purpose, and",
            "A salt value of appropriate strength that is generated using a secure random number generator is used to ensure the resultant hash has sufficient entropy."
          ],
          "note": "The assessor should refer to Control Objective 7.3 for more information on secure random number generators."
        }
      ]
    },
    {
      "id": "7.2",
      "description": "The software supports industry standard key management processes and procedures. Industry standard key management processes and procedures are those recognized by industry standards bodies, such as NIST, ANSI, and ISO.",
      "tests": [
        {
          "id": "7.2.a",
          "description": "The assessor shall examine evidence to confirm that information is maintained that describes the following for each key specified in the inventory:",
          "bullets": [
            "Key label or name",
            "Key location",
            "Effective date",
            "Expiration date",
            "Key purpose/type",
            "Key generation method/algorithm used",
            "Key length"
          ]
        },
        {
          "guidance": "Whether implemented within or outside the software, the manner in which cryptographic keys are managed is a critical part of the continued security of payment software and the sensitive data it handles. While cryptographic key management processes are often implemented as operational procedures, the software should support secure key-management practices based on industry standards or best practices."
        },
        {
          "id": "7.2.b",
          "description": "The assessor shall examine evidence and test the software to validate the evidence examined in Test Requirement 7.2.a and to confirm that:",
          "bullets": [
            "All cryptographic keys that are used for providing security to critical assets (confidentiality, integrity, and authenticity) and other security services to the software have a unique purpose, and that no key is used for both encryption and authentication operations.",
            "All keys have defined generation methods, and no secret or private cryptographic keys relied upon for security of critical assets are shared between software instances, except when a common secret or private key is used for securing the storage of other cryptographic keys that are generated during the installation, initialization, or first use of the software (for example, white-box cryptography).",
            "All cryptographic keys have an equivalent bit strength of at least 128 bits in accordance with industry standards.",
            "All keys have a defined cryptoperiod aligned with industry standards, and methods are implemented to retire and/or update each key at the end of the defined cryptoperiod.",
            "The integrity and confidentiality of all secret and private cryptographic keys managed by the software are protected when stored (for example, encrypted with a key-encrypting key that is at least as strong as the data-encrypting key and is stored separately from the data-encrypting key, or as at least two full-length key components or key shares, in accordance with an industry-accepted method).",
            "All keys have a defined generation or injection process, and this process ensures sufficient entropy for the key.",
            "All key-generation functions must implement one-way functions or other irreversible key-generation processes, and no reversible key calculation modes (such as key variants) are used to directly create new keys from an existing key."
          ],
          "guidance": "Industry-standard key management practices should be applied to the following: The generation of strong cryptographic keys. Secure cryptographic key distribution. Secure cryptographic key storage. Cryptographic key changes for keys that have reached the end of their cryptoperiod. The retirement or replacement of keys. The enforcement of split knowledge and dual control (when the software supports manual clear-text cryptographic key-management operations). The prevention of unauthorized substitution of cryptographic keys. The implementation of a mechanism to render irretrievable any cryptographic key material or cryptogram stored by the payment software. This requirement applies to keys used to encrypt sensitive data and any respective key-encrypting keys."
        },
        {
          "id": "7.2.c",
          "description": "Where cryptography is used to protect a key, the assessor shall examine evidence and test the software to confirm that security is not provided to any key by a key of lesser strength (for example, by encrypting a 256-bit AES key with a 128-bit AES key)."
        },
        {
          "id": "7.2.d",
          "description": "Where public keys are used by the system, the assessor shall examine evidence and test the software to confirm that the authenticity of all public keys is preserved."
        },
        {
          "id": "7.2.e",
          "description": "Where public or white-box keys are not unique per software instantiation the assessor shall examine evidence to confirm that methods and procedures to revoke and/or replace such keys (or key pairs) exist."
        },
        {
          "id": "7.2.f",
          "description": "Where the software relies upon external files or other data elements for key material, such as for public TLS certificates, the assessor shall examine evidence to confirm that guidance on how to install such key material, including details noting any security requirements for such key material, is provided to stakeholders in accordance with Control Objective 12.1."
        },
        {
          "id": "7.2.g",
          "description": "Where public keys are manually loaded or used as root keys, the assessor shall examine evidence and test the software to confirm that the keys are installed and stored in a way that provides dual control (to a level that is feasible for the execution environment), preventing a single user from replacing a key to enable a man-in-the-middle attack or the allow for unauthorized decryption of stored data. Where complete dual control is not feasible (for example, due to a limitation of the execution environment), the assessor shall confirm that the methods implemented are appropriate to protect the public keys."
        },
        {
          "id": "7.2.h",
          "description": "The assessor shall examine evidence to confirm that secret and/or private keys are managed in a way that ensures split knowledge over the key to a level that is feasible given the platform on which the software is executed. Where absolute split knowledge is not feasible, the assessor shall confirm that the methods implemented are reasonable to protect secrets and/or private keys."
        }
      ]
    },
    {
      "id": "7.3",
      "description": "All random numbers used by the software are generated using only industry-standard random number generation (RNG) algorithms or libraries. Industry-standard RNG algorithms or libraries are those that meet industry standards for sufficient unpredictability (for example, NIST Special Publication 800-22).",
      "tests": [
        {
          "id": "7.3.a",
          "description": "The assessor shall examine evidence and test the software to identify all random number generators used by the software and to confirm that all random number generation methods:",
          "bullets": [
            "Use at least 128 bits of entropy prior to the output of any random numbers.",
            "Ensure it is not possible for the system to provide or produce reduced entropy upon start-up or entry of other predictable states of the system."
          ]
        },
        {
          "guidance": "Random numbers are often used with cryptography to protect sensitive information. Encryption keys and initialization values (seeds) are examples of implementations in which random numbers are required. It is not a trivial endeavor to design and implement a secure random number generator. Software vendors are required to use only approved random number generation algorithms and libraries or provide evidence to illustrate how the random number generation algorithms and libraries were tested to confirm that random numbers generated are sufficiently unpredictable. The implementation may rely on either a validated cryptographic library or module. The software vendor should have a good understanding of the installation, initialization, configuration, and usage (for example, initial seeding of the random function) of the RNG mechanisms to ensure that the implementation can meet the effective security strength required for the intended use."
        },
        {
          "id": "7.3.b",
          "description": "Where third-party software, platforms, or libraries are used for all or part of the random number generation process, the assessor shall examine evidence (such as current publicly available literature) to confirm that the third-party software does not expose any vulnerabilities that may compromise its use for generating random values."
        },
        {
          "id": "7.3.c",
          "description": "Where the software vendor relies on a previous assessment of the random number generator or source of initial entropy, the assessor shall examine evidence (such as the approval records of the previous assessment) to confirm that this scheme and specific approval include the correct areas of the software in the scope of its assessment, and that the vendor claims do not exceed the scope of the evaluation or approval of that software.",
          "example": "For example, some cryptographic implementations approved under FIPS 140-2 or 140-3 require seeding from an external entropy source to correctly output random data."
        },
        {
          "id": "7.3.d",
          "description": "Where the software vendor does not rely on a previous assessment of the random number generator or source of initial entropy, the assessor shall test the software to obtain 128MB of data output from each random number generator implemented in the system to confirm the lack of statistical correlation in the output. This data may be generated by the assessor directly, or supplied by the vendor, but the assessor must confirm that the generation method implemented ensures that the data is produced as it would be produced by the software during normal operation.",
          "note": "The assessor can use the NIST Statistical Test Suite to identify statistical correlation in the random number generation implementation."
        }
      ]
    },
    {
      "id": "7.4",
      "description": "Random values have entropy that meets the minimum effective strength requirements of the cryptographic primitives and keys that rely on them.",
      "tests": [
        {
          "id": "7.4.a",
          "description": "The assessor shall examine evidence and test the software to confirm that the methods used for the generation of all cryptographic keys and other material (such as IVs, “k” values for digital signatures, and so on) have entropy that meets the minimum effective strength requirements of the cryptographic primitives and keys."
        },
        {
          "guidance": "Entropy is the degree of randomness of a random value generator. The higher the entropy, the less predictable the next value in a random number generator is likely to be."
        },
        {
          "id": "7.4.b",
          "description": "Where cryptographic keys are generated through processes which require direct user interaction, such as through the entry of a passphrase or the use of “random” user interaction with the software, the assessor shall examine evidence and test the software to confirm that these processes are implemented in such a way that they provide sufficient entropy. Specifically, the assessor shall confirm that:",
          "bullets": [
            "Methods used for generating keys directly from a password/passphrase enforce an input domain that is able to provide sufficient entropy, such that the total possible inputs are at least equal to that of the equivalent bit strength of the key being generated (for example, a 32 hex-digit input field for an AES128 key).",
            "Passphrases are passed through an industry-standard key derivation function, such as PBKDF2 or bcrypt, which extends the work factor for any attempt to brute-force a passphrase value. The assessor shall confirm that a work factor of at least 10,000 is applied to any such implementation.",
            "Guidance is provided to stakeholders in accordance with Control Objective 12.1 that includes instructions that any passphrase used must: – Be randomly generated itself using a valid and secure random process, and that an online random number generator must not be used for this purpose. – Not be implemented by a single person, such that one person has an advantage in recovering the clear key value, violating the requirements for split knowledge."
          ]
        }
      ]
    },
    {
      "id": "8.1",
      "description": "All access attempts and usage of critical assets are tracked and traceable to a unique user.",
      "note": "This Secure Software Standard recognizes that some execution environments cannot support the detailed logging requirements in other PCI standards. Therefore, the term “activity tracking” is used here to differentiate the expectations of this standard with regards to logging from similar requirements in other PCI standards.",
      "requirements": [
        {
          "id": "8.1.a",
          "description": "The assessor shall examine evidence and test the software to confirm that all access attempts and usage of critical assets are tracked and traceable to a unique individual, system, or entity.",
          "function_names": []
        }
      ],
      "guidance": "To ensure user accountability and to support post-incident forensic investigation, payment software should capture and maintain historical records of all software activities involving critical assets and ensure that all such activities are traceable to a unique user (for example, a person, system, or other entity).\nExamples of activities that the software should record include:\n• All individual user attempts to access sensitive data or resources.\n• Usage of or changes to sensitive functions, such as the software’s identification and authentication mechanisms or activity tracking mechanisms.\n• Initialization, stopping, or pausing of sensitive functions.\nThis control objective does not mandate the logging of each encryption operation or function processing sensitive data, but it does require that access is tracked and any methods that may expose sensitive data are also tracked."
    },
    {
      "id": "8.2",
      "description": "All activity is captured in sufficient and necessary detail to accurately describe the specific activities that were performed, who performed them, the time they were performed, and the critical assets that were affected.",
      "requirements": [
        {
          "id": "8.2.a",
          "description": "The assessor shall examine evidence and test the software to confirm that the tracking method(s) implemented capture specific activity performed, including:\n• Enablement of any privileged modes of operation.\n• Disabling of encryption of sensitive data.\n• Decryption of sensitive data.\n• Exporting of sensitive data to other systems or processes.\n• Failed authentication attempts.\n• Disabling or deleting a security control or altering security functions.",
          "function_names": []
        },
        {
          "id": "8.2.b",
          "description": "The assessor shall examine evidence and test the software to confirm that the tracking method(s) implemented provide the following:\n• A unique identification for the individual, system, or entity accessing or using critical assets.\n• A timestamp for each tracked event.\n• Details on what critical asset has been accessed.",
          "function_names": []
        },
        {
          "id": "8.2.c",
          "description": "The assessor shall test the software to confirm that confidential data is not directly recorded in the tracking data.",
          "function_names": []
        }
      ],
      "guidance": "By recording the details in this requirement for all attempts to access or use critical assets, malicious activity or potential software or data compromise can be quickly identified and with sufficient detail to know who performed the activity, whether the attempt was successful, when the activity occurred, what critical assets were affected, and the origination of the event."
    },
    {
      "id": "8.3",
      "description": "The software supports secure retention of detailed activity records.",
      "requirements": [
        {
          "id": "8.3.a",
          "description": "Where the activity records are managed by the software, including only temporarily before being passed to other systems, the assessor shall examine evidence and test the software to confirm that the protection methods are implemented to protect completeness, accuracy, and integrity of the activity records.",
          "function_names": []
        },
        {
          "id": "8.3.b",
          "description": "Where the software utilizes external or third-party systems for the maintenance of tracking data, such as a log server, the assessor shall examine evidence to confirm that guidance on the correct and complete setup and/or integration of the software with the external or third-party system(s) is provided to stakeholders in accordance with Control Objective 12.1.",
          "function_names": []
        },
        {
          "id": "8.3.c",
          "description": "The assessor shall test the software to confirm methods are implemented to secure the authenticity of the tracking data during transmission to the log storage system, and to confirm that this protection meets the requirements of this standard (for example, authenticity parameters must be applied using strong cryptography) and any account or authentication parameters used for access to an external logging system are protected.",
          "function_names": []
        }
      ],
      "guidance": "In order to identify anomalous behavior and to enable forensic investigation upon suspicion of potential software or data compromise, the software must provide for the retention of detailed activity records either through native means (within the software itself) or support integration with other solutions such as centralized log servers, cloud-based logging solutions, or back-end monitoring solutions.\nWithout adequate protection of activity records, their completeness, accuracy, and integrity cannot be guaranteed and any reliance that would otherwise be placed on them (such as during a forensic investigation) would be negated.\nWhen activity records are managed by the software, the records must be protected in accordance with all applicable requirements for the protection of sensitive data."
    },
    {
      "id": "8.4",
      "description": "The software handles failures in activity-tracking mechanisms such that the integrity of existing activity records is preserved.",
      "requirements": [
        {
          "id": "8.4.a",
          "description": "The assessor shall examine evidence and test the software to confirm that the failure of the activity-tracking mechanism(s) does not violate the integrity of existing records by confirming that:\n• The software does not overwrite existing tracking data upon a restart of the software. Each new start shall only append to existing datasets or shall create a new tracking dataset.\n• Where unique dataset names are relied upon for maintaining integrity between execution instances, the implementation ensures that other software (including another instance of the same software) cannot overwrite or render invalid existing datasets.\n• The software applies, where possible, suitable file privileges to assist with maintaining the integrity of the tracking dataset (such as applying an append-only access control to a dataset once created). Where the software does not apply such controls, the assessor shall confirm reasonable justification exists describing why this is the case, why the behavior is sufficient, and what additional mitigations are applied to maintain the integrity of the tracking data.",
          "function_names": []
        },
        {
          "id": "8.4.b",
          "description": "The assessor shall examine evidence and test the software to confirm that the integrity of activity tracking records is maintained by:\n• Performing actions that should be tracked, force-closing and then restarting the software, and performing other tracked actions.\n• Performing actions that should be tracked, power-cycling the platform on which the software is executing, and then restarting the software and performing other tracked actions.\n• Locking access to the tracking dataset and confirming that the software handles the inability to access this dataset in a secure way, such as by creating a new dataset or preventing further use of the software.\n• Preventing the creation of new dataset entries by preventing further writing to the media on which the dataset is located (for example, by using media that has insufficient available space).\nWhere any of the tests above are not possible, the assessor shall interview personnel to confirm reasonable justification exists to describe why this is the case and shall confirm protections are in place to prevent such scenarios from affecting the integrity of the tracking records.",
          "function_names": []
        }
      ],
      "guidance": "Software security controls should be implemented to ensure that when activity-tracking mechanism(s) fail, those failures are handled in a way that maintains the integrity of the records. Otherwise, attackers may intentionally target activity-tracking mechanisms and cause failures that would allow the attackers to conceal or overwrite evidence of their activities."
    },
    {
      "id": "9.1",
      "description": "The software detects and alerts upon detection of anomalous behavior, such as changes in post-deployment configurations or obvious attack behavior.",
      "requirements": [
        {
          "id": "9.1.a",
          "description": "The assessor shall examine evidence and test the software to confirm that methods are implemented to validate the integrity of software executables and any configuration options, files, and datasets that the software relies upon for operation such that unauthorized post-deployment changes are detected.\nWhere the execution environment prevents this, the assessor shall examine evidence (including publicly available literature on the platform and associated technologies) to confirm that there are indeed no methods for validating authenticity, and that additional security controls are implemented to minimize the associated risk.",
          "function_names": []
        },
        {
          "id": "9.1.b",
          "description": "The assessor shall examine evidence and test the software to confirm that integrity values used by the software and dataset(s) upon which it relies for secure operation are checked upon software execution, and at least every 36 hours thereafter (if the software continues execution during that time period).",
          "function_names": []
        },
        {
          "id": "9.1.c",
          "description": "Where cryptographic primitives are used by any anomaly detection methods, the assessor shall examine evidence and test the software to confirm that the cryptographic primitives are protected.",
          "function_names": []
        },
        {
          "id": "9.1.d",
          "description": "Where stored values are used by any anomaly detection methods, the assessor shall examine evidence and test the software to confirm that these values are considered sensitive data and are protected accordingly.",
          "function_names": []
        },
        {
          "id": "9.1.e",
          "description": "Where configuration or other dataset values can be modified by the software during execution, the assessor shall examine evidence and test the software to confirm that integrity protections are implemented to allow for this update while still ensuring dataset integrity can be validated after the update.",
          "function_names": []
        },
        {
          "id": "9.1.f",
          "description": "The assessor shall examine evidence and test the software to confirm that the software implements controls to prevent brute-force attacks on account, password, or cryptographic-key input fields (for example, input rate limiting).",
          "function_names": []
        },
        {
          "id": "9.1.g",
          "description": "Where third-party tools or services are relied upon by the software to provide attack detection capabilities, the assessor shall examine evidence to confirm that guidance on how to configure such tools and services to support this control objective is provided to stakeholders in accordance with Control Objective 12.1.",
          "function_names": []
        }
      ],
      "guidance": "Software should possess basic functionality to differentiate between normal and anomalous user behavior. Examples of anomalous behavior that should be automatically detected by the software include changes in post-deployment (or post-initialization) configurations or obvious automated-attack behaviors, such as repeated authentication attempts at a frequency that is infeasible for a human user.\nIn some cases, it may be impractical to implement these capabilities directly into payment software, and third-party tools or services may be required. Where such tools or services are relied upon, the software vendor must provide guidance (or direction on where appropriate guidance may be obtained) that describes how and to what extent third-party tools and services should be configured to satisfy the control objective and associated test requirements."
    },
    {
      "id": "10.1",
      "description": "Software threats and vulnerabilities are identified, assessed, and addressed.",
      "requirements": [
        {
          "id": "10.1.a",
          "description": "Using information obtained in Test Requirement 4.1.a, the assessor shall examine evidence to confirm that common attack methods against the software are identified. This may include platform-level, protocol-level, and/or language-level attacks.",
          "function_names": []
        },
        {
          "id": "10.1.b",
          "description": "The assessor shall examine evidence to confirm that the identified attacks are valid for the software and shall note where this does not include common attack methods detailed in industry-standard references such as OWASP and CWE lists.",
          "function_names": []
        },
        {
          "id": "10.1.c",
          "description": "The assessor shall examine evidence to confirm that mitigations against each identified attack are implemented, and that the software release process includes ongoing validation of the existence of these mitigations.",
          "function_names": []
        }
      ],
      "guidance": "Determining how to effectively secure and defend the software against attacks requires a thorough understanding of the specific threats and potential vulnerabilities applicable to the vendor’s software.\nThis typically involves understanding the following:\n• The types of information collected, stored, processed, or transmitted by the software.\n• The motivations an attacker may have for attacking the software.\n• The methods an attacker might utilize or the vulnerabilities an attacker might try to exploit during an attack.\n• The exploitability of any identified vulnerabilities.\n• The impact a successful attack.\nThe identified threats and vulnerabilities should be tracked, assigned to responsible personnel, and fixed or mitigated prior to payment software release.\nFor guidance on threat analysis and cyber-resiliency design principles, refer to industry standards and guidance, such as the current version of NIST Special Publication 800-160."
    },
    {
      "id": "10.2",
      "description": "Vulnerabilities in the software and third-party components are tested for and fixed prior to release.",
      "requirements": [
        {
          "id": "10.2.a",
          "description": "The assessor shall examine evidence to confirm that robust testing processes are used throughout the software lifecycle to manage vulnerabilities in software and to verify that the mitigations used to secure the software against attacks remain in place and are effective.",
          "function_names": []
        },
        {
          "id": "10.2.b",
          "description": "The assessor shall examine evidence including documented testing processes and output of several instances of the testing to confirm that the testing process:\n• Includes, at a minimum, the use of automated tools capable of detecting vulnerabilities both in software code and during software execution.\n• Includes the use of security testing tools that are suitable for the software architecture, development languages, and frameworks used in the development of the software.\n• Demonstrates a history of finding software vulnerabilities and remediating them prior to software release.\n• Accounts for the entire code base and detects vulnerabilities in third-party, open-source, or shared components and libraries.\n• Accounts for common vulnerabilities and attack methods.",
          "function_names": []
        },
        {
          "id": "10.2.c",
          "description": "Where evidence examined in Test Requirement 10.2.b shows the release of software with known vulnerabilities, the assessor shall examine further evidence to confirm that:\n• An industry-standard vulnerability-ranking system (such as CVSS) is used to classify/categorize vulnerabilities.\n• A remediation plan is maintained for all detected vulnerabilities that ensures vulnerabilities do not remain unmitigated for an indefinite period.",
          "function_names": []
        }
      ],
      "guidance": "Most software vulnerabilities are introduced as a result of coding errors, bad design, improper implementation, or the use of vulnerable components.\nSoftware should be developed and tested in a manner that minimizes the existence of any vulnerabilities and detects those that emerge over time, such that the vulnerabilities may be addressed before the software is released or updated.\nTechniques to avoid the introduction of vulnerabilities during development include the use of security coding practices, testing code during each phase of the development lifecycle using automated tools (such as static/dynamic analysis tools and interactive security testing tools), and the use of known secure components (for example, common code that has already undergone significant security vetting).\nTo minimize the introduction of software vulnerabilities from third-party components, those components must also be evaluated. Ideally, they should be subject to the same secure development and testing processes as the software created by the vendor.\nSecurity testing should be performed by appropriately skilled vendor personnel or third parties. In addition, security testing personnel should be able to conduct tests in an objective manner and be authorized to escalate any identified vulnerabilities to appropriate management or development personnel, so they can be properly addressed."
    },
    {
      "id": "11.1",
      "description": "Software updates to fix known vulnerabilities are made available to stakeholders in a timely manner.",
      "requirements": [
        {
          "id": "11.1.a",
          "description": "The assessor shall examine evidence to confirm that:\n• Reasonable criteria are defined for releasing software updates to fix security vulnerabilities.\n• Security updates are made available to stakeholders in accordance with the defined criteria.",
          "function_names": []
        },
        {
          "id": "11.1.b",
          "description": "The assessor shall examine evidence, including update-specific security-testing results and details, to confirm that security updates are made available to stakeholders in accordance with the defined criteria. Where updates are not provided in accordance with the defined criteria, the assessor shall confirm that such instances are justified and reasonable.",
          "function_names": []
        }
      ],
      "guidance": "Vulnerabilities in software should be fixed as soon as possible to enable software users and other stakeholders to address any risks before vulnerabilities in their payment systems and software can be exploited by attackers.\nVulnerabilities should be addressed in a manner that is commensurate with the risk they pose to software users or other stakeholders. The most critical or severe vulnerabilities (those with the highest exploitability and the greatest potential impact to stakeholders) should be patched immediately, followed by those with moderate-to-low exploitability or potential impact. The criteria for determining how and when to make patches available to stakeholders should be defined and followed."
    },
    {
      "id": "11.2",
      "description": "Software releases and updates are delivered in a secure manner that ensures the integrity of the software code.",
      "requirements": [
        {
          "id": "11.2.a",
          "description": "The assessor shall examine evidence to confirm that the method(s) by which the vendor releases software updates maintain the integrity of the software code during transmission and installation.",
          "function_names": []
        },
        {
          "id": "11.2.b",
          "description": "Where user input or interaction is required to validate the integrity of the software code, the assessor shall examine evidence to confirm that guidance on this process is provided to stakeholders in accordance with Control Objective 12.1.",
          "function_names": []
        },
        {
          "id": "11.2.c",
          "description": "Where the integrity method implemented is not cryptographically secure, the assessor shall examine evidence to confirm that the software distribution method provides a chain of trust, such as through use of a TLS connection that provides compliant cipher-suite implementations.",
          "function_names": []
        },
        {
          "id": "11.2.d",
          "description": "The assessor shall examine vendor evidence to confirm that stakeholders are notified of software updates, and that guidance on how they may be obtained and installed is provided to stakeholders in accordance with Control Objective 12.1.",
          "function_names": []
        },
        {
          "id": "11.2.e",
          "description": "The assessor shall examine evidence to confirm that stakeholders are notified when known vulnerabilities are detected in software that has not yet been updated with a fix. This includes vulnerabilities that may exist in third-party software and libraries used by the software. The assessor shall confirm that this process includes providing the stakeholders with suggested mitigations for any such vulnerabilities.",
          "function_names": []
        },
        {
          "id": "11.2.f",
          "description": "The assessor shall examine evidence to confirm that the software update mechanisms cover all software, configuration files, and other metadata that may be used by the software for security purposes or which may in some way affect the security of the software.",
          "function_names": []
        }
      ],
      "guidance": "Security updates should include a mechanism within the update process to verify the update code has not been replaced or tampered with. Examples of integrity checks include, but are not limited to, checksums and digitally signed certificates (where implemented correctly). Verification could be implemented within the software itself or through guidance that is provided to stakeholders to direct them on the manual verification of software updates.\nIn addition, the process of distributing updates and patches should prevent malicious individuals from intercepting the updates in transit, modifying them, and then redistributing them to unsuspecting stakeholders."
    },
    {
      "id": "12.1",
      "description": "The software vendor provides stakeholders with clear and thorough guidance on the secure implementation, configuration, and operation of its payment software.",
      "requirements": [
        {
          "id": "12.1.a",
          "description": "The assessor shall examine evidence to confirm that the vendor creates and provides stakeholders, clear and sufficient guidance to allow for the secure installation, configuration, and use of the software.",
          "function_names": []
        },
        {
          "id": "12.1.b",
          "description": "The assessor shall examine evidence to confirm that the guidance:\n• Includes details on how to securely and correctly install any third-party software that is required for the operation of the vendor software.\n• Provides instructions on the correct configuration of the platform(s) on which the software is to be executed, including setting security parameters and installation of any data elements (such as certificates).\n• Includes instructions for key management (for example, the use of keys and how they are distributed, loaded, removed, changed, and destroyed.)\n• Does not instruct the user to disable security settings or parameters within the installed environment, such as anti-malware software or firewall or other network-level protection systems.\n• Does not instruct the user to execute the software in a privileged mode higher than what is required by the software.\n• Provides details on how to validate the version of the software and clearly indicates for which version(s) of the software the guidance is written.\n• Provides justification for any requirements in this standard that are to be assessed as not applicable. For each of these, the assessor shall confirm justification exists for why this is the case and shall confirm that it agrees with their understanding and the results of their software testing.",
          "function_names": []
        }
      ],
      "guidance": "When followed, the software vendor's implementation guidance provides assurance that the software and patches can be securely installed, configured, and maintained in a customer environment, and that all desired security functions are active and working as intended. The guidance should cover all options and functions available to software users that could affect the security of the software or the data it interacts with. The guidance should also include secure configuration options for any components provided with or supported by the software, such as external software and underlying platforms.\nExamples of configurable options include:\n• Changing default credentials and passwords.\n• Enabling and disabling software accounts, services, and features.\n• Changes in resource access permissions.\n• Integration with third-party cryptographic libraries, random number generators, and so on.\nThe provided guidance should result in a secure configuration across all supported platforms and all configurable options."
    },
    {
      "id": "A.1",
      "description": "Sensitive Authentication Data (SAD) is not retained after authorization.",
      "requirements": [
        {
          "id": "A.1.1",
          "description": "The software does not store sensitive authentication data after authorization (even if encrypted) unless the software is intended only for use by issuers or organizations that support issuing services.",
          "test_requirements": "Using information obtained in Test Requirement 1.1.a in the Core Requirements section, the assessor shall examine evidence and test the software to identify all potential storage locations for Sensitive Authentication Data, and to confirm that the software does not store such data after transaction authorization is complete. This includes storage of SAD in temporary storage (such as volatile memory), semi-permanent storage (such as RAM disks), and non-volatile storage (such as magnetic and flash storage media). Where Sensitive Authentication Data is stored after authorization, the assessor shall examine evidence to confirm that the software is designed explicitly for issuing purposes or for use by issuers or organizations that support issuing services.",
          "function_names": []
        }
      ],
      "guidance": "Sensitive authentication data consists of full track data, card validation code or value, and PIN data. Storage of sensitive authentication data after authorization is prohibited. This data is valuable to malicious individuals as it allows them to generate counterfeit payment cards and create fraudulent transactions. Testing should include at least the following types of files, as well as any other output generated by the payment software: Incoming transaction data, All logs (transaction, history, debugging, error), History files, Trace files, Audio and image files (digital voice and biometrics), Non-volatile memory (including cache), Database schemas, Database contents."
    },
    {
      "id": "A.2",
      "description": "Stored cardholder data is protected.",
      "requirements": [
        {
          "id": "A.2.1",
          "description": "The software vendor provides guidance to stakeholders regarding secure deletion of cardholder data after expiration of defined retention period(s).",
          "test_requirements": "The assessor shall examine evidence to confirm that guidance is provided to stakeholders in accordance with Control Objective 12.1 that details: All locations where the software stores cardholder data; How to securely delete cardholder data stored by the payment software, including cardholder data stored on underlying software or systems (such as in OS files or in databases); How to configure the underlying software or systems to prevent the inadvertent capture or retention of cardholder data (for example, by system backup or restore points).",
          "function_names": []
        },
        {
          "id": "A.2.2.a",
          "description": "The software provides features to restrict or otherwise mask all displays of PAN to the minimum number of digits required.",
          "test_requirements": "The assessor shall examine evidence to confirm that the software provides features that enable responsible parties to restrict or otherwise mask the display of PAN to the minimum number of digits required to meet a defined business need.",
          "function_names": []
        },
        {
          "id": "A.2.2.b",
          "description": "The software provides features to restrict or otherwise mask all displays of PAN to the minimum number of digits required.",
          "test_requirements": "The assessor shall examine evidence to confirm that all displays of PAN are completely masked by default, and that explicit authorization is required to display any digits of the PAN.",
          "function_names": []
        },
        {
          "id": "A.2.2.c",
          "description": "Where user input or interaction is required to configure PAN masking features and options, the assessor shall examine evidence to confirm that guidance on how to configure these features/options is provided to stakeholders in accordance with Control Objective 12.1.",
          "test_requirements": "The assessor shall examine evidence to confirm that guidance on configuring PAN masking options is provided to stakeholders.",
          "function_names": []
        },
        {
          "id": "A.2.2.d",
          "description": "The assessor shall test the software to confirm that all displays of PAN are completely masked by default, and that explicit authorization is required to display any element of the PAN.",
          "test_requirements": "The assessor shall test the software to confirm PAN masking is enforced by default and requires explicit authorization for display.",
          "function_names": []
        },
        {
          "id": "A.2.3.a",
          "description": "PAN is rendered unreadable anywhere it is stored (including data on portable digital media, backup media, and in logs) by using truncation, index tokens and pads, or strong cryptography with associated key-management processes and procedures.",
          "test_requirements": "The assessor shall examine evidence and test the software to confirm that methods are implemented to render PAN unreadable anywhere it is stored using truncation, index tokens and pads (with pads securely stored), or strong cryptography with associated key-management processes. The assessor should examine tables, files, log files, and other resources created or generated by the software to verify that PAN is unreadable.",
          "function_names": []
        },
        {
          "id": "A.2.3.b",
          "description": "Where user input or interaction is required to configure methods to render PAN unreadable when stored, the assessor shall examine evidence to confirm that guidance on configuring these options is provided to stakeholders in accordance with Control Objective 12.1.",
          "test_requirements": "The assessor shall confirm that stakeholders are provided with details of configurable options, instructions for configuring methods across all storage locations, a list of instances where PAN may be output for storage outside of the payment application, and instructions on protection of debugging logs.",
          "function_names": []
        },
        {
          "id": "A.2.3.c",
          "description": "Where software creates both tokenized and truncated versions of the same PAN, the assessor shall examine evidence and test the software to confirm that the tokenized and truncated versions cannot be correlated to reconstruct the original PAN.",
          "test_requirements": "The assessor shall test and confirm that tokenized and truncated PAN values cannot be correlated to reconstruct the full PAN.",
          "function_names": []
        },
        {
          "id": "A.2.3.d",
          "description": "Where software creates or generates files for use outside the software (for example, files generated for export or backup, including on removable media), the assessor shall examine evidence and test the software to confirm that PAN is rendered unreadable.",
          "test_requirements": "The assessor shall test files generated for use outside the software and confirm PAN is rendered unreadable.",
          "function_names": []
        },
        {
          "id": "A.2.3.e",
          "description": "If the software vendor stores PAN for any reason (for example, log files, debugging files, or customer data received for troubleshooting), the assessor shall examine evidence and test the software to confirm that PAN is rendered unreadable in accordance with this control objective.",
          "test_requirements": "The assessor shall confirm PAN stored by the vendor in any form is rendered unreadable in compliance with control objectives.",
          "function_names": []
        }
      ],
      "guidance": "The software vendor must provide details of all locations where the software may store cardholder data, including underlying systems such as OS and databases, as well as instructions for securely deleting data after retention periods. Stakeholders must also be given configuration details for underlying systems to prevent inadvertent capture. Masking of PAN should always limit display to the minimum digits required for business needs (for example, only last four). PAN must be rendered unreadable when stored using truncation, index tokens and pads, or strong cryptography. Debugging logs containing PAN must be protected and securely deleted after use. Tokenized and truncated PAN values must not be correlatable. Files generated for external use must also have PAN unreadable."
    },
    {
      "id": "B.1",
      "description": "Terminal Software Documentation",
      "requirements": [
        {
          "id": "B.1.1",
          "description": "The software vendor maintains documentation that describes all software components, interfaces, and services provided or used by the software.",
          "test_requirements": "The assessor shall examine evidence to confirm that documentation is maintained that describes the software’s overall design and function including all third-party and open-source components, external services, and APIs used by the software, as well as all User Interfaces (UI) and APIs provided or made accessible by the software.",
          "guidance": "Software vendors should maintain detailed documentation that clearly and effectively describes the overall design and function of its software, including all services (internal and external), components, and functions, and how those services, components, and functions interact.",
          "function_names": []
        },
        {
          "id": "B.1.2",
          "description": "The software vendor maintains documentation that describes all data flows and functions that involve sensitive data. Note: This control objective is an extension of Control Objectives 1.1 and 1.2. Validation should be performed at the same time.",
          "requirements": [
            {
              "id": "B.1.2.a",
              "description": "The assessor shall examine evidence to confirm that documentation is maintained that describes all sensitive data flows.",
              "test_requirements": "The assessor shall confirm documentation describes all sensitive data flows, including all sensitive data stored, processed, or transmitted by the software; all storage locations (temporary and persistent); and how sensitive data is securely deleted from storage when no longer needed.",
              "guidance": "Software vendors should maintain documentation that clearly identifies and describes the types of data stored, processed, and transmitted by the software; how data is shared between components and functions; and the protection mechanisms implemented to safeguard that data. This documentation clarifies how data is stored, processed, or transmitted, with whom it is shared, and potential attack vectors to access critical software assets."
            },
            {
              "id": "B.1.2.b",
              "description": "The assessor shall examine evidence to confirm that documentation is maintained that describes all functions that handle sensitive data.",
              "test_requirements": "The assessor shall confirm documentation describes all functions handling sensitive data, including all inputs, outputs, and possible error conditions for each function, as well as all cryptographic algorithms, modes of operation, and associated key management practices for all functions that employ cryptography to protect sensitive data.",
              "guidance": ""
            }
          ],
          "guidance": "",
          "function_names": []
        },
        {
          "id": "B.1.3",
          "description": "The software vendor maintains documentation that describes all configurable options that can affect the security of sensitive data.",
          "test_requirements": "The assessor shall confirm documentation describes all configurable options provided or made available by the software that can impact the security of sensitive data, including options that allow access to sensitive data, enable modification of protection mechanisms, remote access features, remote update features, and the default settings for each configurable option.",
          "guidance": "Software vendors should identify all configurable options within their software, particularly those controlling security features and functions. Configurable features must be considered potential attack vectors. Where configurable options enable control over security features, robust security controls should protect them from misuse. All configurable options should be configured to their most secure settings by default in accordance with Control Objective 2.",
          "function_names": []
        }
      ],
      "guidance": "The software architecture is documented and includes diagrams that describe all software components and services in use and how they interact."
    },
    {
      "id": "B.2",
      "description": "Terminal Software Design",
      "requirements": [
        {
          "id": "B.2.1",
          "description": "The software is intended for deployment and operation on payment terminals (PCI-approved POI devices).",
          "test_requirements": "The assessor shall examine evidence to determine the payment terminals upon which the software is to be deployed. For each terminal, compare device characteristics with PCI SSC’s List of Approved PTS Devices (model name/number, PTS approval number, hardware version number, firmware version number).",
          "guidance": "Payment terminals provide high confidentiality and integrity protection for payment data and transactions. Software should use approved terminal features rather than implementing equivalent features to avoid introducing vulnerabilities.",
          "function_names": []
        },
        {
          "id": "B.2.2",
          "description": "The software uses only the external communication methods included in the payment terminal’s PTS device evaluation.",
          "requirements": [
            {
              "id": "B.2.2.a",
              "description": "The assessor shall examine evidence (including source code) to determine whether the software supports external communications.",
              "test_requirements": "",
              "guidance": "Software must use device-provided security features for external communication. It must not implement its own communication methods to avoid introducing vulnerabilities."
            },
            {
              "id": "B.2.2.b",
              "description": "The assessor shall examine all relevant payment terminal documentation to determine which external communication methods were included in the PTS evaluation.",
              "test_requirements": "",
              "guidance": ""
            },
            {
              "id": "B.2.2.c",
              "description": "The assessor shall confirm that the software uses only the external communication methods included in the PTS evaluation.",
              "test_requirements": "",
              "guidance": ""
            },
            {
              "id": "B.2.2.1",
              "description": "Where the software relies on the Open Protocols feature, it is developed according to the payment terminal vendor’s security guidance/policy.",
              "test_requirements": "Examine terminal documentation and software design/process documentation to confirm adherence to vendor guidance.",
              "guidance": "Vendor security guidance ensures compliance with PCI PTS POI Open Protocol and other PTS requirements."
            },
            {
              "id": "B.2.2.2",
              "description": "The software does not circumvent, bypass, or add services/protocols to the Open Protocols of the payment terminal.",
              "test_requirements": "Examine evidence (including source code) to confirm no circumvention or addition of link layer protocols, IP protocols, security protocols, or IP services.",
              "guidance": "Open Protocol requirements prevent vulnerabilities that can be remotely exploited. Adding services or failing to follow vendor guidance invalidates the device’s approval."
            }
          ],
          "function_names": []
        },
        {
          "id": "B.2.3",
          "description": "The software does not bypass or render ineffective any encryption methods or account data security methods implemented by the payment terminal.",
          "requirements": [
            {
              "id": "B.2.3.a",
              "description": "Examine evidence to determine whether the software provides encryption, and confirm it does not bypass terminal encryption.",
              "test_requirements": "",
              "guidance": "Payment terminals provide robust cryptographic and key management functions. Software must not bypass terminal encryption methods."
            },
            {
              "id": "B.2.3.b",
              "description": "Examine terminal documentation to determine which encryption methods are provided by the terminal.",
              "test_requirements": "",
              "guidance": ""
            },
            {
              "id": "B.2.3.c",
              "description": "Confirm that the software does not bypass or render ineffective any terminal encryption methods.",
              "test_requirements": "",
              "guidance": ""
            },
            {
              "id": "B.2.3.d",
              "description": "Where the software provides encryption and terminal is not required to provide approved encryption methods, confirm that strong cryptography is used.",
              "test_requirements": "Examine source code to confirm encryption methods provide strong cryptography in accordance with Control Objectives 7.1 and 7.2.",
              "guidance": ""
            }
          ],
          "function_names": []
        },
        {
          "id": "B.2.4",
          "description": "The software uses only the random number generation functions included in the terminal’s PTS evaluation for all cryptographic operations and does not implement its own RNG.",
          "requirements": [
            {
              "id": "B.2.4.a",
              "description": "Examine evidence to determine whether the software requires random values for cryptographic operations.",
              "test_requirements": "",
              "guidance": "Unpredictable random numbers are critical for cryptographic effectiveness. Terminal software should only use device RNG functions."
            },
            {
              "id": "B.2.4.b",
              "description": "Examine terminal documentation to determine all RNG functions included in the PTS evaluation.",
              "test_requirements": "",
              "guidance": ""
            },
            {
              "id": "B.2.4.c",
              "description": "Confirm that the software uses only the RNG functions included in the PTS evaluation and does not implement its own.",
              "test_requirements": "",
              "guidance": ""
            }
          ],
          "function_names": []
        },
        {
          "id": "B.2.5",
          "description": "The software does not provide sharing of clear-text account data directly with other software (except terminal firmware).",
          "requirements": [
            {
              "id": "B.2.5.a",
              "description": "Examine evidence to determine all logical interfaces and their functions, including those for sharing clear-text account data with firmware.",
              "test_requirements": "",
              "guidance": "Software providing its own mechanisms for sharing clear-text account data increases risk. Use terminal-provided SRED functions."
            },
            {
              "id": "B.2.5.b",
              "description": "Confirm that the software does not allow sharing of clear-text account data directly with other software.",
              "test_requirements": "",
              "guidance": ""
            },
            {
              "id": "B.2.5.c",
              "description": "Install and test the software to confirm it does not share clear-text account data directly with other software.",
              "test_requirements": "Use appropriate test platform and forensic tools according to Control Objectives 12.1 and B.5.1.",
              "guidance": ""
            }
          ],
          "function_names": []
        },
        {
          "id": "B.2.6",
          "description": "The software uses and integrates all shared resources securely and according to the terminal vendor’s security guidance/policy.",
          "requirements": [
            {
              "id": "B.2.6.a",
              "description": "Examine evidence to determine whether and how the software uses shared resources and confirm secure integration.",
              "test_requirements": "",
              "guidance": "Failure to use shared resources according to guidance risks unauthorized disclosure of sensitive data."
            },
            {
              "id": "B.2.6.b",
              "description": "Install and test the software to confirm all connections to or use of shared resources are secure.",
              "test_requirements": "Use appropriate test platform and forensic tools according to Control Objectives 12.1 and B.5.1.",
              "guidance": ""
            }
          ],
          "function_names": []
        },
        {
          "id": "B.2.7",
          "description": "The software does not bypass or render ineffective any application segregation enforced by the terminal.",
          "requirements": [
            {
              "id": "B.2.7.a",
              "description": "Examine terminal documentation to determine how application segregation is enforced.",
              "test_requirements": "",
              "guidance": "Logical application segregation prevents one application from tampering with others or the firmware. Terminal software must adhere to segregation controls."
            },
            {
              "id": "B.2.7.b",
              "description": "Confirm that the software does not introduce functions to bypass application segregation controls.",
              "test_requirements": "",
              "guidance": ""
            }
          ],
          "function_names": []
        },
        {
          "id": "B.2.8",
          "description": "All software files are cryptographically signed to enable cryptographic authentication by the terminal firmware.",
          "requirements": [
            {
              "id": "B.2.8.a",
              "description": "Examine guidance to confirm detailed instructions for cryptographically signing software files.",
              "test_requirements": "",
              "guidance": "All binaries, libraries, and configuration files must be signed using digital certificates including the terminal vendor in the certificate chain. Signing should use secure cryptographic devices under dual control."
            },
            {
              "id": "B.2.8.b",
              "description": "Install and configure the software to confirm all software files are cryptographically signed.",
              "test_requirements": "Use test platform and forensic tools according to Control Objectives 12.1 and B.5.1.",
              "guidance": ""
            },
            {
              "id": "B.2.8.c",
              "description": "For files outside the base software package, confirm each is cryptographically signed or justify why not.",
              "test_requirements": "",
              "guidance": ""
            },
            {
              "id": "B.2.8.d",
              "description": "Confirm EMV payment transactions’ Certificate Authority public keys are cryptographically signed.",
              "test_requirements": "Install and configure software according to Control Objectives 12.1 and B.5.1 and test using appropriate platform and tools.",
              "guidance": "EMV CA public keys should be signed and authenticated using the same methods as terminal software files."
            }
          ],
          "function_names": []
        },
        {
          "id": "B.2.9",
          "description": "The integrity of software prompt files is protected in accordance with B.2.8.",
          "requirements": [
            {
              "id": "B.2.9.a",
              "description": "Examine evidence to determine if the software supports data entry prompts or prompt files and confirm integrity protection.",
              "test_requirements": "",
              "guidance": "Prompt files control data entry, including PIN/account data. They should be stored and managed securely to preserve integrity."
            },
            {
              "id": "B.2.9.b",
              "description": "Confirm guidance includes detailed instructions for cryptographically signing all prompt files.",
              "test_requirements": "",
              "guidance": ""
            },
            {
              "id": "B.2.9.c",
              "description": "Install and test the software to confirm all prompt files are cryptographically signed and authenticated.",
              "test_requirements": "Use appropriate test platform and forensic tools according to Control Objectives 12.1 and B.5.1.",
              "guidance": "When prompt files are stored in shared storage, they should be cryptographically signed and authenticated by the terminal before execution."
            }
          ],
          "function_names": []
        }
      ],
      "guidance": "The software must not implement any feature that circumvents or renders ineffective the security features, functions, and characteristics of the payment terminal."
    },
    {
      "id": "B.3",
      "description": "Terminal Software Attack Mitigation",
      "requirements": [
        {
          "id": "B.3.1",
          "description": "The software validates all user and other external inputs.",
          "note": "Control Objectives B.3.1 through B.3.3 are extensions of Control Objective 4.2. Validation should be performed at the same time.",
          "requirements": [
            {
              "id": "B.3.1.a",
              "description": "Examine evidence (including source code) to identify all locations where the software accepts input from untrusted sources. Confirm inputs conform to expected characteristics, and all non-conforming input is rejected or securely handled.",
              "guidance": "Externally supplied data is a potential attack vector. Injection attacks manipulate input to cause software to behave unexpectedly. All input data should be validated, filtered, and/or sanitized before processing. Terminal software inputs should be validated against a defined set of acceptable values."
            },
            {
              "id": "B.3.1.b",
              "description": "Install and test the software by supplying invalid or unexpected input characteristics to confirm that the software validates all inputs and either rejects or securely handles them.",
              "test_requirements": "Use appropriate test platform and forensic tools according to Control Objectives 12.1 and B.5.1."
            },
            {
              "id": "B.3.1.1",
              "description": "All string values are validated by the software.",
              "requirements": [
                {
                  "id": "B.3.1.1.a",
                  "description": "Identify all functions where string values are passed as inputs and confirm that all strings are checked to prevent erroneous or malicious interpretation as commands.",
                  "guidance": "Inputs interpreted as commands are susceptible to injection attacks. Even transformed or sanitized inputs may still be vulnerable."
                },
                {
                  "id": "B.3.1.1.b",
                  "description": "Test the software by supplying inputs that include commands to confirm the software rejects or securely handles such inputs.",
                  "guidance": "All inputs that can be interpreted as commands must be handled securely to prevent execution of arbitrary commands."
                }
              ]
            },
            {
              "id": "B.3.1.2",
              "description": "The software checks inputs and rejects or securely handles any inputs that violate buffer size or memory allocation thresholds.",
              "requirements": [
                {
                  "id": "B.3.1.2.a",
                  "description": "Identify all functions handling buffers and confirm each function: uses unsigned variables for buffer sizes; checks that buffers are sized appropriately; rejects or securely handles inputs that violate buffer or memory thresholds.",
                  "guidance": "Low-level languages like C/C++ allow direct manipulation of OS/hardware features, making software susceptible to buffer overflow/underflow attacks. Buffer sizes should be validated against data size."
                },
                {
                  "id": "B.3.1.2.b",
                  "description": "Test the software by supplying inputs that violate buffer size thresholds to confirm that it rejects or securely handles such attempts.",
                  "test_requirements": "Use appropriate test platform and forensic tools according to Control Objectives 12.1 and B.5.1."
                }
              ]
            }
          ],
          "function_names": []
        },
        {
          "id": "B.3.2",
          "description": "Return values are checked, and error conditions are handled securely.",
          "requirements": [
            {
              "id": "B.3.2.a",
              "description": "Identify all functions that handle sensitive data and confirm that: return values are checked for sensitive data; return values are processed to avoid inadvertent disclosure.",
              "guidance": "Unhandled exceptions can lead to sensitive data exposure. Functions handling sensitive data should include routines for handling unknown exceptions."
            },
            {
              "id": "B.3.2.b",
              "description": "Test each function handling sensitive data by attempting to generate unhandled exceptions to confirm error conditions do not expose sensitive data.",
              "test_requirements": "Use appropriate test platform and forensic tools according to Control Objectives 12.1 and B.5.1."
            }
          ],
          "function_names": []
        },
        {
          "id": "B.3.3",
          "description": "Race conditions are avoided.",
          "requirements": [
            {
              "id": "B.3.3.a",
              "description": "Identify all functions that rely on synchronous processing and confirm that protection mechanisms are implemented to mitigate race conditions.",
              "guidance": "Race conditions can occur when sequential processing assumptions are violated, e.g., time-of-use/time-of-check issues. Exploitable race conditions may allow arbitrary code execution."
            },
            {
              "id": "B.3.3.b",
              "description": "Test each synchronous function by attempting to generate race conditions to confirm the software is resistant to such attacks.",
              "guidance": "Protection mechanisms, such as locks, should control sequential processing to prevent race condition exploitation. All sequential data processing should implement protections."
            }
          ],
          "function_names": []
        }
      ],
      "guidance": "Software security controls should mitigate attack vectors including injection attacks, buffer overflows, unhandled exceptions, and race conditions."
    },
    {
      "id": "B.4",
      "description": "Terminal Software Security Testing",
      "requirements": [
        {
          "id": "B.4.1",
          "description": "A documented process is maintained and followed for testing software for vulnerabilities prior to each update or release.",
          "note": "This control objective is an extension of Control Objective 10.2. Validation should be performed at the same time.",
          "requirements": [
            {
              "id": "B.4.1.a",
              "description": "Examine evidence to confirm that the software vendor maintains a documented process for testing software for vulnerabilities prior to each update or release, in accordance with Control Objective 10.2.",
              "guidance": "The documented process should include how the vendor tests for: unnecessary ports and protocols, unintended storage or transmission of clear-text account data, and faulty or ineffective security controls. Lingering test functions or data, default user accounts, hard-coded credentials, and test accounts must be removed before release."
            },
            {
              "id": "B.4.1.b",
              "description": "Examine evidence to confirm that the software is tested for vulnerabilities prior to each release, covering the presence or use of unnecessary ports and protocols, unintended handling of clear-text account data, hard-coded authentication credentials, test data or accounts, and any faulty or ineffective security controls.",
              "guidance": "Before public release, ensure that default accounts, hard-coded credentials, test data, and ineffective security controls are explicitly removed from the software."
            }
          ],
          "function_names": []
        }
      ],
      "guidance": "Software vulnerabilities often result from unremoved test functions or data. Rigorous pre-release testing ensures that sensitive data and security controls are properly protected."
    },
    {
      "id": "B.5",
      "description": "Terminal Software Implementation Guidance",
      "requirements": [
        {
          "id": "B.5.1",
          "description": "The software vendor provides implementation guidance on how to implement and operate the software securely for the payment terminals on which it is to be deployed.",
          "note": "This control objective is an extension of Control Objective 12.1. Validation should be performed at the same time.",
          "requirements": [
            {
              "id": "B.5.1.1",
              "description": "Implementation guidance includes detailed instructions for how to configure all available security options and parameters of the software.",
              "guidance": "The required guidance should instruct stakeholders on configuring all available security options and parameters in accordance with Control Objective B.1.3."
            },
            {
              "id": "B.5.1.2",
              "description": "Implementation guidance includes detailed instructions for how to securely configure the software to use the security features and functions of the payment terminal where applicable.",
              "guidance": "The guidance should instruct stakeholders on securely configuring the software to leverage the payment terminal’s security features and functions."
            },
            {
              "id": "B.5.1.3",
              "description": "Implementation guidance includes detailed instructions for how to configure the software to securely integrate or use any shared resources provided by the payment terminal.",
              "guidance": "The guidance should instruct stakeholders on securely integrating or using shared resources provided by the payment terminal in accordance with Control Objective B.2.6."
            },
            {
              "id": "B.5.1.4",
              "description": "Implementation guidance includes detailed instructions on how to cryptographically sign the software files in a manner that enables the cryptographic authentication of all such files by the payment terminal.",
              "guidance": "The guidance should instruct stakeholders on cryptographically signing all software files in accordance with Control Objective B.2.8."
            },
            {
              "id": "B.5.1.5",
              "description": "Implementation guidance includes instructions for stakeholders to cryptographically sign all prompt files.",
              "guidance": "The guidance should instruct stakeholders on cryptographically signing all prompt files in accordance with Control Objective B.2.9."
            }
          ],
          "function_names": []
        },
        {
          "id": "B.5.2",
          "description": "Implementation guidance adheres to payment terminal vendor guidance on the secure configuration of the payment terminal.",
          "requirements": [
            {
              "id": "B.5.2",
              "description": "Examine evidence to confirm that the guidance aligns with the payment terminal vendor’s security guidance/policy.",
              "guidance": "Software implementation guidance must not conflict with the payment terminal vendor’s recommendations and must align with the vendor’s security guidance to ensure proper configuration by users."
            }
          ],
          "function_names": []
        }
      ],
      "guidance": "Software implementation guidance should provide clear, thorough instructions to ensure secure configuration and operation on payment terminals while fully aligning with vendor security policies."
    },
    {
      "id": "C.1",
      "description": "Web Software Components & Services",
      "requirements": [
        {
          "id": "C.1.1",
          "description": "All software components and services are documented or otherwise cataloged in a software bill of materials (SBOM).",
          "test_requirements": "Examine evidence to confirm that information is maintained describing all software components and services, including proprietary libraries, third-party frameworks, and APIs.",
          "guidance": "Knowing all components and their provenance is critical to minimizing vulnerabilities. SBOM standards like CycloneDX, SPDX, and SWID can be used.",
          "function_names": []
        },
        {
          "id": "C.1.2",
          "description": "The SBOM describes each of the primary components and services in use, as well as their secondary transitive component relationships and dependencies.",
          "test_requirements": [
            "Confirm SBOM describes all primary components and services and all secondary transitive dependencies.",
            "Test that the SBOM accurately reflects components and services in use, and any missing dependencies are justified."
          ],
          "guidance": "Software may have nested dependencies; SBOM should capture at least third-party code and transitive relationships. Justifications must be documented where information is missing.",
          "function_names": []
        },
        {
          "id": "C.1.3",
          "description": "Where the software is provided 'as a service', the SBOM includes information describing the software dependencies present in the production environment.",
          "test_requirements": [
            "Examine evidence to confirm SBOM describes dependencies in the production environment.",
            "Test that SBOM accurately reflects dependencies in production; confirm any missing information is justified."
          ],
          "guidance": "Dependencies in production environments like database servers, application servers, runtime platforms, and plugins must be included in the SBOM.",
          "function_names": []
        },
        {
          "id": "C.1.4",
          "description": "The SBOM includes sufficient information about each component or service to enable tracking across the software supply chain.",
          "test_requirements": [
            "Confirm SBOM includes source/supplier, component/service name, relationships, version, author, and unique identifiers.",
            "Test that SBOM accurately represents components and services in use."
          ],
          "guidance": "Tracking vulnerabilities requires uniquely identifying each component and version, and locating sources for updates or patches.",
          "function_names": []
        },
        {
          "id": "C.1.5",
          "description": "A new SBOM is created or generated each time the software is updated.",
          "test_requirements": "Confirm that a new SBOM is generated for each new software release.",
          "guidance": "Each version must have its own SBOM to accurately track components and vulnerabilities across different versions.",
          "function_names": []
        },
        {
          "id": "C.1.6",
          "description": "Vulnerabilities in third-party components and services are monitored and managed in accordance with Control Objective 10.",
          "test_requirements": [
            "Confirm that third-party components are regularly monitored for vulnerabilities.",
            "Confirm that identified vulnerabilities are patched or mitigated in a timely manner."
          ],
          "guidance": "Vulnerabilities in third-party components must be treated like vendor-controlled code and patched or mitigated promptly.",
          "function_names": []
        },
        {
          "id": "C.1.7",
          "description": "Where software components and/or resources are hosted or maintained on third-party systems, the authenticity of those components is verified each time they are fetched.",
          "test_requirements": [
            "Confirm that authenticity of software components fetched from third-party systems is verified.",
            "Test that software verifies authenticity each time components are fetched."
          ],
          "guidance": "Fetching third-party components from public repositories carries risks; authenticity must be validated using strong cryptography or digital signatures.",
          "function_names": []
        }
      ]
    },
    {
      "id": "C.2",
      "description": "Web Software Access Controls",
      "requirements": [
        {
          "id": "C.2.1",
          "description": "User access to sensitive functions and sensitive resources exposed through Internet-accessible interfaces is authenticated.",
          "test_requirements": "Examine evidence to identify all sensitive functions and resources exposed through Internet-accessible interfaces.",
          "guidance": "Authentication must be robust, free from design weaknesses, and resistant to attacks. Use industry-standard third-party mechanisms or follow industry best practices for custom methods.",
          "function_names": []
        },
        {
          "id": "C.2.1.1",
          "description": "The methods implemented to authenticate user access to sensitive functions and sensitive resources use industry-standard mechanisms.",
          "test_requirements": [
            "Identify all authentication methods used.",
            "Confirm methods are industry-standard or comply with best practices.",
            "Confirm sessions are handled per secure session management standards.",
            "Confirm tokens are handled per secure token management standards."
          ],
          "guidance": "Only well-tested, widely adopted authentication mechanisms should be used. Custom methods must adhere to industry standards.",
          "function_names": []
        },
        {
          "id": "C.2.1.2",
          "description": "The methods implemented are sufficiently strong and robust to protect authentication credentials.",
          "test_requirements": "Examine evidence to confirm methods are resistant to common attacks and comply with Control Objective 5.3.",
          "guidance": "Strong methods include multi-factor authentication or methods using strong cryptography (e.g., digital signatures, certificates).",
          "function_names": []
        },
        {
          "id": "C.2.1.3",
          "description": "Authentication decisions are enforced within a secure area of the software.",
          "test_requirements": [
            "Identify where authentication decisions are enforced in the software.",
            "Confirm all authentication decisions are enforced in a secure area.",
            "Test that client-side functions are never solely relied upon for authentication."
          ],
          "guidance": "Authentication must not depend solely on client-side scripts or data. Secure areas ensure integrity and reliability of authentication enforcement.",
          "function_names": []
        },
        {
          "id": "C.2.2",
          "description": "Access to all Internet-accessible interfaces is restricted to explicitly authorized users only.",
          "test_requirements": [
            "Identify all Internet-exposed interfaces.",
            "Identify methods used to authorize access.",
            "Confirm methods are correctly implemented, appropriate for user types, and free of known vulnerabilities.",
            "Confirm guidance is provided for user-configurable access methods.",
            "Confirm access is restricted to explicitly authorized users.",
            "Test that access is restricted to authorized users."
          ],
          "guidance": "Fine-grained access control is required for modern web applications. Each interface is a potential attack vector and must enforce proper access controls.",
          "function_names": []
        },
        {
          "id": "C.2.3",
          "description": "Access to all software functions and resources exposed through Internet-accessible interfaces is restricted to explicitly authorized users only.",
          "test_requirements": "Identify all functions and resources exposed and examine how access is controlled for each.",
          "guidance": "Access must be controlled at both interface and function/resource level to ensure only authorized users can access sensitive elements.",
          "function_names": []
        },
        {
          "id": "C.2.3.1",
          "description": "The software ensures enforcement of access control rules at both the function level and resource level with fine-grained access control.",
          "test_requirements": [
            "Examine evidence to determine how access is controlled for individual functions and resources.",
            "Confirm methods are correctly implemented, appropriate, and free of vulnerabilities.",
            "Confirm guidance is provided for user-configurable methods.",
            "Confirm access is restricted to explicitly authorized users."
          ],
          "guidance": "Fine-grained access control ensures users only access authorized functions/resources. Vendor guidance must explain configurable options and security considerations.",
          "function_names": []
        },
        {
          "id": "C.2.3.2",
          "description": "Authorization rules are enforced upon each user request to access software functions and resources.",
          "test_requirements": [
            "Confirm authorization checks occur each time a request is made to a function or resource.",
            "Test that access control rules are enforced per request."
          ],
          "guidance": "Authorization must be verified on every request to mitigate risks if credentials are compromised. Use defense-in-depth strategies.",
          "function_names": []
        },
        {
          "id": "C.2.3.3",
          "description": "Access control decisions are enforced within a secure area of the software architecture.",
          "test_requirements": [
            "Identify where authorization and access control decisions are enforced.",
            "Confirm all decisions are enforced within secure areas.",
            "Test that client-side functions are never solely relied upon for access control."
          ],
          "guidance": "Secure areas ensure integrity and reliability of access control enforcement. Avoid relying solely on client-side components for security.",
          "function_names": []
        }
      ]
    },
    {
      "id": "C.2",
      "description": "Web Software Access Controls",
      "requirements": [
        {
          "id": "C.2.1",
          "description": "User access to sensitive functions and sensitive resources exposed through Internet-accessible interfaces is authenticated.",
          "requirements": [
            {
              "id": "C.2.1",
              "description": "Using information obtained in Test Requirements 1.2.a and 2.1.a in the Core Requirements, the assessor shall examine evidence to identify all sensitive functions and sensitive resources exposed through Internet-accessible interfaces.",
              "guidance": "Writing custom authentication functions is not a trivial matter. There are numerous issues and considerations that must be factored into the design and implementation of such functions including, but not limited to, the fact that they are a significant target for attackers. Authentication functions must be free from weaknesses in design and must be resistant to targeted attacks. Given the importance of and the heavy reliance on such functions for security purposes (and those of this standard), it is recommended that entities use third-party authentication functions, modules, libraries, services, and so on, that are already widely used within the industry and have been subjected to thorough security testing and scrutiny. Where the use of such mechanisms is not feasible, then custom methods may be used. However, custom methods must be designed and implemented in strict accordance with applicable industry standards or best practices for authentication. Failure to do so could expose vulnerabilities or design weaknesses in custom authentication methods to malicious entities who may exploit those vulnerabilities to manipulate or otherwise bypass custom authentication mechanisms."
            },
            {
              "id": "C.2.1.1",
              "description": "The methods implemented to authenticate user access to sensitive functions and sensitive resources use industry-standard mechanisms.",
              "requirements": [
                {
                  "id": "C.2.1.1.a",
                  "description": "The assessor shall examine evidence to identify all methods implemented by the software to authenticate access to sensitive functions and sensitive resources.",
                  "guidance": "Similar to developing one’s own authorization mechanisms, developing custom authentication mechanisms can be quite a complex undertaking. Much of an application’s security is dependent on the strength and robustness of its authentication and authorization mechanisms. There are numerous issues and considerations that must be factored into the design and implementation of such functions including but not limited to, the fact that they are a significant target for attackers. Authentication functions must be free from weaknesses and must be able to withstand targeted attacks. For this reason, only well-designed and well-tested mechanisms should be used. Authentication mechanisms that are provided by industry-accepted suppliers and widely adopted within the industry are generally understood to have been subjected to substantial testing and validation throughout the course of that adoption. Therefore, it is strongly recommended that these mechanisms be used by other entities instead of writing and implementing their own mechanisms. Where the use of third-party mechanisms is not feasible, then custom methods may be used. However, custom methods must be designed and implemented in strict accordance with applicable industry standards or best practices for authentication. Failure to do so could expose vulnerabilities or design weaknesses in custom authentication methods to malicious entities who may exploit those vulnerabilities to manipulate, or otherwise bypass the custom authentication mechanisms, rendering all such functions effectively useless."
                },
                {
                  "id": "C.2.1.1.b",
                  "description": "The assessor shall examine evidence to confirm that the implemented methods use industry-standard mechanisms that are: Provided by well-known and industry-accepted third-party suppliers; or Designed and implemented in accordance with applicable industry standards or best practices.",
                  "guidance": ""
                },
                {
                  "id": "C.2.1.1.c",
                  "description": "Where sessions are used to authenticate user access to sensitive functions and sensitive resources, the assessor shall examine evidence to confirm that the sessions are handled in accordance with industry-recognized standards and best practices for secure session management.",
                  "guidance": ""
                },
                {
                  "id": "C.2.1.1.d",
                  "description": "Where tokens (for example, access tokens and refresh tokens) are used to authenticate user access to sensitive functions and sensitive resources, the assessor shall examine evidence to confirm that the tokens are handled in accordance with industry-recognized standards and best practices for secure token management.",
                  "guidance": ""
                }
              ]
            },
            {
              "id": "C.2.1.2",
              "description": "The methods implemented to authenticate user access to sensitive functions and sensitive resources through Internet-accessible interfaces are sufficiently strong and robust to protect authentication credentials in accordance with Control Objective 5.3.",
              "requirements": [
                {
                  "id": "C.2.1.2",
                  "description": "Using information obtained in Test Requirement C.2.1.1.a, the assessor shall examine evidence to confirm that the authentication methods implemented are sufficiently strong and robust to protect authentication credentials in accordance with Control Objective 5.3 in the Core Requirements section.",
                  "guidance": "Strong and robust authentication methods are those that are resistant to common attacks. Examples of such methods include, but are not limited to, multi-factor authentication and/or authentication methods that employ strong cryptography (such as digital signatures or certificates)."
                }
              ]
            },
            {
              "id": "C.2.1.3",
              "description": "Authentication decisions are enforced within a secure area of the software.",
              "requirements": [
                {
                  "id": "C.2.1.3.a",
                  "description": "The assessor shall examine evidence to identify where within the software architecture authentication decisions are enforced.",
                  "guidance": "Like authorization decisions, authentication decisions must be enforced within a secure area of the software. Authentication methods should never rely solely on scripts or data obtained from the client or browser. With that said, it is permissible to use client-side scripts and data when combined with server-side methods to enhance authentication capabilities."
                },
                {
                  "id": "C.2.1.3.b",
                  "description": "The assessor shall examine evidence to confirm that all authentication decisions are enforced within a secure area of the software architecture.",
                  "guidance": ""
                },
                {
                  "id": "C.2.1.3.c",
                  "description": "The assessor shall examine evidence and test the software to confirm that client-side or browser-based functions, scripts, and data are never solely relied upon for authentication purposes.",
                  "guidance": ""
                }
              ]
            }
          ],
          "function_names": []
        },
        {
          "id": "C.2.2",
          "description": "Access to all Internet-accessible interfaces is restricted to explicitly authorized users only.",
          "requirements": [
            {
              "id": "C.2.2.a",
              "description": "Using information obtained in Test Requirement 2.1.a in the Core Requirements section, the assessor shall examine evidence to identify all software interfaces that are exposed to the Internet or that can be configured in a way that exposes them to the Internet.",
              "guidance": "Modern web applications, particularly those that rely heavily on APIs, microservices and serverless environments, require fine-grained access control capabilities to handle the increasingly complex relationships between software users, interfaces, functions, and resources."
            },
            {
              "id": "C.2.2.b",
              "description": "The assessor shall examine evidence to identify all methods used to authorize access to Internet-accessible interfaces.",
              "guidance": ""
            },
            {
              "id": "C.2.2.c",
              "description": "The assessor shall examine evidence and test the software to confirm that each of these methods is: implemented correctly; appropriate for the types of users expected to use the interface; and does not expose known vulnerabilities.",
              "guidance": "One key difference between traditional “monolithic” web applications and modern web applications is the degree to which an application is exposed (or potentially exposed) to the Internet. Where monolithic web applications tend to keep interactions between software components confined to a single security context (such as an internal or isolated system or network), modern web applications are typically segmented into many distinct and/or independent software functions that are then exposed to the Internet through APIs so that they may be accessible to other application or users, regardless of where they may reside. Unfortunately, each Internet accessible interface (and the functions and resources it provides) is a potential attack vector. To mitigate the risks associated with exposing so many software functions to the Internet, each interface must implement access control mechanisms to ensure that only authorized systems and users are able to access the interface, and the functions and resources exposed through those interfaces."
            },
            {
              "id": "C.2.2.d",
              "description": "Where the methods used to authorize access to Internet-accessible interfaces is user configurable, or otherwise requires user input or interaction, the assessor shall examine evidence to confirm that appropriate guidance is made available to stakeholders in accordance with Control Objective 12.1 that describes the configurable options available and how to configure each method securely.",
              "guidance": ""
            },
            {
              "id": "C.2.2.e",
              "description": "Where the methods used to authorize access to Internet-accessible interfaces are configured and controlled by the assessed entity, the assessor shall examine evidence to confirm that access to Internet-accessible interfaces is restricted to an appropriate set of explicitly authorized users (or entities).",
              "guidance": ""
            },
            {
              "id": "C.2.2.f",
              "description": "The assessor shall examine evidence and test the software to confirm that access to all Internet-accessible interfaces is restricted to explicitly authorized users only.",
              "guidance": ""
            }
          ],
          "function_names": []
        },
        {
          "id": "C.2.3",
          "description": "Access to all software functions and resources exposed through Internet-accessible interfaces is restricted to explicitly authorized users only.",
          "requirements": [
            {
              "id": "C.2.3",
              "description": "Using information obtained in Test Requirement C.2.2.a, the assessor shall examine evidence to identify all software functions and resources that are exposed, or that can be configured in a way that exposes them, through Internet-accessible interfaces.",
              "guidance": "In addition to controlling access at the interface level, access to individual functions and resources provided through each Internet accessible interface must also be controlled. Access needs to the different functions and resources within a given interface can be quite complex depending upon the types of users and systems that need to use a given interface and the different capabilities and data accessible through those functions and resources."
            },
            {
              "id": "C.2.3.1",
              "description": "The software ensures the enforcement of access control rules at both the function level and resource level with fine-grained access control capabilities.",
              "requirements": [
                {
                  "id": "C.2.3.1.a",
                  "description": "Using information obtained in Test Requirement C.2.3, the assessor shall examine evidence to determine how the software controls access to individual functions and resources exposed (or potentially exposed) through Internet-accessible interfaces.",
                  "guidance": "To support the fine-grained access control needs of modern web application architectures and to ensure that users are only able to access the software functions and resources that they are authorized to use, the software must support the ability to define and enforce access control rules at varying “levels” within the interface’s hierarchy, including at the individual function and resource level(s). Depending upon the types of functions and resources exposed in a given software interface, the methods used to authorize access at the interface level may not be appropriate to provide access to individual functions and resources exposed through such interfaces. For example, API keys are often used to authorize access to an API for a particular entity (also called project-level or entity-level authorization). While API keys may be suitable for authorizing this level of access to an API, it may not be suitable for authorizing individual user access to specific functions or resources exposed (or potentially exposed) through the API."
                },
                {
                  "id": "C.2.3.1.b",
                  "description": "The assessor shall then examine evidence to identify the methods used to restrict access to the functions and resources exposed (or potentially exposed) through Internet-accessible interfaces and to confirm that each of these methods is: implemented correctly; appropriate for the type of function(s) and resource(s) provided; and does not expose known vulnerabilities.",
                  "guidance": ""
                },
                {
                  "id": "C.2.3.1.c",
                  "description": "Where the methods used to authorize access to the functions and resources exposed (or potentially exposed) through Internet-accessible interfaces are user configurable or otherwise requires user input or interaction, the assessor shall examine evidence to confirm that guidance is made available to stakeholders in accordance with Control Objective 12.1 that describes the mechanisms and configurable options available to restrict access to the functions and resources exposed through these interfaces, and how to configure such mechanisms.",
                  "guidance": ""
                },
                {
                  "id": "C.2.3.1.d",
                  "description": "Where the methods used to authorize access to the functions and resources exposed (or potentially exposed) through Internet-accessible interfaces is configured and controlled by the assessed entity, the assessor shall examine evidence to confirm that access to the functions and resources is restricted to an appropriate set of explicitly authorized users.",
                  "guidance": "Where fined-grained access control is necessary, the methods implemented to control access to all software functions and resources exposed through Internet accessible interfaces must be appropriate for the types of authorization(s) required (for example, user versus entity) and the functions and resources involved (sensitive versus non-sensitive functions and resources). Wherever end users are required to configure the access control authorizations and permissions for individual functions and resources exposed through Internet accessible interfaces, the software vendor must provide guidance (or otherwise make guidance accessible) to users and other stakeholders to explain how to configure such permissions and to alert them to important security considerations when configuring available options and parameters."
                },
                {
                  "id": "C.2.3.1.e",
                  "description": "The assessor shall examine evidence and test the software to confirm that the methods used to restrict access to the functions and resources exposed (or potentially exposed) through Internet-accessible interfaces require users to be explicitly authorized prior to being granted such access.",
                  "guidance": ""
                }
              ]
            },
            {
              "id": "C.2.3.2",
              "description": "Authorization rules are enforced upon each user request to access software functions and resources through Internet-accessible interfaces.",
              "requirements": [
                {
                  "id": "C.2.3.2.a",
                  "description": "Using information obtained in Test Requirement C.2.3.1.a, the assessor shall examine evidence to confirm that authorization checks are performed each time users request access to a function or resource exposed (or potentially exposed) through Internet-accessible interfaces to verify they are authorized for the function, resource, and type of access requested.",
                  "guidance": "Most modern web applications, particularly those that use APIs, microservices and serverless architectures, operate on a request/response basis. Each time a user wants to perform a function or access application data, they submit a request to the application (usually through an API or similar) to access a particular function or resource. The software then processes that request and, if authorized, executes the requested function and/or returns the requested data. It is often trivial for attackers to obtain login credentials of authorized users. A defense-in-depth strategy is essential to ensuring that only authorized users can access protected functions and resources. When combined with other security controls, such as expiring sessions or tokens after a relatively short period of time, authorization checks can significantly limit what an attacker can do if they are able to compromise the credentials of an authorized user."
                },
                {
                  "id": "C.2.3.2.b",
                  "description": "The assessor shall examine evidence and test the software to confirm that access control rules are enforced each time a user attempts to access a function or resource exposed (or potentially exposed) through Internet-accessible interfaces.",
                  "guidance": ""
                }
              ]
            },
            {
              "id": "C.2.3.3",
              "description": "Access control decisions are enforced within a secure area of the software architecture.",
              "requirements": [
                {
                  "id": "C.2.3.3.a",
                  "description": "The assessor shall examine evidence to identify where in the software architecture authorization and access control decisions are enforced.",
                  "guidance": "Payment software should never rely on unknown or insecure services and features for security-related purposes. Secure areas or systems are those within the software architecture where the integrity of available services and data is ensured, and therefore can be relied upon by the software. Historically, web application architectures consisted of “client-side” components and “server-side” components. Client-side functions are those typically performed by a common web browser. Server-side functions are those typically performed by web, application, and/or database servers. Given the open nature and design of most common web browsers and the fact that they are maintained by end users, server-side functions are typically considered to be more secure given a software/service provider’s ability to control and secure those aspects of the software architecture. Modern web software architectures, however, have become increasingly complex with software components often deployed across multiple geographic locations and managed by multiple entities. In these circumstances, the distinction between “client-side” or “server-side” functions can be increasingly ambiguous. The term “secure area” is a reference to traditional “server-side” functions without getting into architectural specifics. Examples of a secure area include a secured server environment, a microservice, or a serverless API."
                },
                {
                  "id": "C.2.3.3.b",
                  "description": "The assessor shall examine evidence to confirm that all access control decisions are enforced within a secure area of the software architecture.",
                  "guidance": ""
                },
                {
                  "id": "C.2.3.3.c",
                  "description": "The assessor shall examine evidence and test the software to confirm that client-side or browser-based functions, scripts, and data are never solely relied upon for access control purposes.",
                  "guidance": ""
                }
              ]
            }
          ],
          "function_names": []
        }
      ],
      "guidance": "Software security controls are implemented to restrict access to Internet-accessible interfaces, functions, and resources to explicitly authorized users only."
    },
    {
      "id": "C.3",
      "description": "Web Software Attack Mitigation",
      "requirements": [
        {
          "id": "C.3.2.2",
          "description": "Parsers and interpreters are configured with the most restrictive configuration feasible.",
          "requirements": [
            {
              "id": "C.3.2.2.a",
              "description": "Using information obtained in Test Requirement C.3.2.b, the assessor shall examine evidence to identify the configurations for each parser or interpreter used to process untrusted input data.",
              "guidance": "In some cases, it may not be feasible to isolate (parameterization) or modify (escaping, encoding, etc.) input data prior to processing the data. In such cases, the only viable method to protect against input manipulation attacks is to use a parser or interpreter that has been hardened to prevent such attacks. For example, at the time of this publication the only viable way to protect against an XML External Entity attack is to configure the XML parser to disable the Document Type Definition (DTD) feature, otherwise known as External Entities feature."
            },
            {
              "id": "C.3.2.2.b",
              "description": "For each of the parsers/interpreters and the configurations identified, the assessor shall examine evidence to confirm that parsers and interpreters are configured with the most restrictive set of capabilities feasible and that the settings are justified and reasonable.",
              "guidance": "Where certain parser/interpreter features cannot be configured securely, the assessor shall examine evidence to confirm that other methods are implemented to mitigate the lack of secure settings and to further protect against the execution of malicious commands. The specific settings that must be disabled/enabled to protect against certain attacks depends on the parsers and interpreters. For more information, refer to available security guidance on the specific parsers/interpreters in use. Where certain features of the parsers or interpreters cannot be configured with the most secure settings possible, then the processing of untrusted input data should use techniques such as sandboxing to prevent (or otherwise mitigate the impacts of) malicious code execution."
            }
          ],
          "function_names": []
        },
        {
          "id": "C.3.3",
          "description": "Software security controls are implemented to protect software interfaces from resource starvation attacks.",
          "requirements": [
            {
              "id": "C.3.3.a",
              "description": "Using information obtained in Test Requirements C.2.1.a and C.2.2, the assessor shall examine evidence to identify all Internet accessible interfaces and the functions and resources exposed (or potentially exposed) through those interfaces to identify where such interfaces, functions, and resources may be susceptible to resource starvation attacks.",
              "guidance": "While the goal of many attacks is to expose sensitive data and sensitive functions (directly or indirectly) to unauthorized users, other attacks are intended to prevent an application’s use of or access to important computing resources. Such attacks aim to overwhelm the software/system with requests or fill all available system resources such as processing time or memory, therefore starving the software/system of the resources it requires for normal operation and rendering it unusable to other users. In other cases, these attacks are intended to force the software to behave in unintended ways which could, in turn, enable an attacker to execute arbitrary code on the targeted system or expose sensitive data through error messages."
            },
            {
              "id": "C.3.3.b",
              "description": "Where such interfaces, functions, and resources are potentially susceptible to resource starvation attacks, the assessor shall examine evidence to confirm that: the threat of such attacks is documented in accordance with Control Objective 4.1, and software security controls to mitigate such attacks are documented and implemented in accordance with Control Objective 4.2.",
              "guidance": ""
            },
            {
              "id": "C.3.3.c",
              "description": "The assessor shall examine evidence to confirm that the software security controls implemented to mitigate resource starvation and other similar attacks on Internet accessible interfaces are designed and implemented in accordance with applicable industry standards and best practices.",
              "guidance": ""
            },
            {
              "id": "C.3.3.d",
              "description": "Where the implementation of software security controls is user configurable or otherwise requires user input or interaction, the assessor shall examine evidence to confirm that guidance is made available to stakeholders in accordance with Control Objective 12.1 that describes how to configure such mechanisms.",
              "guidance": "Examples of methods used to mitigate the risk of such attacks include limiting the rate on the number of requests that can be submitted within a given time period (rate limiting). Additional methods to prevent such attacks may include defining other limits such as the number of users and/or systems that can submit requests, mutually authenticating those users and systems, or using CAPTCHA or other anti-automation techniques that can prevent large volumes of requests being submitted to software interfaces within a short time period. For SaaS or other similar environments, appropriate network-based controls may also be used to address these types of attacks."
            }
          ],
          "function_names": []
        },
        {
          "id": "C.3.4",
          "description": "Software security controls are implemented to protect Internet accessible interfaces from malicious file content.",
          "requirements": [
            {
              "id": "C.3.4.a",
              "description": "Using information obtained in Test Requirement C.2.1.a, the assessor shall examine evidence to identify all Internet accessible interfaces that accept file uploads and the file types permitted.",
              "guidance": "File uploads can be used to provide larger datasets to a piece of software. However, such uploads must be managed securely to prevent the misuse of this function. Files not correctly managed may end up being executable on the host system or be used as a vector to infect or subvert the software or other systems (for example, by creating or overwriting malicious configuration files). File upload interfaces may also provide unintended access to the underlying host system or software. Different file types may be provided with different permissions or functions within a host system, and any file upload system should ensure that only expected file types are accepted for upload. However, care must be taken to ensure that this added process does not itself expose vulnerabilities that could be exploited."
            },
            {
              "id": "C.3.4.b",
              "description": "Where the software accepts file uploads over Internet accessible interfaces, the assessor shall examine evidence to confirm that: the threat of attacks on file upload mechanisms is documented in accordance with Control Objective 4.1, and software security controls to mitigate such attacks are documented and implemented in accordance with Control Objective 4.2.",
              "guidance": ""
            },
            {
              "id": "C.3.4.c",
              "description": "The assessor shall examine evidence to confirm that the software security controls implemented to mitigate attacks on file upload mechanisms are implemented in accordance with applicable industry standards and best practices.",
              "guidance": ""
            },
            {
              "id": "C.3.4.d",
              "description": "The assessor shall examine evidence to confirm that the software security controls implemented to mitigate attacks on file upload mechanisms include methods to restrict the file types permitted by the file upload mechanisms.",
              "guidance": "Many file formats allow for the embedding of other files or data which can be ‘expanded’ out when parsing the source file. In some scenarios this can be used to gain privileges or exploit vulnerabilities on the host platform which would not otherwise be possible. Uploaded files need to be managed in ways that prevent the exploitation of file parsing or expansion attacks. To prevent the exploitation of file upload systems, any files that are uploaded cannot be assigned writable or executable privileges. Files which are required to be writable need to be copied across to a separate file managed only by the software to prevent a malicious user from exploiting the file between upload and use. For defense-in-depth, some software development languages and frameworks include the ability to make calls to anti-malware systems to scan these files upon upload. File and file type parsers are notorious sources of exploits. Such parsers must not make security decisions based on file names or file extensions. Acceptable file types should have a basic structure that enables the software to determine the file type without using file names or file extensions."
            },
            {
              "id": "C.3.4.e",
              "description": "The assessor shall examine evidence to confirm that the software security controls implemented to mitigate attacks on file upload mechanisms include methods to restrict the maximum number and size of files permitted for upload.",
              "guidance": ""
            },
            {
              "id": "C.3.4.f",
              "description": "The assessor shall examine evidence to confirm that the software security controls implemented to mitigate attacks on file upload mechanisms account for the use of complex or compressed file formats that are often used to overwhelm or otherwise exploit file-parsing mechanisms.",
              "guidance": ""
            },
            {
              "id": "C.3.4.g",
              "description": "The assessor shall examine evidence to confirm that the software security controls implemented to mitigate attacks on file upload mechanisms include methods that store uploaded files outside of the webroot and assign those files read-only permissions.",
              "guidance": ""
            },
            {
              "id": "C.3.4.h",
              "description": "The assessor shall examine evidence to confirm that the use of file-parsing mechanisms does not rely on file names or file extensions for security purposes.",
              "guidance": ""
            },
            {
              "id": "C.3.4.i",
              "description": "Where the implementation of software security controls is user configurable or otherwise requires user input or interaction, the assessor shall examine evidence to confirm that guidance is made available to stakeholders in accordance with Control Objective 12.1 that describes how to configure such mechanisms.",
              "guidance": ""
            }
          ],
          "function_names": []
        },
        {
          "id": "C.3.5",
          "description": "Software security controls are implemented to protect Internet accessible interfaces from hostile object creation and data tampering.",
          "requirements": [
            {
              "id": "C.3.5.a",
              "description": "Using information obtained in Test Requirements C.2.1.a and C.2.2, the assessor shall examine evidence to identify all software functions exposed through Internet accessible interfaces that accept and process data objects as inputs.",
              "guidance": "Some software APIs accept serialized data objects (for example, arrays, cookies, tokens, and so on) to be passed from other systems. However, without appropriate methods in place to restrict object deserialization and creation, malicious individuals may be able to use these APIs to launch denial-of-service attacks, compromise access control mechanisms, or inject and execute malicious code on underlying systems. There are numerous methods to protect against serialization (and deserialization) attacks. Some programming languages, libraries, and APIs provide features and functions that are resistant to serialization attacks. Other methods include using deserialization mechanisms that only support pure data formats like JSON or XML, limiting data types allowed during object creation, encrypting communications, and authenticating API clients. Appropriate methods to protect against serialization attacks depend on the API implementation. Refer to industry sources, such as the Open Web Application Security Project (OWASP) for more information. For the same reasons explained in C.3.4, file-parsing mechanisms must not make security decisions based on file names or file extensions. Acceptable file types should have a basic structure that enables the software to determine the file type without using file names or file extensions."
            },
            {
              "id": "C.3.5.b",
              "description": "Where the software accepts and processes data objects as inputs, the assessor shall examine evidence to confirm that: the threat of hostile object creation and data tampering attacks is documented in accordance with Control Objective 4.1, and software security controls to mitigate such attacks are documented and implemented in accordance with Control Objective 4.2.",
              "guidance": ""
            },
            {
              "id": "C.3.5.c",
              "description": "The assessor shall examine evidence to confirm that the software security controls implemented to mitigate hostile object creation and data tampering attacks are implemented in accordance with applicable industry standards and best practices.",
              "guidance": ""
            },
            {
              "id": "C.3.5.d",
              "description": "The assessor shall examine evidence to confirm that the software security controls implemented to mitigate hostile object creation and data tampering attacks include methods that restrict the file formats permitted by file-parsing mechanisms.",
              "guidance": ""
            },
            {
              "id": "C.3.5.e",
              "description": "The assessor shall examine evidence to confirm that the use of file-parsing mechanisms does not rely on file names or file extensions for security purposes.",
              "guidance": ""
            },
            {
              "id": "C.3.5.f",
              "description": "The assessor shall examine evidence to confirm that the use of file-parsing mechanisms does not expose other vulnerabilities.",
              "guidance": ""
            },
            {
              "id": "C.3.5.g",
              "description": "Where the software accepts serialized objects as inputs, the assessor shall examine evidence to confirm that software security controls are implemented to protect against deserialization attacks and that such security controls adhere to applicable industry standards and best practices.",
              "guidance": "Some file-parsing mechanisms are inherently susceptible to certain vulnerabilities. For example, XML parsers are often vulnerable to External Entity attacks. Similarly, JSON parsers are vulnerable to attacks where insecure commands, such as eval(), can enable the execution of malicious code. To mitigate attacks that attempt to exploit vulnerabilities in file-parsing mechanisms, it may be necessary for entities to implement additional software security controls. Examples of such controls include, but are not limited to, configuring file-parsing mechanisms to use the most restrictive configuration feasible, avoiding or escaping certain commands that are known issues for file-parsing mechanisms, or isolating and executing file-parsing commands in a sandbox. The methods used to further mitigate such attacks should consider the specific parsers and interpreters in use and be implemented in a manner appropriate for each parser and interpreter."
            },
            {
              "id": "C.3.5.h",
              "description": "Where the software security controls implemented to protect against hostile object creation and data tampering are user configurable or otherwise require user input or interaction, the assessor shall examine evidence to confirm that guidance is made available to stakeholders in accordance with Control Objective 12.1 that describes how to configure such mechanisms.",
              "guidance": ""
            }
          ],
          "function_names": []
        },
        {
          "id": "C.3.6",
          "description": "Software security controls are implemented to protect Internet accessible interfaces from attacks that exploit multi-origin resource sharing.",
          "requirements": [
            {
              "id": "C.3.6.a",
              "description": "The assessor shall examine evidence to determine if and/or how the software supports cross-origin access to Internet accessible interfaces, and to confirm that access to software APIs and resources from browser-based scripts is disabled by default.",
              "guidance": "Software may be required to allow access to resources or API interfaces from other domains or Internet origins. This practice may lead to vulnerabilities that expose sensitive data or sensitive functions to attacks. Where not required, cross-origin resource sharing should be disabled. Where cross-origin resource sharing is necessary due to a legitimate business purpose, such access must be enabled only for the domains and origins required for the software to perform its intended function(s). Use of permission lists or other configurations may be suitable for identifying permitted origins, but such configurations must also be protected against modification by malicious parties."
            },
            {
              "id": "C.3.6.b",
              "description": "Where cross-origin access is enabled, the assessor shall examine evidence to confirm that the reasons for enabling cross-origin access are reasonable and justified, and that access is restricted to the minimum number of origins feasible.",
              "guidance": ""
            },
            {
              "id": "C.3.6.c",
              "description": "The assessor shall test the software to confirm that the claims made by the assessed entity regarding cross-origin access are valid. At a minimum, testing is expected to include functional testing using forensic tools/techniques.",
              "guidance": ""
            },
            {
              "id": "C.3.6.d",
              "description": "Where disabling or restricting cross-origin access to software APIs requires user input or interaction, the assessor shall examine evidence to confirm that appropriate guidance on this process is provided to stakeholders in accordance with Control Objective 12.1.",
              "guidance": ""
            }
          ],
          "function_names": []
        }
      ],
      "guidance": "Software security controls should protect web interfaces from attacks, including malicious file uploads, resource starvation, and untrusted input, using industry best practices and providing guidance to stakeholders where user interaction is required."
    },
    {
      "id": "C.4",
      "description": "Web Software Communications",
      "requirements": [
        {
          "id": "C.4.1",
          "description": "Sensitive data transmissions are encrypted in accordance with Control Objectives 6.2 and 6.3.",
          "requirements": [
            {
              "id": "C.4.1.a",
              "description": "Using information obtained in Test Requirement 6.2.a, the assessor shall examine evidence to determine how communications are handled by the software, including those between separate systems in the overall software architecture.",
              "guidance": "The types of data which may be considered sensitive may vary across different implementations. See Control Objective 1.1 for more information on identifying sensitive data. It is therefore important that any connection that transmits sensitive data is encrypted using strong cryptography. Common methods for achieving this will include the use of TLS using appropriate cipher suites. Although connections that do not transmit sensitive data do not explicitly require the use of encryption, it is noted that the use of strong cryptography to secure all connections is considered a best practice and should be implemented for all communications unless legitimate business or technological constraints exist that render such an approach infeasible. In most cases, however, communications between web application components include the transmission of authentication information (user credentials or session information) which is considered sensitive data by definition and should therefore be encrypted using strong cryptography."
            },
            {
              "id": "C.4.1.b",
              "description": "Where the software allows or otherwise supports the transmission of sensitive data between users and systems in different security contexts, the assessor shall examine evidence to confirm that all such communications are encrypted using strong cryptography in accordance with Control Objectives 6.2 and 6.3.",
              "guidance": ""
            },
            {
              "id": "C.4.1.c",
              "description": "Where sensitive data is transmitted using server-to-server communications (for example, using APIs), the assessor shall examine evidence to confirm that the software enforces or otherwise supports mutual authentication between systems.",
              "guidance": "Where sensitive data is transmitted between systems operating within different security contexts and/or different environments, it is important that such communications be restricted to an explicitly approved list of systems, and that the systems involved be mutually authenticated such that attempts to intercept or compromise such communications are appropriately mitigated. Where the software provider controls the configuration of such communications, mutual authentication must be enforced. Otherwise, the software provider must provide features to support the mutual authentication of disparate systems so that an implementing entity may configure such features accordingly."
            },
            {
              "id": "C.4.1.d",
              "description": "Where internally generated or self-signed certificates are used for securing sensitive data transmissions, the assessor shall examine evidence to confirm that: the use of internally generated or self-signed certificates is reasonable and justified, and the software is configured to accept the minimum feasible number of internally generated or self-signed certificates.",
              "guidance": "Many organizations that choose to use internally generated and/or self-signed certificates do so for the benefits they offer without considering the additional overhead needed to manage them securely. As a result, critical security processes such as certificate revocation and key management are not implemented or maintained properly. For this reason, the use of internally generated and/or self-signed certificates should be kept to an absolute minimum. Where their use is required, such instances should be documented and justified."
            }
          ],
          "function_names": []
        }
      ],
      "guidance": "Sensitive data transmissions must be secured using strong cryptography and mutual authentication where applicable. Use of self-signed or internally generated certificates should be minimized, documented, and justified."
    }
  ]
}