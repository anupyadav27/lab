[
  {
    "name": "gcp_network_change_control_compliance",
    "gcp_api": "gcp.network.getChangeHistory()",
    "service": "gcp_network",
    "rationale": "Needed to verify that changes to network configurations are approved and managed according to a change control process."
  },
  {
    "name": "gcp_network_diagram_maintenance",
    "gcp_api": "gcp.network.getTopology()",
    "service": "gcp_network",
    "rationale": "Needed to programmatically verify and maintain an accurate network diagram showing all connections."
  },
  {
    "name": "gcp_network_inbound_traffic_restriction",
    "gcp_api": "gcp.network.firewallRules.list()",
    "service": "gcp_network",
    "rationale": "To ensure all inbound traffic to the CDE is restricted to necessary traffic only and all other traffic is denied."
  },
  {
    "name": "gcp_network_outbound_traffic_restriction",
    "gcp_api": "gcp.network.firewallRules.list()",
    "service": "gcp_network",
    "rationale": "To ensure all outbound traffic from the CDE is restricted to necessary traffic only and all other traffic is denied."
  },
  {
    "name": "gcp_network_wireless_traffic_restriction",
    "gcp_api": "gcp.network.firewallRules.list()",
    "service": "gcp_network",
    "rationale": "To ensure all wireless traffic into the CDE is denied by default unless explicitly authorized."
  },
  {
    "name": "gcp_network_trusted_untrusted_boundary",
    "gcp_api": "gcp.network.firewallRules.list()",
    "service": "gcp_network",
    "rationale": "To verify that NSCs are implemented between trusted and untrusted networks."
  },
  {
    "name": "gcp_network_inbound_untrusted_traffic_restriction",
    "gcp_api": "gcp.network.firewallRules.list()",
    "service": "gcp_network",
    "rationale": "To ensure inbound traffic from untrusted networks is restricted to authorized communications only."
  },
  {
    "name": "gcp_network_anti_spoofing_measures_enabled",
    "gcp_api": "gcp.network.firewall.setAntiSpoofing()",
    "service": "gcp_network",
    "rationale": "To programmatically enable and verify anti-spoofing measures on network firewalls."
  },
  {
    "name": "gcp_network_cardholder_data_access_restriction",
    "gcp_api": "gcp.network.firewall.setAccessRestrictions()",
    "service": "gcp_network",
    "rationale": "To ensure that system components storing cardholder data are not directly accessible from untrusted networks."
  },
  {
    "name": "gcp_network_internal_ip_disclosure_prevention",
    "gcp_api": "gcp.network.firewall.setIpDisclosurePrevention()",
    "service": "gcp_network",
    "rationale": "To prevent unauthorized disclosure of internal IP addresses and routing information."
  },
  {
    "name": "gcp_compute_device_security_controls_enforced",
    "gcp_api": "gcp.compute.instances.setSecurityControls()",
    "service": "gcp_compute",
    "rationale": "To ensure security controls are enforced on devices connecting to both untrusted networks and the CDE."
  },
  {
    "name": "gcp_iam_roles_responsibility_matrix_verification",
    "gcp_api": "gcp.iam.getRole()",
    "service": "gcp_iam",
    "rationale": "To programmatically verify the assignment of roles and responsibilities in a structured format like a RACI matrix."
  },
  {
    "name": "gcp_compute_configuration_standards_enforcement",
    "gcp_api": "gcp.compute.instances.get()",
    "service": "gcp_compute",
    "rationale": "To ensure that configuration standards are enforced and verified against industry standards programmatically."
  },
  {
    "name": "gcp_iam_vendor_default_account_management",
    "gcp_api": "gcp.iam.getServiceAccount()",
    "service": "gcp_iam",
    "rationale": "To automate the detection and management of vendor default accounts and ensure they are either disabled or have their passwords changed."
  },
  {
    "name": "gcp_compute_function_isolation_verification",
    "gcp_api": "gcp.compute.instances.get()",
    "service": "gcp_compute",
    "rationale": "To verify that functions with different security levels are isolated or secured appropriately on the same system component."
  },
  {
    "name": "gcp_compute_unnecessary_services_disabling",
    "gcp_api": "gcp.compute.instances.setMetadata()",
    "service": "gcp_compute",
    "rationale": "To programmatically disable or remove unnecessary services, protocols, and functions on system components."
  },
  {
    "name": "gcp_compute_insecure_protocols_detection",
    "gcp_api": "gcp.compute.instances.list()",
    "service": "compute",
    "rationale": "To identify and manage instances using insecure protocols or services."
  },
  {
    "name": "gcp_compute_security_parameters_verification",
    "gcp_api": "gcp.compute.instances.get()",
    "service": "compute",
    "rationale": "To verify that security parameters are configured to prevent misuse."
  },
  {
    "name": "gcp_network_encrypted_admin_access_enforcement",
    "gcp_api": "gcp.network.firewalls.list()",
    "service": "network",
    "rationale": "To ensure all non-console administrative access is encrypted using strong cryptography."
  },
  {
    "name": "gcp_network_wireless_defaults_check",
    "gcp_api": "gcp.network.wifi.list()",
    "service": "network",
    "rationale": "To verify that wireless vendor defaults are changed or confirmed secure."
  },
  {
    "name": "gcp_network_wireless_key_rotation",
    "gcp_api": "gcp.network.wifi.update()",
    "service": "network",
    "rationale": "To automate the rotation of wireless encryption keys based on personnel changes or suspected compromise."
  },
  {
    "name": "gcp_storage_card_verification_code_removal",
    "gcp_api": "gcp.storage.remove_object()",
    "service": "gcp_storage",
    "rationale": "To ensure that card verification codes are not stored after authorization, a function to programmatically remove or verify the absence of such data in storage is needed."
  },
  {
    "name": "gcp_storage_pin_block_removal",
    "gcp_api": "gcp.storage.remove_object()",
    "service": "gcp_storage",
    "rationale": "To ensure that PINs and PIN blocks are not stored after authorization, a function to programmatically remove or verify the absence of such data in storage is needed."
  },
  {
    "name": "gcp_storage_sad_encryption_verification",
    "gcp_api": "gcp.kms.verify_encryption()",
    "service": "gcp_kms",
    "rationale": "To ensure that Sensitive Authentication Data (SAD) is encrypted using strong cryptography prior to authorization completion."
  },
  {
    "name": "gcp_storage_sad_business_need_verification",
    "gcp_api": "gcp.storage.metadata_check()",
    "service": "gcp_storage",
    "rationale": "To verify that storage of SAD is limited to legitimate business needs and is encrypted."
  },
  {
    "name": "gcp_iam_pan_display_masking",
    "gcp_api": "gcp.iam.set_policy()",
    "service": "gcp_iam",
    "rationale": "To ensure that PAN is masked when displayed, except for roles with a legitimate business need."
  },
  {
    "name": "gcp_compute_system_component_risk_analysis_frequency",
    "gcp_api": "gcp.compute.instances.get()",
    "service": "compute",
    "rationale": "To programmatically retrieve and evaluate the frequency of system component evaluations based on risk analysis."
  },
  {
    "name": "gcp_security_antimalware_auto_update_verification",
    "gcp_api": "gcp.securitycenter.findings.list()",
    "service": "securitycenter",
    "rationale": "To verify that anti-malware solutions are configured for automatic updates and that updates are current."
  },
  {
    "name": "gcp_security_antimalware_scan_configuration",
    "gcp_api": "gcp.securitycenter.findings.list()",
    "service": "securitycenter",
    "rationale": "To ensure anti-malware solutions are configured for periodic and real-time scans."
  },
  {
    "name": "gcp_compute_malware_scan_frequency_analysis",
    "gcp_api": "gcp.compute.instances.get()",
    "service": "compute",
    "rationale": "To evaluate the frequency of malware scans based on targeted risk analysis."
  },
  {
    "name": "gcp_security_removable_media_scan_configuration",
    "gcp_api": "gcp.securitycenter.findings.list()",
    "service": "securitycenter",
    "rationale": "To verify that anti-malware solutions are configured to scan removable media upon connection."
  },
  {
    "name": "gcp_security_antimalware_audit_logging_enabled",
    "gcp_api": "gcp.security.antimalware.setAuditLogging()",
    "service": "gcp_security",
    "rationale": "Specific function needed to ensure anti-malware audit logs are enabled and retained."
  },
  {
    "name": "gcp_security_antimalware_protection_enforcement",
    "gcp_api": "gcp.security.antimalware.enforceProtection()",
    "service": "gcp_security",
    "rationale": "Function needed to ensure anti-malware mechanisms cannot be disabled or altered by unauthorized users."
  },
  {
    "name": "gcp_security_phishing_protection_mechanisms",
    "gcp_api": "gcp.security.phishing.protect()",
    "service": "gcp_security",
    "rationale": "Function needed to implement and verify anti-phishing mechanisms."
  },
  {
    "name": "gcp_compute_pan_detection_in_preprod",
    "gcp_api": "gcp.compute.instances.list()",
    "service": "gcp_compute",
    "rationale": "To programmatically verify that live PANs are not present in pre-production environments, a function to scan for PAN patterns in compute instances is needed."
  },
  {
    "name": "gcp_compute_test_data_removal_check",
    "gcp_api": "gcp.compute.instances.list()",
    "service": "gcp_compute",
    "rationale": "To ensure test data and accounts are removed before production, a function to check for test patterns in compute instances is needed."
  },
  {
    "name": "gcp_iam_shared_id_usage_monitoring",
    "gcp_api": "gcp.iam.getSharedIdUsage()",
    "service": "gcp_iam",
    "rationale": "To monitor and log the usage of shared IDs to ensure they are only used under exceptional circumstances."
  },
  {
    "name": "gcp_iam_unique_authentication_factors_per_customer",
    "gcp_api": "gcp.iam.ensureUniqueAuthFactors()",
    "service": "gcp_iam",
    "rationale": "To ensure unique authentication factors are used for each customer premises."
  },
  {
    "name": "gcp_iam_user_id_lifecycle_management",
    "gcp_api": "gcp.iam.manageUserIdLifecycle()",
    "service": "gcp_iam",
    "rationale": "To manage the lifecycle of user IDs including additions, deletions, and modifications with appropriate authorization."
  },
  {
    "name": "gcp_iam_terminate_user_access",
    "gcp_api": "gcp.iam.revokeUserAccess()",
    "service": "gcp_iam",
    "rationale": "To immediately revoke access for terminated users to prevent unauthorized access."
  },
  {
    "name": "gcp_iam_inactive_user_account_management",
    "gcp_api": "gcp.iam.disableInactiveAccounts()",
    "service": "gcp_iam",
    "rationale": "To automatically disable or remove inactive user accounts after 90 days of inactivity."
  },
  {
    "name": "gcp_iam_third_party_account_temporary_enablement",
    "gcp_api": "gcp.iam.setAccountStatus()",
    "service": "gcp_iam",
    "rationale": "To programmatically enable and disable third-party accounts based on time schedules."
  },
  {
    "name": "gcp_compute_instance_idle_timeout_configuration",
    "gcp_api": "gcp.compute.instances.setIdleTimeout()",
    "service": "gcp_compute",
    "rationale": "To enforce idle timeout settings for user sessions on compute instances."
  },
  {
    "name": "gcp_iam_multi_factor_authentication_enforcement",
    "gcp_api": "gcp.iam.enforceMFA()",
    "service": "gcp_iam",
    "rationale": "To ensure that at least one authentication factor is required for user access."
  },
  {
    "name": "gcp_iam_identity_verification_before_modification",
    "gcp_api": "gcp.iam.verifyIdentityBeforeChange()",
    "service": "gcp_iam",
    "rationale": "To ensure identity verification before any authentication factor modification."
  },
  {
    "name": "gcp_iam_mfa_non_console_enforcement",
    "gcp_api": "gcp.iam.setMfaPolicy()",
    "service": "gcp_iam",
    "rationale": "To enforce MFA for all non-console access into the CDE."
  },
  {
    "name": "gcp_iam_mfa_remote_access_enforcement",
    "gcp_api": "gcp.iam.setMfaPolicy()",
    "service": "gcp_iam",
    "rationale": "To enforce MFA for all remote access originating from outside the entity\u2019s network."
  },
  {
    "name": "gcp_iam_mfa_replay_protection",
    "gcp_api": "gcp.iam.setReplayProtection()",
    "service": "gcp_iam",
    "rationale": "To configure MFA systems to prevent replay attacks and ensure proper MFA configuration."
  },
  {
    "name": "gcp_iam_interactive_login_prevention",
    "gcp_api": "gcp.iam.setInteractiveLoginPolicy()",
    "service": "gcp_iam",
    "rationale": "To prevent interactive login for system and application accounts unless explicitly authorized."
  },
  {
    "name": "gcp_security_password_hardcoding_detection",
    "gcp_api": "gcp.security.scanForHardcodedPasswords()",
    "service": "gcp_security",
    "rationale": "To detect and prevent hardcoded passwords in scripts, configuration files, and source code."
  },
  {
    "name": "gcp_security_visitor_access_management",
    "gcp_api": "gcp.security.manageVisitorAccess()",
    "service": "gcp_security",
    "rationale": "Automate the management of visitor access to the CDE, including authorization and monitoring."
  },
  {
    "name": "gcp_security_visitor_badge_deactivation",
    "gcp_api": "gcp.security.deactivateVisitorBadge()",
    "service": "gcp_security",
    "rationale": "Automate the deactivation of visitor badges upon exit or expiration to prevent unauthorized reuse."
  },
  {
    "name": "gcp_security_visitor_log_management",
    "gcp_api": "gcp.security.manageVisitorLogs()",
    "service": "gcp_security",
    "rationale": "Automate the maintenance and retention of visitor logs for at least three months."
  },
  {
    "name": "gcp_storage_media_physical_security",
    "gcp_api": "gcp.storage.ensureMediaSecurity()",
    "service": "gcp_storage",
    "rationale": "Ensure that all media containing cardholder data is physically secured."
  },
  {
    "name": "gcp_storage_offline_backup_security",
    "gcp_api": "gcp.storage.secureOfflineBackups()",
    "service": "gcp_storage",
    "rationale": "Ensure offline media backups with cardholder data are stored securely."
  },
  {
    "name": "gcp_logging_audit_logs_enabled_for_all_components",
    "gcp_api": "logging.projects.logs.list()",
    "service": "gcp_logging",
    "rationale": "To ensure audit logs are enabled for all system components and cardholder data."
  },
  {
    "name": "gcp_logging_user_access_to_cardholder_data",
    "gcp_api": "logging.projects.logs.list()",
    "service": "gcp_logging",
    "rationale": "To specifically capture all individual user access to cardholder data."
  },
  {
    "name": "gcp_logging_admin_access_actions",
    "gcp_api": "logging.projects.logs.list()",
    "service": "gcp_logging",
    "rationale": "To ensure all actions taken by individuals with administrative access are logged."
  },
  {
    "name": "gcp_logging_access_to_audit_logs",
    "gcp_api": "logging.projects.logs.list()",
    "service": "gcp_logging",
    "rationale": "To capture all access to audit logs to prevent tampering."
  },
  {
    "name": "gcp_logging_invalid_access_attempts",
    "gcp_api": "logging.projects.logs.list()",
    "service": "gcp_logging",
    "rationale": "To ensure that all invalid logical access attempts are logged."
  },
  {
    "name": "gcp_logging_audit_log_initialization_tracking",
    "gcp_api": "gcp.logging.audit_logs.initialize()",
    "service": "gcp_logging",
    "rationale": "To track initialization and status changes of audit logs."
  },
  {
    "name": "gcp_logging_system_object_creation_deletion_tracking",
    "gcp_api": "gcp.logging.track.system_objects()",
    "service": "gcp_logging",
    "rationale": "To specifically track creation and deletion of system-level objects."
  },
  {
    "name": "gcp_logging_audit_log_access_control_check",
    "gcp_api": "gcp.logging.check.audit_log_access()",
    "service": "gcp_logging",
    "rationale": "To ensure that access to audit log files is limited based on job-related needs."
  },
  {
    "name": "gcp_compute_time_server_configuration_check",
    "gcp_api": "gcp.compute.instances.get()",
    "service": "compute",
    "rationale": "To verify that instances are configured to use designated time servers and that time synchronization settings are compliant with PCI DSS requirements."
  },
  {
    "name": "gcp_network_time_server_access_control",
    "gcp_api": "gcp.network.firewalls.get()",
    "service": "network",
    "rationale": "To ensure that only designated time servers receive time updates from specific industry-accepted external sources."
  },
  {
    "name": "gcp_compute_time_change_logging",
    "gcp_api": "gcp.logging.entries.list()",
    "service": "logging",
    "rationale": "To ensure that any changes to time settings on critical systems are logged and monitored."
  },
  {
    "name": "gcp_security_critical_control_failure_alerts",
    "gcp_api": "gcp.securitycenter.findings.list()",
    "service": "securitycenter",
    "rationale": "To detect and alert on failures of critical security control systems."
  },
  {
    "name": "gcp_security_critical_control_failure_detection",
    "gcp_api": "gcp.securitycenter.findings.list()",
    "service": "securitycenter",
    "rationale": "To ensure prompt detection and alerting of failures in critical security control systems."
  },
  {
    "name": "gcp_security_control_failure_response",
    "gcp_api": "gcp.securitycenter.findings.update()",
    "service": "securitycenter",
    "rationale": "To document and respond to failures of critical security control systems, including identifying causes and implementing remediation."
  },
  {
    "name": "gcp_network_wireless_access_point_detection",
    "gcp_api": "gcp.network.list_access_points()",
    "service": "gcp_network",
    "rationale": "To programmatically detect and list authorized and unauthorized wireless access points."
  },
  {
    "name": "gcp_network_wireless_alert_configuration",
    "gcp_api": "gcp.network.configure_alerts()",
    "service": "gcp_network",
    "rationale": "To configure alerts for unauthorized wireless access points detection."
  },
  {
    "name": "gcp_network_authorized_access_point_inventory",
    "gcp_api": "gcp.network.get_authorized_access_points()",
    "service": "gcp_network",
    "rationale": "To maintain an inventory of authorized wireless access points programmatically."
  },
  {
    "name": "gcp_security_vulnerability_rescan_verification",
    "gcp_api": "gcp.security.rescan_vulnerabilities()",
    "service": "gcp_security",
    "rationale": "To verify that rescans confirm resolution of high-risk vulnerabilities."
  },
  {
    "name": "gcp_security_vulnerability_rescan_scheduling",
    "gcp_api": "gcp.security.command_center.scheduleRescan()",
    "service": "security_command_center",
    "rationale": "To automate the scheduling of rescans based on risk assessment."
  },
  {
    "name": "gcp_security_authenticated_scan_configuration",
    "gcp_api": "gcp.security.command_center.configureAuthenticatedScan()",
    "service": "security_command_center",
    "rationale": "To ensure authenticated scans are configured with sufficient privileges."
  },
  {
    "name": "gcp_security_post_change_vulnerability_scan",
    "gcp_api": "gcp.security.command_center.scanAfterChange()",
    "service": "security_command_center",
    "rationale": "To ensure scans are automatically triggered after significant changes."
  },
  {
    "name": "gcp_security_external_vulnerability_scan_scheduling",
    "gcp_api": "gcp.security.command_center.scheduleExternalScan()",
    "service": "security_command_center",
    "rationale": "To automate the scheduling of external vulnerability scans every three months."
  },
  {
    "name": "gcp_security_external_post_change_scan",
    "gcp_api": "gcp.security.command_center.externalScanAfterChange()",
    "service": "security_command_center",
    "rationale": "To ensure external scans are conducted after significant changes."
  },
  {
    "name": "gcp_security_penetration_testing_scheduling",
    "gcp_api": "gcp.security.schedulePenetrationTest()",
    "service": "gcp_security",
    "rationale": "Automate scheduling and execution of penetration tests to ensure coverage and frequency requirements are met."
  },
  {
    "name": "gcp_security_penetration_test_results_retention",
    "gcp_api": "gcp.security.storeTestResults()",
    "service": "gcp_security",
    "rationale": "Ensure retention of penetration test results and remediation activities for at least 12 months."
  },
  {
    "name": "gcp_security_internal_penetration_testing",
    "gcp_api": "gcp.security.executeInternalPenTest()",
    "service": "gcp_security",
    "rationale": "Automate internal penetration testing to ensure it is performed according to defined methodology and frequency."
  },
  {
    "name": "gcp_security_external_penetration_testing",
    "gcp_api": "gcp.security.executeExternalPenTest()",
    "service": "gcp_security",
    "rationale": "Automate external penetration testing to ensure it is performed according to defined methodology and frequency."
  },
  {
    "name": "gcp_security_vulnerability_remediation_tracking",
    "gcp_api": "gcp.security.trackRemediation()",
    "service": "gcp_security",
    "rationale": "Track and verify remediation of vulnerabilities found during penetration testing."
  },
  {
    "name": "gcp_network_segmentation_penetration_testing",
    "gcp_api": "gcp.network.testSegmentation()",
    "service": "gcp_network",
    "rationale": "Automate penetration testing of segmentation controls to ensure they are operational and effective."
  },
  {
    "name": "gcp_network_segmentation_penetration_test_scheduling",
    "gcp_api": "gcp.network.schedulePenetrationTest()",
    "service": "gcp_network",
    "rationale": "To automate scheduling and verification of segmentation penetration tests."
  },
  {
    "name": "gcp_iam_customer_penetration_test_access",
    "gcp_api": "gcp.iam.setCustomerAccess()",
    "service": "gcp_iam",
    "rationale": "To programmatically manage customer access for penetration testing purposes."
  },
  {
    "name": "gcp_network_intrusion_detection_configuration",
    "gcp_api": "gcp.network.configureIDS()",
    "service": "gcp_network",
    "rationale": "To ensure IDS/IPS configurations are set and monitored programmatically."
  },
  {
    "name": "gcp_security_malware_communication_detection",
    "gcp_api": "gcp.security.detectMalwareCommunication()",
    "service": "gcp_security",
    "rationale": "To detect and alert on covert malware communication channels programmatically."
  },
  {
    "name": "gcp_storage_file_integrity_monitoring",
    "gcp_api": "gcp.storage.monitorFileIntegrity()",
    "service": "gcp_storage",
    "rationale": "To implement file integrity monitoring for critical files programmatically."
  },
  {
    "name": "gcp_security_http_header_tamper_detection",
    "gcp_api": "gcp.security.httpHeaderTamperDetection()",
    "service": "gcp_security",
    "rationale": "To programmatically detect and alert on unauthorized modifications to HTTP headers and script contents of payment pages."
  },
  {
    "name": "gcp_security_phishing_protection_configuration",
    "gcp_api": "gcp.security.phishingProtection()",
    "service": "gcp_security",
    "rationale": "To programmatically configure phishing protection settings and monitor for phishing attempts."
  },
  {
    "name": "gcp_iam_third_party_service_provider_management",
    "gcp_api": "gcp.iam.thirdPartyServiceProvider()",
    "service": "gcp_iam",
    "rationale": "To manage and maintain a list of third-party service providers programmatically."
  },
  {
    "name": "gcp_iam_tpsp_engagement_audit",
    "gcp_api": "gcp.iam.audit()",
    "service": "gcp_iam",
    "rationale": "To programmatically verify and audit the engagement process of TPSPs, ensuring due diligence is performed."
  },
  {
    "name": "gcp_iam_tpsp_compliance_monitoring",
    "gcp_api": "gcp.iam.complianceStatus()",
    "service": "gcp_iam",
    "rationale": "To automate the monitoring of TPSPs' PCI DSS compliance status annually."
  },
  {
    "name": "gcp_iam_tpsp_responsibility_matrix",
    "gcp_api": "gcp.iam.responsibilityMatrix()",
    "service": "gcp_iam",
    "rationale": "To maintain and programmatically verify the responsibility matrix for PCI DSS requirements between TPSPs and the entity."
  },
  {
    "name": "gcp_iam_tpsp_agreement_verification",
    "gcp_api": "gcp.iam.agreementVerification()",
    "service": "gcp_iam",
    "rationale": "To verify that TPSPs provide written agreements acknowledging their security responsibilities."
  },
  {
    "name": "gcp_iam_tpsp_information_provision",
    "gcp_api": "gcp.iam.informationProvision()",
    "service": "gcp_iam",
    "rationale": "To support TPSPs in providing necessary information to customers for PCI DSS compliance."
  },
  {
    "name": "gcp_security_incident_alert_response",
    "gcp_api": "gcp.securitycenter.alerts.list()",
    "service": "security_command_center",
    "rationale": "To enable automated responses to alerts generated by security monitoring systems."
  },
  {
    "name": "gcp_network_intrusion_detection_monitoring",
    "gcp_api": "gcp.network.securityMonitoring()",
    "service": "network_security",
    "rationale": "To monitor and respond to intrusion-detection and intrusion-prevention alerts."
  },
  {
    "name": "gcp_security_incident_plan_update",
    "gcp_api": "gcp.securitycenter.incidentResponsePlan.update()",
    "service": "security_command_center",
    "rationale": "To programmatically update the incident response plan based on lessons learned and industry developments."
  },
  {
    "name": "gcp_storage_pan_detection",
    "gcp_api": "gcp.storage.dataInspection()",
    "service": "storage",
    "rationale": "To detect stored PAN in unexpected locations and trigger incident response procedures."
  },
  {
    "name": "gcp_security_pan_remediation",
    "gcp_api": "gcp.securitycenter.panRemediation()",
    "service": "security_command_center",
    "rationale": "To automate the remediation process when PAN is detected outside the CDE."
  }
]