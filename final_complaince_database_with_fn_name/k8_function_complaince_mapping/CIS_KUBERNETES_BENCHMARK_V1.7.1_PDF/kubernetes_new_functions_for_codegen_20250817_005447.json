{
  "metadata": {
    "generated_at": "2025-08-17T00:54:47.749875",
    "total_new_functions": 69,
    "description": "New Kubernetes security functions suggested by compliance mapper for Python code generation"
  },
  "new_functions": [
    {
      "function_name": "apiserver_pod_spec_file_permissions",
      "service": "apiserver",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l <file_path>",
      "rationale": "This function is needed to check the permissions of the API server pod specification file and ensure they are set to 644 or more restrictive.",
      "compliance_id": "1.1.1",
      "compliance_title": "Ensure that the API server pod specification file permissions are set to 644 or more restrictive",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'apiserver_pod_spec_file_permissions' is suggested to check the permissions of the API server pod specification file."
    },
    {
      "function_name": "apiserver_pod_spec_file_ownership",
      "service": "apiserver",
      "kubernetes_api": "kubectl exec -it <pod_name> -- chown root:root <file_path>",
      "rationale": "This function is needed to ensure that the API server pod specification file ownership is set to root:root, which is a requirement for compliance item 1.1.2",
      "compliance_id": "1.1.2",
      "compliance_title": "Ensure that the API server pod specification file ownership is set to root:root",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'apiserver_pod_spec_file_ownership' is suggested to fill this gap."
    },
    {
      "function_name": "controllermanager_pod_spec_file_permissions",
      "service": "controllermanager",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l <file_path>",
      "rationale": "This function is needed to check the permissions of the controller manager pod specification file and ensure they are set to 644 or more restrictive.",
      "compliance_id": "1.1.3",
      "compliance_title": "Ensure that the controller manager pod specification file permissions are set to 644 or more restrictive",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'controllermanager_pod_spec_file_permissions' is suggested to check the permissions of the controller manager pod specification file."
    },
    {
      "function_name": "controllermanager_pod_spec_file_ownership",
      "service": "controllermanager",
      "kubernetes_api": "kubectl exec -it <pod_name> -- chown root:root <file_path>",
      "rationale": "This function is needed to ensure that the controller manager pod specification file ownership is set to root:root, which is a security best practice to prevent unauthorized modifications.",
      "compliance_id": "1.1.4",
      "compliance_title": "Ensure that the controller manager pod specification file ownership is set to root:root",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'controllermanager_pod_spec_file_ownership' is suggested to check and set the ownership of the controller manager pod specification file to root:root."
    },
    {
      "function_name": "scheduler_pod_spec_file_permissions",
      "service": "scheduler",
      "kubernetes_api": "kubectl get pods -n kube-system",
      "rationale": "To ensure that the scheduler pod specification file permissions are set to 644 or more restrictive",
      "compliance_id": "1.1.5",
      "compliance_title": "Ensure that the scheduler pod specification file permissions are set to 644 or more restrictive",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'scheduler_pod_spec_file_permissions' is suggested to check the permissions of the scheduler pod specification file."
    },
    {
      "function_name": "scheduler_pod_spec_file_ownership",
      "service": "scheduler",
      "kubernetes_api": "kubectl exec -it <pod_name> -- chown root:root <scheduler_pod_spec_file>",
      "rationale": "This function is needed to ensure that the scheduler pod specification file ownership is set to root:root, which is a security best practice to prevent unauthorized modifications.",
      "compliance_id": "1.1.6",
      "compliance_title": "Ensure that the scheduler pod specification file ownership is set to root:root",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'scheduler_pod_spec_file_ownership' is suggested."
    },
    {
      "function_name": "etcd_pod_spec_file_permissions",
      "service": "etcd",
      "kubernetes_api": "kubectl exec -it etcd-master -- ls -l /etc/kubernetes/manifests/etcd.yaml",
      "rationale": "This function is needed to check the permissions of the etcd pod specification file and ensure they are set to 644 or more restrictive",
      "compliance_id": "1.1.7",
      "compliance_title": "Ensure that the etcd pod specification file permissions are set to 644 or more restrictive",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'etcd_pod_spec_file_permissions' is suggested to check the permissions of the etcd pod specification file."
    },
    {
      "function_name": "etcd_pod_spec_file_ownership",
      "service": "etcd",
      "kubernetes_api": "kubectl exec -it etcd-master -- chown root:root /etc/kubernetes/manifests/etcd.yaml",
      "rationale": "This function is needed to ensure that the etcd pod specification file ownership is set to root:root, which is a security best practice to prevent unauthorized modifications.",
      "compliance_id": "1.1.8",
      "compliance_title": "Ensure that the etcd pod specification file ownership is set to root:root",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'etcd_pod_spec_file_ownership' is suggested to check and set the ownership of the etcd pod specification file to root:root."
    },
    {
      "function_name": "container_network_interface_file_permissions",
      "service": "core",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/cni/net.d/",
      "rationale": "This function is needed to check the permissions of the Container Network Interface files and ensure they are set to 644 or more restrictive",
      "compliance_id": "1.1.9",
      "compliance_title": "Ensure that the Container Network Interface file permissions are set to 644 or more restrictive",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'container_network_interface_file_permissions' is suggested to check the permissions of the Container Network Interface files."
    },
    {
      "function_name": "container_network_interface_file_ownership",
      "service": "core",
      "kubernetes_api": "kubectl exec -it <pod_name> -- chown root:root <cni_file_path>",
      "rationale": "This function is needed to ensure that the Container Network Interface file ownership is set to root:root, which is a security best practice to prevent unauthorized modifications.",
      "compliance_id": "1.1.10",
      "compliance_title": "Ensure that the Container Network Interface file ownership is set to root:root",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'container_network_interface_file_ownership' is suggested to check and set the ownership of the Container Network Interface files to root:root."
    },
    {
      "function_name": "etcd_data_directory_permissions_check",
      "service": "etcd",
      "kubernetes_api": "kubectl exec etcd-master -n kube-system -- ls -l /var/lib/etcd",
      "rationale": "This function is needed to check the permissions of the etcd data directory and ensure they are set to 700 or more restrictive",
      "compliance_id": "1.1.11",
      "compliance_title": "Ensure that the etcd data directory permissions are set to 700 or more restrictive",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly address the compliance requirement of checking etcd data directory permissions. A new function 'etcd_data_directory_permissions_check' is suggested to fill this gap."
    },
    {
      "function_name": "etcd_data_directory_ownership_check",
      "service": "etcd",
      "kubernetes_api": "kubectl exec -it etcd-master -- chown -R etcd:etcd /var/lib/etcd",
      "rationale": "This function is needed to ensure that the etcd data directory ownership is set to etcd:etcd, which is a critical security measure to protect the data stored in etcd.",
      "compliance_id": "1.1.12",
      "compliance_title": "Ensure that the etcd data directory ownership is set to etcd:etcd",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly address the requirement of checking the ownership of the etcd data directory. Therefore, a new function 'etcd_data_directory_ownership_check' is suggested."
    },
    {
      "function_name": "admin_conf_file_permissions",
      "service": "apiserver",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/admin.conf",
      "rationale": "To ensure that the admin.conf file permissions are set to 644",
      "compliance_id": "1.1.13",
      "compliance_title": "Ensure that the admin.conf file permissions are set to 644",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing function 'kubelet_conf_file_permissions' partially covers the compliance requirement. However, it does not specifically check the permissions of the admin.conf file. Therefore, a new function 'admin_conf_file_permissions' is suggested."
    },
    {
      "function_name": "apiserver_admin_conf_file_ownership",
      "service": "apiserver",
      "kubernetes_api": "ls -l /etc/kubernetes/admin.conf",
      "rationale": "To ensure that the admin.conf file ownership is set to root:root, a new function is needed that checks the ownership of this file.",
      "compliance_id": "1.1.14",
      "compliance_title": "Ensure that the admin.conf file ownership is set to root:root",
      "coverage_assessment": "none",
      "mapping_notes": "No existing function in the database checks the ownership of the admin.conf file. A new function 'apiserver_admin_conf_file_ownership' is suggested to fill this gap."
    },
    {
      "function_name": "scheduler_conf_file_permissions",
      "service": "scheduler",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/scheduler.conf",
      "rationale": "This function is needed to check the permissions of the scheduler.conf file and ensure they are set to 644 or more restrictive.",
      "compliance_id": "1.1.15",
      "compliance_title": "Ensure that the scheduler.conf file permissions are set to 644 or more restrictive",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'scheduler_conf_file_permissions' is suggested to check the permissions of the scheduler.conf file."
    },
    {
      "function_name": "scheduler_conf_file_ownership",
      "service": "scheduler",
      "kubernetes_api": "kubectl exec -it <pod_name> -n kube-system -- ls -l /etc/kubernetes/scheduler.conf",
      "rationale": "This function is needed to ensure that the scheduler.conf file ownership is set to root:root, which is a critical security measure to prevent unauthorized access or modifications.",
      "compliance_id": "1.1.16",
      "compliance_title": "Ensure that the scheduler.conf file ownership is set to root:root",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'scheduler_conf_file_ownership' is suggested to check the ownership of the scheduler.conf file."
    },
    {
      "function_name": "controllermanager_conf_file_permissions",
      "service": "controllermanager",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/controller-manager.conf",
      "rationale": "This function is needed to check the permissions of the controller-manager.conf file and ensure they are set to 644 or more restrictive.",
      "compliance_id": "1.1.17",
      "compliance_title": "Ensure that the controller-manager.conf file permissions are set to 644 or more restrictive",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'controllermanager_conf_file_permissions' is suggested to check the permissions of the controller-manager.conf file."
    },
    {
      "function_name": "controllermanager_conf_file_ownership",
      "service": "controllermanager",
      "kubernetes_api": "kubectl exec -it <pod_name> -n kube-system -- ls -l /etc/kubernetes/controller-manager.conf",
      "rationale": "This function is needed to ensure that the controller-manager.conf file ownership is set to root:root, which is a critical security measure to prevent unauthorized access or modifications.",
      "compliance_id": "1.1.18",
      "compliance_title": "Ensure that the controller-manager.conf file ownership is set to root:root",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'controllermanager_conf_file_ownership' is suggested to check the ownership of the controller-manager.conf file."
    },
    {
      "function_name": "kubernetes_pki_directory_file_ownership_check",
      "service": "apiserver",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/pki/",
      "rationale": "This function is needed to ensure that the Kubernetes PKI directory and file ownership is set to root:root, which is a critical security measure to prevent unauthorized access or modifications.",
      "compliance_id": "1.1.19",
      "compliance_title": "Ensure that the Kubernetes PKI directory and file ownership is set to root:root",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly address the compliance requirement of ensuring the Kubernetes PKI directory and file ownership is set to root:root. A new function 'kubernetes_pki_directory_file_ownership_check' is suggested to fill this gap."
    },
    {
      "function_name": "apiserver_pki_cert_file_permissions",
      "service": "apiserver",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/pki/",
      "rationale": "To ensure that the Kubernetes PKI certificate files have permissions of 600 or more restrictive",
      "compliance_id": "1.1.20",
      "compliance_title": "Ensure that the Kubernetes PKI certificate file permissions are set to 600 or more restrictive",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly address the compliance requirement of ensuring that the Kubernetes PKI certificate file permissions are set to 600 or more restrictive. A new function 'apiserver_pki_cert_file_permissions' is suggested to fill this gap."
    },
    {
      "function_name": "kubernetes_pki_key_file_permissions_check",
      "service": "core",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/pki/",
      "rationale": "This function is needed to ensure that the Kubernetes PKI key files have permissions of 600.",
      "compliance_id": "1.1.21",
      "compliance_title": "Ensure that the Kubernetes PKI key file permissions are set to 600",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'kubernetes_pki_key_file_permissions_check' is suggested to check the permissions of Kubernetes PKI key files."
    },
    {
      "function_name": "etcd_certfile_and_keyfile_set",
      "service": "etcd",
      "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[?(@.metadata.labels.component==\"etcd\")].spec.containers[0].command}'",
      "rationale": "To ensure that the --etcd-certfile and --etcd-keyfile arguments are set as appropriate, a specific function is needed to check these arguments in the etcd configuration.",
      "compliance_id": "1.2.25",
      "compliance_title": "Ensure that the --etcd-certfile and --etcd-keyfile arguments are set as appropriate",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing functions 'apiserver_etcd_tls_config' and 'etcd_tls_encryption' partially cover the compliance requirement by ensuring that etcd is configured to use TLS encryption. However, they do not specifically check for the --etcd-certfile and --etcd-keyfile arguments. Therefore, a new function 'etcd_certfile_and_keyfile_set' is suggested to fill this gap."
    },
    {
      "function_name": "apiserver_tls_cert_file_set",
      "service": "apiserver",
      "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[*].spec.containers[*].command}' | grep -- '--tls-cert-file'",
      "rationale": "To ensure that the --tls-cert-file argument is set as appropriate",
      "compliance_id": "1.2.26",
      "compliance_title": "Ensure that the --tls-cert-file and --tls-private-key-file arguments are set as appropriate",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing functions 'apiserver_tls_config' and 'kubelet_tls_cert_and_key' partially cover the compliance requirement. However, they do not specifically check for the --tls-cert-file and --tls-private-key-file arguments. Therefore, two new functions 'apiserver_tls_cert_file_set' and 'apiserver_tls_private_key_file_set' are suggested to fill this gap."
    },
    {
      "function_name": "apiserver_tls_private_key_file_set",
      "service": "apiserver",
      "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[*].spec.containers[*].command}' | grep -- '--tls-private-key-file'",
      "rationale": "To ensure that the --tls-private-key-file argument is set as appropriate",
      "compliance_id": "1.2.26",
      "compliance_title": "Ensure that the --tls-cert-file and --tls-private-key-file arguments are set as appropriate",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing functions 'apiserver_tls_config' and 'kubelet_tls_cert_and_key' partially cover the compliance requirement. However, they do not specifically check for the --tls-cert-file and --tls-private-key-file arguments. Therefore, two new functions 'apiserver_tls_cert_file_set' and 'apiserver_tls_private_key_file_set' are suggested to fill this gap."
    },
    {
      "function_name": "controllermanager_terminated_pod_gc_threshold_set",
      "service": "controllermanager",
      "kubernetes_api": "kubectl get pods -n kube-system",
      "rationale": "This function is needed to ensure that the garbage collector is activated on pod termination as appropriate, which is a requirement of compliance item 1.3.1.",
      "compliance_id": "1.3.1",
      "compliance_title": "Ensure that the --terminated-pod-gc-threshold argument is set as appropriate",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'controllermanager_terminated_pod_gc_threshold_set' is suggested to check if the --terminated-pod-gc-threshold argument is set as appropriate."
    },
    {
      "function_name": "apiserver_root_ca_file_set",
      "service": "apiserver",
      "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{range .items[*]}{.spec.containers[*].command}{\"\\n\"}{end}' | grep kube-apiserver | grep -- --root-ca-file",
      "rationale": "To ensure that the --root-ca-file argument is set as appropriate in the API server",
      "compliance_id": "1.3.5",
      "compliance_title": "Ensure that the --root-ca-file argument is set as appropriate",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing functions check if the --client-ca-file argument is set for the API server, controller manager, and kubelet, which is related but not exactly the same as checking the --root-ca-file argument. Therefore, a new function is needed to specifically check the --root-ca-file argument in the API server."
    },
    {
      "function_name": "etcd_cert_file_and_key_file_set",
      "service": "etcd",
      "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[*].spec.containers[*].command}'",
      "rationale": "To ensure that the --cert-file and --key-file arguments are set as appropriate for etcd service",
      "compliance_id": "2.1",
      "compliance_title": "Ensure that the --cert-file and --key-file arguments are set as appropriate",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing functions 'apiserver_etcd_tls_config' and 'etcd_tls_encryption' partially cover the compliance requirement. However, they do not specifically check if the --cert-file and --key-file arguments are set. Therefore, a new function 'etcd_cert_file_and_key_file_set' is suggested."
    },
    {
      "function_name": "apiserver_no_auto_tls",
      "service": "apiserver",
      "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[?(@.metadata.labels.component==\"kube-apiserver\")].spec.containers[0].command}'",
      "rationale": "To ensure that the --auto-tls argument is not set to true in the apiserver",
      "compliance_id": "2.3",
      "compliance_title": "Ensure that the --auto-tls argument is not set to true",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing function 'etcd_no_auto_tls' partially covers the compliance requirement. However, it only checks the etcd service. A new function 'apiserver_no_auto_tls' is needed to check the apiserver service."
    },
    {
      "function_name": "etcd_peer_cert_file_set",
      "service": "etcd",
      "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[*].spec.containers[*].command}' | grep -- --peer-cert-file",
      "rationale": "To ensure that the --peer-cert-file argument is set as appropriate",
      "compliance_id": "2.4",
      "compliance_title": "Ensure that the --peer-cert-file and --peer-key-file arguments are set as appropriate",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing function 'etcd_peer_tls_config' partially covers the compliance requirement by checking the TLS configuration for etcd peers. However, it does not specifically check for the --peer-cert-file and --peer-key-file arguments. Therefore, two new functions 'etcd_peer_cert_file_set' and 'etcd_peer_key_file_set' are suggested to fill this gap."
    },
    {
      "function_name": "etcd_peer_key_file_set",
      "service": "etcd",
      "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[*].spec.containers[*].command}' | grep -- --peer-key-file",
      "rationale": "To ensure that the --peer-key-file argument is set as appropriate",
      "compliance_id": "2.4",
      "compliance_title": "Ensure that the --peer-cert-file and --peer-key-file arguments are set as appropriate",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing function 'etcd_peer_tls_config' partially covers the compliance requirement by checking the TLS configuration for etcd peers. However, it does not specifically check for the --peer-cert-file and --peer-key-file arguments. Therefore, two new functions 'etcd_peer_cert_file_set' and 'etcd_peer_key_file_set' are suggested to fill this gap."
    },
    {
      "function_name": "apiserver_disable_user_client_cert_auth",
      "service": "apiserver",
      "kubernetes_api": "kubectl get --raw /api/v1/nodes | jq -r '.items[].status.addresses[] | select(.type == \"InternalIP\") .address'",
      "rationale": "To ensure that client certificate authentication is not used for users, a function is needed to disable this authentication method for user accounts in the API server.",
      "compliance_id": "3.1.1",
      "compliance_title": "Client certificate authentication should not be used for users",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing functions 'apiserver_client_ca_file_set', 'apiserver_auth_mode_include_rbac', and 'apiserver_auth_mode_not_always_allow' partially cover the compliance requirement by setting up the client certificate file and enabling RBAC. However, a new function 'apiserver_disable_user_client_cert_auth' is needed to specifically disable client certificate authentication for users."
    },
    {
      "function_name": "apiserver_disable_service_account_token_for_users",
      "service": "apiserver",
      "kubernetes_api": "kubectl get serviceaccounts -A",
      "rationale": "To ensure that service account tokens are not used for user authentication, a function is needed to check and disable this feature for all users.",
      "compliance_id": "3.1.2",
      "compliance_title": "Service account token authentication should not be used for users",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing functions provide partial coverage as they deal with service account configuration and minimizing token creation. However, there is no specific function to disable service account token authentication for users, hence a new function is suggested."
    },
    {
      "function_name": "apiserver_bootstrap_token_auth_check",
      "service": "apiserver",
      "kubernetes_api": "kubectl get clusterrolebindings system:node-bootstrapper -o json",
      "rationale": "To ensure bootstrap tokens are not used for general authentication",
      "compliance_id": "3.1.3",
      "compliance_title": "Bootstrap token authentication should not be used for users",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing function 'apiserver_no_token_auth_file' partially covers the compliance requirement by ensuring that token authentication is not used. However, it does not specifically check for bootstrap token authentication. Therefore, a new function 'apiserver_bootstrap_token_auth_check' is suggested to specifically check for bootstrap token authentication."
    },
    {
      "function_name": "apiserver_audit_policy_file_set",
      "service": "apiserver",
      "kubernetes_api": "kubectl get pods -n kube-system",
      "rationale": "This function is needed to ensure that the --audit-policy-file flag is set, which is a requirement for enabling logging of requests made to the API server.",
      "compliance_id": "3.2.1",
      "compliance_title": "Ensure that a minimal audit policy is created",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing functions cover the settings for the audit log such as max age, max backup, max size, and log path. However, there is no function that checks if the --audit-policy-file flag is set. Therefore, a new function 'apiserver_audit_policy_file_set' is suggested."
    },
    {
      "function_name": "apiserver_audit_policy_security_concerns_check",
      "service": "apiserver",
      "kubernetes_api": "kubectl get auditpolicies.audit.k8s.io -n kube-system",
      "rationale": "To ensure that the audit policy created for the cluster covers key security concerns",
      "compliance_id": "3.2.2",
      "compliance_title": "Ensure that the audit policy covers key security concerns",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing functions cover the configuration of audit logs but do not specifically check if the audit policy covers key security concerns. A new function is suggested to fill this gap."
    },
    {
      "function_name": "proxy_kubeconfig_file_permissions",
      "service": "kube-proxy",
      "kubernetes_api": "kubectl exec -it kube-proxy -- ls -l /etc/kubernetes/proxy-kubeconfig",
      "rationale": "This function is needed to check the permissions of the proxy kubeconfig file and ensure they are set to 644 or more restrictive.",
      "compliance_id": "4.1.3",
      "compliance_title": "If proxy kubeconfig file exists ensure permissions are set to 644 or more restrictive",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'proxy_kubeconfig_file_permissions' is suggested to check the permissions of the proxy kubeconfig file."
    },
    {
      "function_name": "kube_proxy_kubeconfig_file_ownership",
      "service": "kube-proxy",
      "kubernetes_api": "ls -l /etc/kubernetes/proxy.conf",
      "rationale": "To ensure the kube-proxy kubeconfig file is owned by root:root",
      "compliance_id": "4.1.4",
      "compliance_title": "If proxy kubeconfig file exists ensure ownership is set to root:root",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions could be mapped to this compliance requirement. A new function is suggested to check the ownership of the kube-proxy kubeconfig file."
    },
    {
      "function_name": "apiserver_ca_file_permissions_check",
      "service": "apiserver",
      "kubernetes_api": "kubectl get pods -n kube-system",
      "rationale": "To ensure that the certificate authorities file permissions are set to 600 or more restrictive",
      "compliance_id": "4.1.7",
      "compliance_title": "Ensure that the certificate authorities file permissions are set to 600 or more restrictive",
      "coverage_assessment": "partial",
      "mapping_notes": "Existing functions only check if the CA file is set, but do not check the file permissions. New functions are needed to check the file permissions."
    },
    {
      "function_name": "kubelet_ca_file_permissions_check",
      "service": "kubelet",
      "kubernetes_api": "kubectl get pods -n kube-system",
      "rationale": "To ensure that the certificate authorities file permissions are set to 600 or more restrictive",
      "compliance_id": "4.1.7",
      "compliance_title": "Ensure that the certificate authorities file permissions are set to 600 or more restrictive",
      "coverage_assessment": "partial",
      "mapping_notes": "Existing functions only check if the CA file is set, but do not check the file permissions. New functions are needed to check the file permissions."
    },
    {
      "function_name": "check_client_ca_file_ownership",
      "service": "apiserver",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/pki",
      "rationale": "To ensure that the client certificate authorities file ownership is set to root:root",
      "compliance_id": "4.1.8",
      "compliance_title": "Ensure that the client certificate authorities file ownership is set to root:root",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing functions 'apiserver_client_ca_file_set' and 'kubelet_client_ca_file_set' partially cover the compliance requirement as they ensure the client certificate authorities file is set. However, they do not check the ownership of the file. Therefore, a new function 'check_client_ca_file_ownership' is needed to ensure the file ownership is set to root:root."
    },
    {
      "function_name": "kubelet_no_hostname_override",
      "service": "kubelet",
      "kubernetes_api": "kubectl get nodes -o jsonpath='{.items[*].spec.taints}'",
      "rationale": "This function is needed to ensure that the --hostname-override argument is not set in kubelet configuration",
      "compliance_id": "4.2.7",
      "compliance_title": "Ensure that the --hostname-override argument is not set",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'kubelet_no_hostname_override' is suggested to check if the --hostname-override argument is not set in kubelet configuration."
    },
    {
      "function_name": "kubelet_set_pod_pid_limit",
      "service": "kubelet",
      "kubernetes_api": "kubectl describe node | grep -i 'PodPidsLimit'",
      "rationale": "This function is needed to ensure that the Kubelet sets limits on the number of PIDs that can be created by pods running on the node.",
      "compliance_id": "4.2.13",
      "compliance_title": "Ensure that a limit is set on pod PIDs",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly address the compliance requirement of setting a limit on pod PIDs. A new function 'kubelet_set_pod_pid_limit' is suggested to fill this gap."
    },
    {
      "function_name": "apiserver_restrict_secrets_access",
      "service": "apiserver",
      "kubernetes_api": "kubectl get secrets --all-namespaces",
      "rationale": "To ensure that access to secrets is restricted to the smallest possible group of users",
      "compliance_id": "5.1.2",
      "compliance_title": "Minimize access to secrets",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing function 'rbac_minimize_secret_access' partially covers the compliance requirement by minimizing access to secrets via RBAC. However, additional functions are needed to restrict access to secrets at the API server level and to prevent exposure of secrets in environment variables."
    },
    {
      "function_name": "core_no_secrets_in_envs",
      "service": "core",
      "kubernetes_api": "kubectl get pods --all-namespaces -o jsonpath='{.items[*].spec.containers[*].env[*].valueFrom.secretKeyRef}'",
      "rationale": "To ensure that secrets are not exposed in environment variables",
      "compliance_id": "5.1.2",
      "compliance_title": "Minimize access to secrets",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing function 'rbac_minimize_secret_access' partially covers the compliance requirement by minimizing access to secrets via RBAC. However, additional functions are needed to restrict access to secrets at the API server level and to prevent exposure of secrets in environment variables."
    },
    {
      "function_name": "rbac_minimize_privileged_service_account_assignment",
      "service": "apiserver",
      "kubernetes_api": "kubectl get serviceaccounts -n kube-system",
      "rationale": "To ensure that privileged service accounts are not assigned to pods unnecessarily",
      "compliance_id": "5.1.4",
      "compliance_title": "Minimize access to create pods",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing function 'rbac_minimize_pod_creation_access' partially covers the compliance requirement by minimizing access to create pods. However, it does not cover the aspects of privileged service account assignment and hostPath mounting. Therefore, two new functions 'rbac_minimize_privileged_service_account_assignment' and 'rbac_minimize_hostpath_mount' are suggested."
    },
    {
      "function_name": "rbac_minimize_hostpath_mount",
      "service": "apiserver",
      "kubernetes_api": "kubectl get pods -n kube-system",
      "rationale": "To ensure that pods do not have access to sensitive hostPaths",
      "compliance_id": "5.1.4",
      "compliance_title": "Minimize access to create pods",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing function 'rbac_minimize_pod_creation_access' partially covers the compliance requirement by minimizing access to create pods. However, it does not cover the aspects of privileged service account assignment and hostPath mounting. Therefore, two new functions 'rbac_minimize_privileged_service_account_assignment' and 'rbac_minimize_hostpath_mount' are suggested."
    },
    {
      "function_name": "core_default_service_account_usage_check",
      "service": "core",
      "kubernetes_api": "kubectl get serviceaccounts -A",
      "rationale": "To ensure that default service accounts are not actively used, a function is needed to check the usage of default service accounts across all namespaces.",
      "compliance_id": "5.1.5",
      "compliance_title": "Ensure that default service accounts are not actively used.",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing functions mapped are related to service account configuration and management, but none of them specifically checks for the active usage of default service accounts. Hence, a new function is suggested to fill this gap."
    },
    {
      "function_name": "core_minimize_service_account_token_mount",
      "service": "core",
      "kubernetes_api": "kubectl get pods --all-namespaces -o jsonpath='{range .items[*]}{\"\\n\"}{.metadata.name}{\": \"}{.spec.serviceAccountName}{\" \"}{.spec.automountServiceAccountToken}{end}'",
      "rationale": "This function is needed to check if service account tokens are being mounted unnecessarily in pods",
      "compliance_id": "5.1.6",
      "compliance_title": "Ensure that Service Account Tokens are only mounted where necessary",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing functions 'apiserver_service_account_plugin' and 'apiserver_service_account_lookup_true' partially cover the compliance requirement by ensuring that the service account plugin is enabled and that service account tokens are verified against the API server. However, a new function 'core_minimize_service_account_token_mount' is needed to check if service account tokens are being mounted in pods where they are not necessary."
    },
    {
      "function_name": "avoid_system_masters_group_usage",
      "service": "apiserver",
      "kubernetes_api": "kubectl get clusterrolebindings -o json",
      "rationale": "This function is needed to check if any user or service account is granted permissions using the system:masters group",
      "compliance_id": "5.1.7",
      "compliance_title": "Avoid use of system:masters group",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly address the compliance requirement of avoiding the use of system:masters group. A new function 'avoid_system_masters_group_usage' is suggested to fill this gap."
    },
    {
      "function_name": "rbac_limit_bind_permission",
      "service": "rbac",
      "kubernetes_api": "kubectl get clusterrolebindings,rolebindings --all-namespaces -o json",
      "rationale": "To ensure that bind permissions are not granted unless strictly required",
      "compliance_id": "5.1.8",
      "compliance_title": "Limit use of the Bind, Impersonate and Escalate permissions in the Kubernetes cluster",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly address the compliance requirement of limiting the use of Bind, Impersonate, and Escalate permissions. New functions are suggested to cover these requirements."
    },
    {
      "function_name": "rbac_limit_impersonate_permission",
      "service": "rbac",
      "kubernetes_api": "kubectl get clusterrolebindings,rolebindings --all-namespaces -o json",
      "rationale": "To ensure that impersonate permissions are not granted unless strictly required",
      "compliance_id": "5.1.8",
      "compliance_title": "Limit use of the Bind, Impersonate and Escalate permissions in the Kubernetes cluster",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly address the compliance requirement of limiting the use of Bind, Impersonate, and Escalate permissions. New functions are suggested to cover these requirements."
    },
    {
      "function_name": "rbac_limit_escalate_permission",
      "service": "rbac",
      "kubernetes_api": "kubectl get clusterrolebindings,rolebindings --all-namespaces -o json",
      "rationale": "To ensure that escalate permissions are not granted unless strictly required",
      "compliance_id": "5.1.8",
      "compliance_title": "Limit use of the Bind, Impersonate and Escalate permissions in the Kubernetes cluster",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly address the compliance requirement of limiting the use of Bind, Impersonate, and Escalate permissions. New functions are suggested to cover these requirements."
    },
    {
      "function_name": "core_minimize_hostpath_pv_creation",
      "service": "core",
      "kubernetes_api": "kubectl get pv -o jsonpath='{.items[?(@.spec.hostPath)].metadata.name}'",
      "rationale": "To prevent privilege escalation via the creation of hostPath volumes",
      "compliance_id": "5.1.9",
      "compliance_title": "Minimize access to create persistent volumes",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing function 'rbac_minimize_pv_creation_access' partially covers the compliance requirement by minimizing access to create persistent volumes. However, it does not specifically address the risk of privilege escalation via the creation of hostPath volumes. Therefore, a new function 'core_minimize_hostpath_pv_creation' is suggested to fill this gap."
    },
    {
      "function_name": "rbac_minimize_validatingwebhookconfigurations_access",
      "service": "apiserver",
      "kubernetes_api": "kubectl get validatingwebhookconfigurations --all-namespaces -o json",
      "rationale": "To ensure that access to validatingwebhookconfigurations is minimized",
      "compliance_id": "5.1.12",
      "compliance_title": "Minimize access to webhook configuration objects",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing function 'rbac_minimize_webhook_config_access' partially covers the compliance requirement. However, it does not specifically address access to 'validatingwebhookconfigurations' and 'mutatingwebhookconfigurations'. Therefore, two new functions are suggested to cover these aspects."
    },
    {
      "function_name": "rbac_minimize_mutatingwebhookconfigurations_access",
      "service": "apiserver",
      "kubernetes_api": "kubectl get mutatingwebhookconfigurations --all-namespaces -o json",
      "rationale": "To ensure that access to mutatingwebhookconfigurations is minimized",
      "compliance_id": "5.1.12",
      "compliance_title": "Minimize access to webhook configuration objects",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing function 'rbac_minimize_webhook_config_access' partially covers the compliance requirement. However, it does not specifically address access to 'validatingwebhookconfigurations' and 'mutatingwebhookconfigurations'. Therefore, two new functions are suggested to cover these aspects."
    },
    {
      "function_name": "apiserver_policy_control_mechanism_check",
      "service": "apiserver",
      "kubernetes_api": "kubectl get pods -n kube-system",
      "rationale": "To ensure that at least one policy control mechanism is active in the cluster",
      "compliance_id": "5.2.1",
      "compliance_title": "Ensure that the cluster has at least one active policy control mechanism in place",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing functions mapped are related to policy control mechanisms in the apiserver. However, none of them directly checks if at least one policy control mechanism is active, hence the need for a new function."
    },
    {
      "function_name": "core_minimize_admission_hostpath_volumes",
      "service": "core",
      "kubernetes_api": "kubectl get pods --all-namespaces -o jsonpath='{range .items[*]}{.metadata.name}{\"\\t\"}{.spec.volumes[*].hostPath.path}{\"\\n\"}{end}'",
      "rationale": "This function is needed to check if any pod is using hostPath volumes, which is not recommended for security reasons.",
      "compliance_id": "5.2.12",
      "compliance_title": "Minimize the admission of HostPath volumes",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly address the compliance requirement of minimizing the admission of HostPath volumes. A new function is proposed to fill this gap."
    },
    {
      "function_name": "cni_network_policy_support_check",
      "service": "core",
      "kubernetes_api": "kubectl get pods -n kube-system",
      "rationale": "This function is needed to check if the CNI in use supports Network Policies",
      "compliance_id": "5.3.1",
      "compliance_title": "Ensure that the CNI in use supports Network Policies",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly relate to the compliance requirement of ensuring the CNI in use supports Network Policies. A new function, cni_network_policy_support_check, is suggested to fill this gap."
    },
    {
      "function_name": "core_namespace_network_policy_check",
      "service": "core",
      "kubernetes_api": "kubectl get networkpolicies --all-namespaces",
      "rationale": "This function is needed to ensure that all namespaces have network policies defined, as per compliance requirement 5.3.2",
      "compliance_id": "5.3.2",
      "compliance_title": "Ensure that all Namespaces have Network Policies defined",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly relate to checking for network policies in all namespaces. A new function 'core_namespace_network_policy_check' is suggested to fill this gap."
    },
    {
      "function_name": "core_secrets_as_files",
      "service": "core",
      "kubernetes_api": "kubectl get pods -o jsonpath='{.items[*].spec.volumes[*].secret}'",
      "rationale": "This function is needed to check if secrets are being used as files, which is the preferred method over environment variables.",
      "compliance_id": "5.4.1",
      "compliance_title": "Prefer using secrets as files over secrets as environment variables",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing function 'core_no_secrets_envs' can be used to check if secrets are being used as environment variables. However, there is no existing function to check if secrets are being used as files. Therefore, a new function 'core_secrets_as_files' is suggested."
    },
    {
      "function_name": "external_secret_storage_check",
      "service": "core",
      "kubernetes_api": "kubectl get secrets -n kube-system",
      "rationale": "To ensure that secrets are not being stored directly in Kubernetes but in an external secrets management system",
      "compliance_id": "5.4.2",
      "compliance_title": "Consider external secret storage",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly address the requirements of this compliance item. New functions are suggested to cover the requirements."
    },
    {
      "function_name": "external_secret_storage_authentication_check",
      "service": "core",
      "kubernetes_api": "kubectl get secrets -n kube-system",
      "rationale": "To ensure that the external secrets management system requires authentication to access secrets",
      "compliance_id": "5.4.2",
      "compliance_title": "Consider external secret storage",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly address the requirements of this compliance item. New functions are suggested to cover the requirements."
    },
    {
      "function_name": "external_secret_storage_audit_check",
      "service": "core",
      "kubernetes_api": "kubectl get secrets -n kube-system",
      "rationale": "To ensure that the external secrets management system has auditing of access to and use of secrets",
      "compliance_id": "5.4.2",
      "compliance_title": "Consider external secret storage",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly address the requirements of this compliance item. New functions are suggested to cover the requirements."
    },
    {
      "function_name": "external_secret_storage_encryption_check",
      "service": "core",
      "kubernetes_api": "kubectl get secrets -n kube-system",
      "rationale": "To ensure that the external secrets management system encrypts secrets",
      "compliance_id": "5.4.2",
      "compliance_title": "Consider external secret storage",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly address the requirements of this compliance item. New functions are suggested to cover the requirements."
    },
    {
      "function_name": "external_secret_storage_rotation_check",
      "service": "core",
      "kubernetes_api": "kubectl get secrets -n kube-system",
      "rationale": "To ensure that the external secrets management system supports easy rotation of secrets",
      "compliance_id": "5.4.2",
      "compliance_title": "Consider external secret storage",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly address the requirements of this compliance item. New functions are suggested to cover the requirements."
    },
    {
      "function_name": "apiserver_image_policy_webhook_config",
      "service": "apiserver",
      "kubernetes_api": "kubectl get apiservices v1.admissionregistration.k8s.io -o jsonpath='{.spec.service.name}'",
      "rationale": "To ensure that the ImagePolicyWebhook admission controller is configured for image provenance",
      "compliance_id": "5.5.1",
      "compliance_title": "Configure Image Provenance using ImagePolicyWebhook admission controller",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly relate to the configuration of ImagePolicyWebhook admission controller for image provenance. A new function is suggested to check the configuration of this admission controller."
    },
    {
      "function_name": "namespace_isolation_check",
      "service": "core",
      "kubernetes_api": "kubectl get namespaces",
      "rationale": "To ensure that resources are properly isolated using namespaces",
      "compliance_id": "5.7.1",
      "compliance_title": "Create administrative boundaries between resources using namespaces",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly address the requirement of creating administrative boundaries between resources using namespaces. A new function, namespace_isolation_check, is suggested to fill this gap."
    },
    {
      "function_name": "core_security_context_check",
      "service": "core",
      "kubernetes_api": "kubectl get pods --all-namespaces -o jsonpath='{range .items[*]}{.metadata.name}{\"\\t\"}{.spec.securityContext}{\"\\n\"}'",
      "rationale": "To ensure that all pods have a security context applied",
      "compliance_id": "5.7.3",
      "compliance_title": "Apply Security Context to Your Pods and Containers",
      "coverage_assessment": "partial",
      "mapping_notes": "The existing functions provide partial coverage for the compliance item. They cover various aspects of the security context such as privilege escalation, capabilities, and host settings. However, there is no function that checks if a security context is applied to all pods and containers, hence the need for a new function."
    },
    {
      "function_name": "default_namespace_usage_check",
      "service": "core",
      "kubernetes_api": "kubectl get all --all-namespaces",
      "rationale": "This function is needed to check if any resources are being used in the default namespace, which is against the compliance requirement.",
      "compliance_id": "5.7.4",
      "compliance_title": "The default namespace should not be used",
      "coverage_assessment": "none",
      "mapping_notes": "No existing functions in the database directly address the compliance requirement of not using the default namespace. A new function 'default_namespace_usage_check' is suggested to fill this gap."
    }
  ]
}