{
  "metadata": {
    "generated_at": "2025-08-17T00:54:47.681516",
    "compliance_framework": "CIS_KUBERNETES_BENCHMARK_V1.7.1_PDF.json",
    "kubernetes_database_functions": 83,
    "processing_stats": {
      "total_items": 131,
      "processed": 130,
      "skipped_manual": 1,
      "mapped_complete": 72,
      "mapped_partial": 23,
      "mapped_none": 35,
      "new_functions_suggested": 69
    }
  },
  "mapping_results": [
    {
      "compliance_id": "1.1.1",
      "title": "Ensure that the API server pod specification file permissions are set to 644 or more restrictive",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "apiserver_pod_spec_file_permissions",
          "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l <file_path>",
          "service": "apiserver",
          "rationale": "This function is needed to check the permissions of the API server pod specification file and ensure they are set to 644 or more restrictive."
        }
      ],
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'apiserver_pod_spec_file_permissions' is suggested to check the permissions of the API server pod specification file."
    },
    {
      "compliance_id": "1.1.2",
      "title": "Ensure that the API server pod specification file ownership is set to root:root",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "apiserver_pod_spec_file_ownership",
          "kubernetes_api": "kubectl exec -it <pod_name> -- chown root:root <file_path>",
          "service": "apiserver",
          "rationale": "This function is needed to ensure that the API server pod specification file ownership is set to root:root, which is a requirement for compliance item 1.1.2"
        }
      ],
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'apiserver_pod_spec_file_ownership' is suggested to fill this gap."
    },
    {
      "compliance_id": "1.1.3",
      "title": "Ensure that the controller manager pod specification file permissions are set to 644 or more restrictive",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "controllermanager_pod_spec_file_permissions",
          "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l <file_path>",
          "service": "controllermanager",
          "rationale": "This function is needed to check the permissions of the controller manager pod specification file and ensure they are set to 644 or more restrictive."
        }
      ],
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'controllermanager_pod_spec_file_permissions' is suggested to check the permissions of the controller manager pod specification file."
    },
    {
      "compliance_id": "1.1.4",
      "title": "Ensure that the controller manager pod specification file ownership is set to root:root",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "controllermanager_pod_spec_file_ownership",
          "kubernetes_api": "kubectl exec -it <pod_name> -- chown root:root <file_path>",
          "service": "controllermanager",
          "rationale": "This function is needed to ensure that the controller manager pod specification file ownership is set to root:root, which is a security best practice to prevent unauthorized modifications."
        }
      ],
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'controllermanager_pod_spec_file_ownership' is suggested to check and set the ownership of the controller manager pod specification file to root:root."
    },
    {
      "compliance_id": "1.1.5",
      "title": "Ensure that the scheduler pod specification file permissions are set to 644 or more restrictive",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "scheduler_pod_spec_file_permissions",
          "kubernetes_api": "kubectl get pods -n kube-system",
          "service": "scheduler",
          "rationale": "To ensure that the scheduler pod specification file permissions are set to 644 or more restrictive"
        }
      ],
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'scheduler_pod_spec_file_permissions' is suggested to check the permissions of the scheduler pod specification file."
    },
    {
      "compliance_id": "1.1.6",
      "title": "Ensure that the scheduler pod specification file ownership is set to root:root",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "scheduler_pod_spec_file_ownership",
          "kubernetes_api": "kubectl exec -it <pod_name> -- chown root:root <scheduler_pod_spec_file>",
          "service": "scheduler",
          "rationale": "This function is needed to ensure that the scheduler pod specification file ownership is set to root:root, which is a security best practice to prevent unauthorized modifications."
        }
      ],
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'scheduler_pod_spec_file_ownership' is suggested."
    },
    {
      "compliance_id": "1.1.7",
      "title": "Ensure that the etcd pod specification file permissions are set to 644 or more restrictive",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "etcd_pod_spec_file_permissions",
          "kubernetes_api": "kubectl exec -it etcd-master -- ls -l /etc/kubernetes/manifests/etcd.yaml",
          "service": "etcd",
          "rationale": "This function is needed to check the permissions of the etcd pod specification file and ensure they are set to 644 or more restrictive"
        }
      ],
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'etcd_pod_spec_file_permissions' is suggested to check the permissions of the etcd pod specification file."
    },
    {
      "compliance_id": "1.1.8",
      "title": "Ensure that the etcd pod specification file ownership is set to root:root",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "etcd_pod_spec_file_ownership",
          "kubernetes_api": "kubectl exec -it etcd-master -- chown root:root /etc/kubernetes/manifests/etcd.yaml",
          "service": "etcd",
          "rationale": "This function is needed to ensure that the etcd pod specification file ownership is set to root:root, which is a security best practice to prevent unauthorized modifications."
        }
      ],
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'etcd_pod_spec_file_ownership' is suggested to check and set the ownership of the etcd pod specification file to root:root."
    },
    {
      "compliance_id": "1.1.9",
      "title": "Ensure that the Container Network Interface file permissions are set to 644 or more restrictive",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "container_network_interface_file_permissions",
          "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/cni/net.d/",
          "service": "core",
          "rationale": "This function is needed to check the permissions of the Container Network Interface files and ensure they are set to 644 or more restrictive"
        }
      ],
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'container_network_interface_file_permissions' is suggested to check the permissions of the Container Network Interface files."
    },
    {
      "compliance_id": "1.1.10",
      "title": "Ensure that the Container Network Interface file ownership is set to root:root",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "container_network_interface_file_ownership",
          "kubernetes_api": "kubectl exec -it <pod_name> -- chown root:root <cni_file_path>",
          "service": "core",
          "rationale": "This function is needed to ensure that the Container Network Interface file ownership is set to root:root, which is a security best practice to prevent unauthorized modifications."
        }
      ],
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'container_network_interface_file_ownership' is suggested to check and set the ownership of the Container Network Interface files to root:root."
    },
    {
      "compliance_id": "1.1.11",
      "title": "Ensure that the etcd data directory permissions are set to 700 or more restrictive",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "etcd_data_directory_permissions_check",
          "kubernetes_api": "kubectl exec etcd-master -n kube-system -- ls -l /var/lib/etcd",
          "service": "etcd",
          "rationale": "This function is needed to check the permissions of the etcd data directory and ensure they are set to 700 or more restrictive"
        }
      ],
      "mapping_notes": "No existing functions in the database directly address the compliance requirement of checking etcd data directory permissions. A new function 'etcd_data_directory_permissions_check' is suggested to fill this gap."
    },
    {
      "compliance_id": "1.1.12",
      "title": "Ensure that the etcd data directory ownership is set to etcd:etcd",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "etcd_data_directory_ownership_check",
          "kubernetes_api": "kubectl exec -it etcd-master -- chown -R etcd:etcd /var/lib/etcd",
          "service": "etcd",
          "rationale": "This function is needed to ensure that the etcd data directory ownership is set to etcd:etcd, which is a critical security measure to protect the data stored in etcd."
        }
      ],
      "mapping_notes": "No existing functions in the database directly address the requirement of checking the ownership of the etcd data directory. Therefore, a new function 'etcd_data_directory_ownership_check' is suggested."
    },
    {
      "compliance_id": "1.1.13",
      "title": "Ensure that the admin.conf file permissions are set to 644",
      "existing_functions_mapped": [
        "kubelet_conf_file_permissions"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "admin_conf_file_permissions",
          "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/admin.conf",
          "service": "apiserver",
          "rationale": "To ensure that the admin.conf file permissions are set to 644"
        }
      ],
      "mapping_notes": "The existing function 'kubelet_conf_file_permissions' partially covers the compliance requirement. However, it does not specifically check the permissions of the admin.conf file. Therefore, a new function 'admin_conf_file_permissions' is suggested."
    },
    {
      "compliance_id": "1.1.14",
      "title": "Ensure that the admin.conf file ownership is set to root:root",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "apiserver_admin_conf_file_ownership",
          "kubernetes_api": "ls -l /etc/kubernetes/admin.conf",
          "service": "apiserver",
          "rationale": "To ensure that the admin.conf file ownership is set to root:root, a new function is needed that checks the ownership of this file."
        }
      ],
      "mapping_notes": "No existing function in the database checks the ownership of the admin.conf file. A new function 'apiserver_admin_conf_file_ownership' is suggested to fill this gap."
    },
    {
      "compliance_id": "1.1.15",
      "title": "Ensure that the scheduler.conf file permissions are set to 644 or more restrictive",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "scheduler_conf_file_permissions",
          "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/scheduler.conf",
          "service": "scheduler",
          "rationale": "This function is needed to check the permissions of the scheduler.conf file and ensure they are set to 644 or more restrictive."
        }
      ],
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'scheduler_conf_file_permissions' is suggested to check the permissions of the scheduler.conf file."
    },
    {
      "compliance_id": "1.1.16",
      "title": "Ensure that the scheduler.conf file ownership is set to root:root",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "scheduler_conf_file_ownership",
          "kubernetes_api": "kubectl exec -it <pod_name> -n kube-system -- ls -l /etc/kubernetes/scheduler.conf",
          "service": "scheduler",
          "rationale": "This function is needed to ensure that the scheduler.conf file ownership is set to root:root, which is a critical security measure to prevent unauthorized access or modifications."
        }
      ],
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'scheduler_conf_file_ownership' is suggested to check the ownership of the scheduler.conf file."
    },
    {
      "compliance_id": "1.1.17",
      "title": "Ensure that the controller-manager.conf file permissions are set to 644 or more restrictive",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "controllermanager_conf_file_permissions",
          "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/controller-manager.conf",
          "service": "controllermanager",
          "rationale": "This function is needed to check the permissions of the controller-manager.conf file and ensure they are set to 644 or more restrictive."
        }
      ],
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'controllermanager_conf_file_permissions' is suggested to check the permissions of the controller-manager.conf file."
    },
    {
      "compliance_id": "1.1.18",
      "title": "Ensure that the controller-manager.conf file ownership is set to root:root",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "controllermanager_conf_file_ownership",
          "kubernetes_api": "kubectl exec -it <pod_name> -n kube-system -- ls -l /etc/kubernetes/controller-manager.conf",
          "service": "controllermanager",
          "rationale": "This function is needed to ensure that the controller-manager.conf file ownership is set to root:root, which is a critical security measure to prevent unauthorized access or modifications."
        }
      ],
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'controllermanager_conf_file_ownership' is suggested to check the ownership of the controller-manager.conf file."
    },
    {
      "compliance_id": "1.1.19",
      "title": "Ensure that the Kubernetes PKI directory and file ownership is set to root:root",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "kubernetes_pki_directory_file_ownership_check",
          "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/pki/",
          "service": "apiserver",
          "rationale": "This function is needed to ensure that the Kubernetes PKI directory and file ownership is set to root:root, which is a critical security measure to prevent unauthorized access or modifications."
        }
      ],
      "mapping_notes": "No existing functions in the database directly address the compliance requirement of ensuring the Kubernetes PKI directory and file ownership is set to root:root. A new function 'kubernetes_pki_directory_file_ownership_check' is suggested to fill this gap."
    },
    {
      "compliance_id": "1.1.20",
      "title": "Ensure that the Kubernetes PKI certificate file permissions are set to 600 or more restrictive",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "apiserver_pki_cert_file_permissions",
          "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/pki/",
          "service": "apiserver",
          "rationale": "To ensure that the Kubernetes PKI certificate files have permissions of 600 or more restrictive"
        }
      ],
      "mapping_notes": "No existing functions in the database directly address the compliance requirement of ensuring that the Kubernetes PKI certificate file permissions are set to 600 or more restrictive. A new function 'apiserver_pki_cert_file_permissions' is suggested to fill this gap."
    },
    {
      "compliance_id": "1.1.21",
      "title": "Ensure that the Kubernetes PKI key file permissions are set to 600",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "kubernetes_pki_key_file_permissions_check",
          "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/pki/",
          "service": "core",
          "rationale": "This function is needed to ensure that the Kubernetes PKI key files have permissions of 600."
        }
      ],
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'kubernetes_pki_key_file_permissions_check' is suggested to check the permissions of Kubernetes PKI key files."
    },
    {
      "compliance_id": "1.2.1",
      "title": "Ensure that the --anonymous-auth argument is set to false",
      "existing_functions_mapped": [
        "apiserver_anonymous_requests",
        "kubelet_disable_anonymous_auth"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing functions 'apiserver_anonymous_requests' and 'kubelet_disable_anonymous_auth' adequately cover the compliance requirement of disabling anonymous requests to the API server."
    },
    {
      "compliance_id": "1.2.2",
      "title": "Ensure that the --token-auth-file parameter is not set",
      "existing_functions_mapped": [
        "apiserver_no_token_auth_file"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_no_token_auth_file' directly addresses the compliance requirement of ensuring that the --token-auth-file parameter is not set."
    },
    {
      "compliance_id": "1.2.3",
      "title": "Ensure that the DenyServiceExternalIPs admission controller is enabled",
      "existing_functions_mapped": [
        "apiserver_deny_service_external_ips"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_deny_service_external_ips' directly addresses the compliance requirement of ensuring that the DenyServiceExternalIPs admission controller is enabled."
    },
    {
      "compliance_id": "1.2.4",
      "title": "Ensure that the --kubelet-client-certificate and --kubelet- client-key arguments are set as appropriate",
      "existing_functions_mapped": [
        "apiserver_kubelet_tls_auth",
        "kubelet_tls_cert_and_key"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing functions 'apiserver_kubelet_tls_auth' and 'kubelet_tls_cert_and_key' cover the requirement of setting the kubelet client certificate and key arguments as they deal with the TLS authentication between the API server and the kubelet, and the presence of the TLS certificate and key in the kubelet respectively."
    },
    {
      "compliance_id": "1.2.5",
      "title": "Ensure that the --kubelet-certificate-authority argument is set as appropriate",
      "existing_functions_mapped": [
        "apiserver_kubelet_cert_auth"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_kubelet_cert_auth' directly addresses the requirement of verifying the kubelet's certificate before establishing a connection, which aligns with the compliance item."
    },
    {
      "compliance_id": "1.2.6",
      "title": "Ensure that the --authorization-mode argument is not set to AlwaysAllow",
      "existing_functions_mapped": [
        "apiserver_auth_mode_not_always_allow"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_auth_mode_not_always_allow' directly addresses the compliance requirement of ensuring that the --authorization-mode argument is not set to AlwaysAllow."
    },
    {
      "compliance_id": "1.2.7",
      "title": "Ensure that the --authorization-mode argument includes Node",
      "existing_functions_mapped": [
        "apiserver_auth_mode_include_node"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_auth_mode_include_node' directly addresses the compliance requirement of ensuring that the --authorization-mode argument includes Node."
    },
    {
      "compliance_id": "1.2.8",
      "title": "Ensure that the --authorization-mode argument includes RBAC",
      "existing_functions_mapped": [
        "apiserver_auth_mode_include_rbac"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_auth_mode_include_rbac' directly addresses the compliance requirement of ensuring that the --authorization-mode argument includes RBAC."
    },
    {
      "compliance_id": "1.2.9",
      "title": "Ensure that the admission control plugin EventRateLimit is set",
      "existing_functions_mapped": [
        "apiserver_event_rate_limit"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_event_rate_limit' directly addresses the compliance requirement of setting the EventRateLimit admission control plugin."
    },
    {
      "compliance_id": "1.2.10",
      "title": "Ensure that the admission control plugin AlwaysAdmit is not set",
      "existing_functions_mapped": [
        "apiserver_no_always_admit_plugin"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_no_always_admit_plugin' directly addresses the compliance requirement of ensuring that the AlwaysAdmit admission control plugin is not set."
    },
    {
      "compliance_id": "1.2.11",
      "title": "Ensure that the admission control plugin AlwaysPullImages is set",
      "existing_functions_mapped": [
        "apiserver_always_pull_images_plugin"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_always_pull_images_plugin' directly addresses the compliance requirement of ensuring the AlwaysPullImages admission control plugin is set."
    },
    {
      "compliance_id": "1.2.12",
      "title": "Ensure that the admission control plugin SecurityContextDeny is set if PodSecurityPolicy is not used",
      "existing_functions_mapped": [
        "apiserver_security_context_deny_plugin"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_security_context_deny_plugin' directly addresses the compliance requirement of ensuring the SecurityContextDeny admission control plugin is set."
    },
    {
      "compliance_id": "1.2.13",
      "title": "Ensure that the admission control plugin ServiceAccount is set",
      "existing_functions_mapped": [
        "apiserver_service_account_plugin",
        "apiserver_service_account_key_file_set",
        "apiserver_service_account_lookup_true"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing functions 'apiserver_service_account_plugin', 'apiserver_service_account_key_file_set', and 'apiserver_service_account_lookup_true' collectively ensure that the admission control plugin ServiceAccount is set, its key file is set, and the lookup is true respectively. Therefore, the coverage is assessed as complete."
    },
    {
      "compliance_id": "1.2.14",
      "title": "Ensure that the admission control plugin NamespaceLifecycle is set",
      "existing_functions_mapped": [
        "apiserver_namespace_lifecycle_plugin"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_namespace_lifecycle_plugin' directly addresses the compliance requirement of setting the NamespaceLifecycle admission control plugin."
    },
    {
      "compliance_id": "1.2.15",
      "title": "Ensure that the admission control plugin NodeRestriction is set",
      "existing_functions_mapped": [
        "apiserver_node_restriction_plugin"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_node_restriction_plugin' directly addresses the compliance requirement of setting the NodeRestriction admission control plugin."
    },
    {
      "compliance_id": "1.2.16",
      "title": "Ensure that the --secure-port argument is not set to 0 - NoteThis recommendation is obsolete and will be deleted per the consensus process.",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [],
      "mapping_notes": "No existing functions map to this compliance item as it is obsolete and will be deleted per the consensus process. Therefore, no new functions are suggested."
    },
    {
      "compliance_id": "1.2.17",
      "title": "Ensure that the --profiling argument is set to false",
      "existing_functions_mapped": [
        "apiserver_disable_profiling",
        "controllermanager_disable_profiling",
        "scheduler_profiling"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing functions 'apiserver_disable_profiling', 'controllermanager_disable_profiling', and 'scheduler_profiling' cover the requirement of ensuring that the --profiling argument is set to false for the apiserver, controller manager, and scheduler respectively."
    },
    {
      "compliance_id": "1.2.18",
      "title": "Ensure that the --audit-log-path argument is set",
      "existing_functions_mapped": [
        "apiserver_audit_log_path_set"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_audit_log_path_set' directly addresses the compliance requirement of setting the --audit-log-path argument."
    },
    {
      "compliance_id": "1.2.19",
      "title": "Ensure that the --audit-log-maxage argument is set to 30 or as appropriate",
      "existing_functions_mapped": [
        "apiserver_audit_log_maxage_set"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_audit_log_maxage_set' directly addresses the compliance requirement of setting the --audit-log-maxage argument to 30 or as appropriate."
    },
    {
      "compliance_id": "1.2.20",
      "title": "Ensure that the --audit-log-maxbackup argument is set to 10 or as appropriate",
      "existing_functions_mapped": [
        "apiserver_audit_log_maxbackup_set"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_audit_log_maxbackup_set' directly addresses the compliance requirement of setting the --audit-log-maxbackup argument to 10 or as appropriate."
    },
    {
      "compliance_id": "1.2.21",
      "title": "Ensure that the --audit-log-maxsize argument is set to 100 or as appropriate",
      "existing_functions_mapped": [
        "apiserver_audit_log_maxsize_set"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_audit_log_maxsize_set' directly addresses the compliance requirement of setting the --audit-log-maxsize argument to 100 or as appropriate."
    },
    {
      "compliance_id": "1.2.22",
      "title": "Ensure that the --request-timeout argument is set as appropriate",
      "existing_functions_mapped": [
        "apiserver_request_timeout_set"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_request_timeout_set' directly addresses the compliance requirement of setting the --request-timeout argument appropriately."
    },
    {
      "compliance_id": "1.2.23",
      "title": "Ensure that the --service-account-lookup argument is set to true",
      "existing_functions_mapped": [
        "apiserver_service_account_lookup_true"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_service_account_lookup_true' directly addresses the compliance requirement of ensuring that the --service-account-lookup argument is set to true."
    },
    {
      "compliance_id": "1.2.24",
      "title": "Ensure that the --service-account-key-file argument is set as appropriate",
      "existing_functions_mapped": [
        "apiserver_service_account_key_file_set"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_service_account_key_file_set' directly addresses the compliance requirement of ensuring the --service-account-key-file argument is set appropriately in the apiserver."
    },
    {
      "compliance_id": "1.2.25",
      "title": "Ensure that the --etcd-certfile and --etcd-keyfile arguments are set as appropriate",
      "existing_functions_mapped": [
        "apiserver_etcd_tls_config",
        "etcd_tls_encryption"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "etcd_certfile_and_keyfile_set",
          "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[?(@.metadata.labels.component==\"etcd\")].spec.containers[0].command}'",
          "service": "etcd",
          "rationale": "To ensure that the --etcd-certfile and --etcd-keyfile arguments are set as appropriate, a specific function is needed to check these arguments in the etcd configuration."
        }
      ],
      "mapping_notes": "The existing functions 'apiserver_etcd_tls_config' and 'etcd_tls_encryption' partially cover the compliance requirement by ensuring that etcd is configured to use TLS encryption. However, they do not specifically check for the --etcd-certfile and --etcd-keyfile arguments. Therefore, a new function 'etcd_certfile_and_keyfile_set' is suggested to fill this gap."
    },
    {
      "compliance_id": "1.2.26",
      "title": "Ensure that the --tls-cert-file and --tls-private-key-file arguments are set as appropriate",
      "existing_functions_mapped": [
        "apiserver_tls_config",
        "kubelet_tls_cert_and_key"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "apiserver_tls_cert_file_set",
          "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[*].spec.containers[*].command}' | grep -- '--tls-cert-file'",
          "service": "apiserver",
          "rationale": "To ensure that the --tls-cert-file argument is set as appropriate"
        },
        {
          "name": "apiserver_tls_private_key_file_set",
          "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[*].spec.containers[*].command}' | grep -- '--tls-private-key-file'",
          "service": "apiserver",
          "rationale": "To ensure that the --tls-private-key-file argument is set as appropriate"
        }
      ],
      "mapping_notes": "The existing functions 'apiserver_tls_config' and 'kubelet_tls_cert_and_key' partially cover the compliance requirement. However, they do not specifically check for the --tls-cert-file and --tls-private-key-file arguments. Therefore, two new functions 'apiserver_tls_cert_file_set' and 'apiserver_tls_private_key_file_set' are suggested to fill this gap."
    },
    {
      "compliance_id": "1.2.27",
      "title": "Ensure that the --client-ca-file argument is set as appropriate",
      "existing_functions_mapped": [
        "apiserver_client_ca_file_set"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_client_ca_file_set' directly addresses the compliance requirement of setting the --client-ca-file argument appropriately."
    },
    {
      "compliance_id": "1.2.28",
      "title": "Ensure that the --etcd-cafile argument is set as appropriate",
      "existing_functions_mapped": [
        "apiserver_etcd_cafile_set"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_etcd_cafile_set' directly addresses the compliance requirement of ensuring the --etcd-cafile argument is set as appropriate."
    },
    {
      "compliance_id": "1.2.29",
      "title": "Ensure that the --encryption-provider-config argument is set as appropriate",
      "existing_functions_mapped": [
        "apiserver_encryption_provider_config_set"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_encryption_provider_config_set' directly addresses the compliance requirement of setting the --encryption-provider-config argument as appropriate."
    },
    {
      "compliance_id": "1.2.30",
      "title": "Ensure that encryption providers are appropriately configured",
      "existing_functions_mapped": [
        "apiserver_encryption_provider_config_set",
        "apiserver_etcd_cafile_set",
        "apiserver_etcd_tls_config",
        "etcd_tls_encryption"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing functions cover the configuration of encryption providers for both the API server and etcd, including TLS encryption and certificate configuration."
    },
    {
      "compliance_id": "1.2.31",
      "title": "Ensure that the API Server only makes use of Strong Cryptographic Ciphers",
      "existing_functions_mapped": [
        "apiserver_strong_ciphers_only"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_strong_ciphers_only' directly addresses the requirement of the compliance item. It ensures that the API server is configured to only use strong cryptographic ciphers."
    },
    {
      "compliance_id": "1.3.1",
      "title": "Ensure that the --terminated-pod-gc-threshold argument is set as appropriate",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "controllermanager_terminated_pod_gc_threshold_set",
          "kubernetes_api": "kubectl get pods -n kube-system",
          "service": "controllermanager",
          "rationale": "This function is needed to ensure that the garbage collector is activated on pod termination as appropriate, which is a requirement of compliance item 1.3.1."
        }
      ],
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'controllermanager_terminated_pod_gc_threshold_set' is suggested to check if the --terminated-pod-gc-threshold argument is set as appropriate."
    },
    {
      "compliance_id": "1.3.2",
      "title": "Ensure that the --profiling argument is set to false",
      "existing_functions_mapped": [
        "apiserver_disable_profiling",
        "controllermanager_disable_profiling"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing functions 'apiserver_disable_profiling' and 'controllermanager_disable_profiling' directly address the compliance requirement of ensuring that the --profiling argument is set to false."
    },
    {
      "compliance_id": "1.3.3",
      "title": "Ensure that the --use-service-account-credentials argument is set to true",
      "existing_functions_mapped": [
        "controllermanager_service_account_credentials"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'controllermanager_service_account_credentials' directly checks if the --use-service-account-credentials argument is set to true in the controller manager, which satisfies the compliance requirement completely."
    },
    {
      "compliance_id": "1.3.4",
      "title": "Ensure that the --service-account-private-key-file argument is set as appropriate",
      "existing_functions_mapped": [
        "controllermanager_service_account_private_key_file"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'controllermanager_service_account_private_key_file' directly addresses the compliance requirement of setting a service account private key file for service accounts on the controller manager."
    },
    {
      "compliance_id": "1.3.5",
      "title": "Ensure that the --root-ca-file argument is set as appropriate",
      "existing_functions_mapped": [
        "apiserver_client_ca_file_set",
        "controllermanager_root_ca_file_set",
        "kubelet_client_ca_file_set"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "apiserver_root_ca_file_set",
          "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{range .items[*]}{.spec.containers[*].command}{\"\\n\"}{end}' | grep kube-apiserver | grep -- --root-ca-file",
          "service": "apiserver",
          "rationale": "To ensure that the --root-ca-file argument is set as appropriate in the API server"
        }
      ],
      "mapping_notes": "The existing functions check if the --client-ca-file argument is set for the API server, controller manager, and kubelet, which is related but not exactly the same as checking the --root-ca-file argument. Therefore, a new function is needed to specifically check the --root-ca-file argument in the API server."
    },
    {
      "compliance_id": "1.3.6",
      "title": "Ensure that the RotateKubeletServerCertificate argument is set to true",
      "existing_functions_mapped": [
        "controllermanager_rotate_kubelet_server_cert"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'controllermanager_rotate_kubelet_server_cert' directly addresses the compliance requirement of ensuring that the RotateKubeletServerCertificate argument is set to true."
    },
    {
      "compliance_id": "1.3.7",
      "title": "Ensure that the --bind-address argument is set to 127.0.0.1",
      "existing_functions_mapped": [
        "controllermanager_bind_address"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'controllermanager_bind_address' directly checks the bind address of the Controller Manager service, which satisfies the compliance requirement."
    },
    {
      "compliance_id": "1.4.1",
      "title": "Ensure that the --profiling argument is set to false",
      "existing_functions_mapped": [
        "apiserver_disable_profiling",
        "controllermanager_disable_profiling"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing functions 'apiserver_disable_profiling' and 'controllermanager_disable_profiling' directly address the compliance requirement of ensuring that the --profiling argument is set to false."
    },
    {
      "compliance_id": "1.4.2",
      "title": "Ensure that the --bind-address argument is set to 127.0.0.1",
      "existing_functions_mapped": [
        "scheduler_bind_address"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'scheduler_bind_address' checks the bind address of the scheduler, which aligns with the compliance requirement."
    },
    {
      "compliance_id": "2.1",
      "title": "Ensure that the --cert-file and --key-file arguments are set as appropriate",
      "existing_functions_mapped": [
        "apiserver_etcd_tls_config",
        "etcd_tls_encryption"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "etcd_cert_file_and_key_file_set",
          "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[*].spec.containers[*].command}'",
          "service": "etcd",
          "rationale": "To ensure that the --cert-file and --key-file arguments are set as appropriate for etcd service"
        }
      ],
      "mapping_notes": "The existing functions 'apiserver_etcd_tls_config' and 'etcd_tls_encryption' partially cover the compliance requirement. However, they do not specifically check if the --cert-file and --key-file arguments are set. Therefore, a new function 'etcd_cert_file_and_key_file_set' is suggested."
    },
    {
      "compliance_id": "2.2",
      "title": "Ensure that the --client-cert-auth argument is set to true",
      "existing_functions_mapped": [
        "etcd_client_cert_auth"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'etcd_client_cert_auth' directly addresses the compliance requirement of enabling client authentication on etcd service."
    },
    {
      "compliance_id": "2.3",
      "title": "Ensure that the --auto-tls argument is not set to true",
      "existing_functions_mapped": [
        "etcd_no_auto_tls"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "apiserver_no_auto_tls",
          "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[?(@.metadata.labels.component==\"kube-apiserver\")].spec.containers[0].command}'",
          "service": "apiserver",
          "rationale": "To ensure that the --auto-tls argument is not set to true in the apiserver"
        }
      ],
      "mapping_notes": "The existing function 'etcd_no_auto_tls' partially covers the compliance requirement. However, it only checks the etcd service. A new function 'apiserver_no_auto_tls' is needed to check the apiserver service."
    },
    {
      "compliance_id": "2.4",
      "title": "Ensure that the --peer-cert-file and --peer-key-file arguments are set as appropriate",
      "existing_functions_mapped": [
        "etcd_peer_tls_config"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "etcd_peer_cert_file_set",
          "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[*].spec.containers[*].command}' | grep -- --peer-cert-file",
          "service": "etcd",
          "rationale": "To ensure that the --peer-cert-file argument is set as appropriate"
        },
        {
          "name": "etcd_peer_key_file_set",
          "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[*].spec.containers[*].command}' | grep -- --peer-key-file",
          "service": "etcd",
          "rationale": "To ensure that the --peer-key-file argument is set as appropriate"
        }
      ],
      "mapping_notes": "The existing function 'etcd_peer_tls_config' partially covers the compliance requirement by checking the TLS configuration for etcd peers. However, it does not specifically check for the --peer-cert-file and --peer-key-file arguments. Therefore, two new functions 'etcd_peer_cert_file_set' and 'etcd_peer_key_file_set' are suggested to fill this gap."
    },
    {
      "compliance_id": "2.5",
      "title": "Ensure that the --peer-client-cert-auth argument is set to true",
      "existing_functions_mapped": [
        "etcd_peer_client_cert_auth"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'etcd_peer_client_cert_auth' directly addresses the compliance requirement of ensuring that the --peer-client-cert-auth argument is set to true for etcd."
    },
    {
      "compliance_id": "2.6",
      "title": "Ensure that the --peer-auto-tls argument is not set to true",
      "existing_functions_mapped": [
        "etcd_no_peer_auto_tls"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'etcd_no_peer_auto_tls' directly addresses the compliance requirement of ensuring that the --peer-auto-tls argument is not set to true."
    },
    {
      "compliance_id": "2.7",
      "title": "Ensure that a unique Certificate Authority is used for etcd",
      "existing_functions_mapped": [
        "apiserver_etcd_cafile_set",
        "etcd_unique_ca"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing functions 'apiserver_etcd_cafile_set' and 'etcd_unique_ca' ensure that a unique Certificate Authority is used for etcd, which satisfies the compliance requirement."
    },
    {
      "compliance_id": "3.1.1",
      "title": "Client certificate authentication should not be used for users",
      "existing_functions_mapped": [
        "apiserver_client_ca_file_set",
        "apiserver_auth_mode_include_rbac",
        "apiserver_auth_mode_not_always_allow"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "apiserver_disable_user_client_cert_auth",
          "kubernetes_api": "kubectl get --raw /api/v1/nodes | jq -r '.items[].status.addresses[] | select(.type == \"InternalIP\") .address'",
          "service": "apiserver",
          "rationale": "To ensure that client certificate authentication is not used for users, a function is needed to disable this authentication method for user accounts in the API server."
        }
      ],
      "mapping_notes": "The existing functions 'apiserver_client_ca_file_set', 'apiserver_auth_mode_include_rbac', and 'apiserver_auth_mode_not_always_allow' partially cover the compliance requirement by setting up the client certificate file and enabling RBAC. However, a new function 'apiserver_disable_user_client_cert_auth' is needed to specifically disable client certificate authentication for users."
    },
    {
      "compliance_id": "3.1.2",
      "title": "Service account token authentication should not be used for users",
      "existing_functions_mapped": [
        "apiserver_service_account_key_file_set",
        "apiserver_service_account_lookup_true",
        "apiserver_service_account_plugin",
        "rbac_minimize_service_account_token_creation"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "apiserver_disable_service_account_token_for_users",
          "kubernetes_api": "kubectl get serviceaccounts -A",
          "service": "apiserver",
          "rationale": "To ensure that service account tokens are not used for user authentication, a function is needed to check and disable this feature for all users."
        }
      ],
      "mapping_notes": "The existing functions provide partial coverage as they deal with service account configuration and minimizing token creation. However, there is no specific function to disable service account token authentication for users, hence a new function is suggested."
    },
    {
      "compliance_id": "3.1.3",
      "title": "Bootstrap token authentication should not be used for users",
      "existing_functions_mapped": [
        "apiserver_no_token_auth_file"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "apiserver_bootstrap_token_auth_check",
          "kubernetes_api": "kubectl get clusterrolebindings system:node-bootstrapper -o json",
          "service": "apiserver",
          "rationale": "To ensure bootstrap tokens are not used for general authentication"
        }
      ],
      "mapping_notes": "The existing function 'apiserver_no_token_auth_file' partially covers the compliance requirement by ensuring that token authentication is not used. However, it does not specifically check for bootstrap token authentication. Therefore, a new function 'apiserver_bootstrap_token_auth_check' is suggested to specifically check for bootstrap token authentication."
    },
    {
      "compliance_id": "3.2.1",
      "title": "Ensure that a minimal audit policy is created",
      "existing_functions_mapped": [
        "apiserver_audit_log_maxage_set",
        "apiserver_audit_log_maxbackup_set",
        "apiserver_audit_log_maxsize_set",
        "apiserver_audit_log_path_set"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "apiserver_audit_policy_file_set",
          "kubernetes_api": "kubectl get pods -n kube-system",
          "service": "apiserver",
          "rationale": "This function is needed to ensure that the --audit-policy-file flag is set, which is a requirement for enabling logging of requests made to the API server."
        }
      ],
      "mapping_notes": "The existing functions cover the settings for the audit log such as max age, max backup, max size, and log path. However, there is no function that checks if the --audit-policy-file flag is set. Therefore, a new function 'apiserver_audit_policy_file_set' is suggested."
    },
    {
      "compliance_id": "3.2.2",
      "title": "Ensure that the audit policy covers key security concerns",
      "existing_functions_mapped": [
        "apiserver_audit_log_maxage_set",
        "apiserver_audit_log_maxbackup_set",
        "apiserver_audit_log_maxsize_set",
        "apiserver_audit_log_path_set"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "apiserver_audit_policy_security_concerns_check",
          "kubernetes_api": "kubectl get auditpolicies.audit.k8s.io -n kube-system",
          "service": "apiserver",
          "rationale": "To ensure that the audit policy created for the cluster covers key security concerns"
        }
      ],
      "mapping_notes": "The existing functions cover the configuration of audit logs but do not specifically check if the audit policy covers key security concerns. A new function is suggested to fill this gap."
    },
    {
      "compliance_id": "4.1.1",
      "title": "Ensure that the kubelet service file permissions are set to 644 or more restrictive",
      "existing_functions_mapped": [
        "kubelet_service_file_permissions"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'kubelet_service_file_permissions' directly addresses the compliance requirement of ensuring that the kubelet service file permissions are set to 644 or more restrictive."
    },
    {
      "compliance_id": "4.1.2",
      "title": "Ensure that the kubelet service file ownership is set to root:root",
      "existing_functions_mapped": [
        "kubelet_service_file_ownership_root"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'kubelet_service_file_ownership_root' directly addresses the compliance requirement of ensuring that the kubelet service file ownership is set to root:root."
    },
    {
      "compliance_id": "4.1.3",
      "title": "If proxy kubeconfig file exists ensure permissions are set to 644 or more restrictive",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "proxy_kubeconfig_file_permissions",
          "kubernetes_api": "kubectl exec -it kube-proxy -- ls -l /etc/kubernetes/proxy-kubeconfig",
          "service": "kube-proxy",
          "rationale": "This function is needed to check the permissions of the proxy kubeconfig file and ensure they are set to 644 or more restrictive."
        }
      ],
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'proxy_kubeconfig_file_permissions' is suggested to check the permissions of the proxy kubeconfig file."
    },
    {
      "compliance_id": "4.1.4",
      "title": "If proxy kubeconfig file exists ensure ownership is set to root:root",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "kube_proxy_kubeconfig_file_ownership",
          "kubernetes_api": "ls -l /etc/kubernetes/proxy.conf",
          "service": "kube-proxy",
          "rationale": "To ensure the kube-proxy kubeconfig file is owned by root:root"
        }
      ],
      "mapping_notes": "No existing functions could be mapped to this compliance requirement. A new function is suggested to check the ownership of the kube-proxy kubeconfig file."
    },
    {
      "compliance_id": "4.1.5",
      "title": "Ensure that the --kubeconfig kubelet.conf file permissions are set to 644 or more restrictive",
      "existing_functions_mapped": [
        "kubelet_conf_file_permissions"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'kubelet_conf_file_permissions' directly addresses the compliance requirement of ensuring the kubelet.conf file permissions are set to 644 or more restrictive."
    },
    {
      "compliance_id": "4.1.6",
      "title": "Ensure that the --kubeconfig kubelet.conf file ownership is set to root:root",
      "existing_functions_mapped": [
        "kubelet_conf_file_ownership"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'kubelet_conf_file_ownership' directly addresses the compliance requirement of ensuring the kubelet.conf file ownership is set to root:root."
    },
    {
      "compliance_id": "4.1.7",
      "title": "Ensure that the certificate authorities file permissions are set to 600 or more restrictive",
      "existing_functions_mapped": [
        "apiserver_client_ca_file_set",
        "apiserver_etcd_cafile_set",
        "kubelet_client_ca_file_set"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "apiserver_ca_file_permissions_check",
          "kubernetes_api": "kubectl get pods -n kube-system",
          "service": "apiserver",
          "rationale": "To ensure that the certificate authorities file permissions are set to 600 or more restrictive"
        },
        {
          "name": "kubelet_ca_file_permissions_check",
          "kubernetes_api": "kubectl get pods -n kube-system",
          "service": "kubelet",
          "rationale": "To ensure that the certificate authorities file permissions are set to 600 or more restrictive"
        }
      ],
      "mapping_notes": "Existing functions only check if the CA file is set, but do not check the file permissions. New functions are needed to check the file permissions."
    },
    {
      "compliance_id": "4.1.8",
      "title": "Ensure that the client certificate authorities file ownership is set to root:root",
      "existing_functions_mapped": [
        "apiserver_client_ca_file_set",
        "kubelet_client_ca_file_set"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "check_client_ca_file_ownership",
          "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/pki",
          "service": "apiserver",
          "rationale": "To ensure that the client certificate authorities file ownership is set to root:root"
        }
      ],
      "mapping_notes": "The existing functions 'apiserver_client_ca_file_set' and 'kubelet_client_ca_file_set' partially cover the compliance requirement as they ensure the client certificate authorities file is set. However, they do not check the ownership of the file. Therefore, a new function 'check_client_ca_file_ownership' is needed to ensure the file ownership is set to root:root."
    },
    {
      "compliance_id": "4.1.9",
      "title": "If the kubelet config.yaml configuration file is being used validate permissions set to 600 or more restrictive",
      "existing_functions_mapped": [
        "kubelet_config_yaml_permissions"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'kubelet_config_yaml_permissions' directly addresses the compliance requirement of validating the permissions of the kubelet config.yaml file."
    },
    {
      "compliance_id": "4.1.10",
      "title": "If the kubelet config.yaml configuration file is being used validate file ownership is set to root:root",
      "existing_functions_mapped": [
        "kubelet_config_yaml_ownership"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'kubelet_config_yaml_ownership' directly addresses the compliance requirement of validating the file ownership of kubelet config.yaml configuration file."
    },
    {
      "compliance_id": "4.2.1",
      "title": "Ensure that the --anonymous-auth argument is set to false",
      "existing_functions_mapped": [
        "kubelet_disable_anonymous_auth"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'kubelet_disable_anonymous_auth' directly addresses the requirement of disabling anonymous requests to the Kubelet server, providing complete coverage for this compliance item."
    },
    {
      "compliance_id": "4.2.2",
      "title": "Ensure that the --authorization-mode argument is not set to AlwaysAllow",
      "existing_functions_mapped": [
        "apiserver_auth_mode_not_always_allow"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'apiserver_auth_mode_not_always_allow' directly addresses the compliance requirement of ensuring that the --authorization-mode argument is not set to AlwaysAllow."
    },
    {
      "compliance_id": "4.2.3",
      "title": "Ensure that the --client-ca-file argument is set as appropriate",
      "existing_functions_mapped": [
        "kubelet_client_ca_file_set"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'kubelet_client_ca_file_set' directly addresses the compliance requirement of ensuring the --client-ca-file argument is set as appropriate, providing complete coverage for this compliance item."
    },
    {
      "compliance_id": "4.2.4",
      "title": "Verify that the --read-only-port argument is set to 0",
      "existing_functions_mapped": [
        "kubelet_disable_read_only_port"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'kubelet_disable_read_only_port' directly addresses the compliance requirement of disabling the read-only port."
    },
    {
      "compliance_id": "4.2.5",
      "title": "Ensure that the --streaming-connection-idle-timeout argument is not set to 0",
      "existing_functions_mapped": [
        "kubelet_streaming_connection_timeout"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'kubelet_streaming_connection_timeout' directly addresses the compliance requirement of ensuring the --streaming-connection-idle-timeout argument is not set to 0."
    },
    {
      "compliance_id": "4.2.6",
      "title": "Ensure that the --make-iptables-util-chains argument is set to true",
      "existing_functions_mapped": [
        "kubelet_manage_iptables"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'kubelet_manage_iptables' directly relates to the compliance requirement of allowing Kubelet to manage iptables, which is the purpose of the --make-iptables-util-chains argument being set to true."
    },
    {
      "compliance_id": "4.2.7",
      "title": "Ensure that the --hostname-override argument is not set",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "kubelet_no_hostname_override",
          "kubernetes_api": "kubectl get nodes -o jsonpath='{.items[*].spec.taints}'",
          "service": "kubelet",
          "rationale": "This function is needed to ensure that the --hostname-override argument is not set in kubelet configuration"
        }
      ],
      "mapping_notes": "No existing functions in the database could satisfy this compliance requirement. A new function 'kubelet_no_hostname_override' is suggested to check if the --hostname-override argument is not set in kubelet configuration."
    },
    {
      "compliance_id": "4.2.8",
      "title": "Ensure that the eventRecordQPS argument is set to a level which ensures appropriate event capture",
      "existing_functions_mapped": [
        "kubelet_event_record_qps"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'kubelet_event_record_qps' directly addresses the compliance requirement of setting the eventRecordQPS argument to an appropriate level to ensure event capture."
    },
    {
      "compliance_id": "4.2.9",
      "title": "Ensure that the --tls-cert-file and --tls-private-key-file arguments are set as appropriate",
      "existing_functions_mapped": [
        "kubelet_tls_cert_and_key"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'kubelet_tls_cert_and_key' checks if the kubelet's TLS certificate and key file arguments are set, which aligns with the compliance requirement."
    },
    {
      "compliance_id": "4.2.10",
      "title": "Ensure that the --rotate-certificates argument is not set to false",
      "existing_functions_mapped": [
        "kubelet_rotate_certificates"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'kubelet_rotate_certificates' directly addresses the compliance requirement of ensuring the --rotate-certificates argument is not set to false."
    },
    {
      "compliance_id": "4.2.11",
      "title": "Verify that the RotateKubeletServerCertificate argument is set to true",
      "existing_functions_mapped": [
        "controllermanager_rotate_kubelet_server_cert"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'controllermanager_rotate_kubelet_server_cert' directly addresses the compliance requirement of enabling kubelet server certificate rotation."
    },
    {
      "compliance_id": "4.2.12",
      "title": "Ensure that the Kubelet only makes use of Strong Cryptographic Ciphers",
      "existing_functions_mapped": [
        "kubelet_strong_ciphers_only"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'kubelet_strong_ciphers_only' directly addresses the compliance requirement of ensuring that the Kubelet only uses strong cryptographic ciphers."
    },
    {
      "compliance_id": "4.2.13",
      "title": "Ensure that a limit is set on pod PIDs",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "kubelet_set_pod_pid_limit",
          "kubernetes_api": "kubectl describe node | grep -i 'PodPidsLimit'",
          "service": "kubelet",
          "rationale": "This function is needed to ensure that the Kubelet sets limits on the number of PIDs that can be created by pods running on the node."
        }
      ],
      "mapping_notes": "No existing functions in the database directly address the compliance requirement of setting a limit on pod PIDs. A new function 'kubelet_set_pod_pid_limit' is suggested to fill this gap."
    },
    {
      "compliance_id": "5.1.1",
      "title": "Ensure that the cluster-admin role is only used where required",
      "existing_functions_mapped": [
        "rbac_cluster_admin_usage"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'rbac_cluster_admin_usage' directly addresses the compliance requirement of ensuring that the cluster-admin role is only used where required. Therefore, no new functions are needed."
    },
    {
      "compliance_id": "5.1.2",
      "title": "Minimize access to secrets",
      "existing_functions_mapped": [
        "rbac_minimize_secret_access"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "apiserver_restrict_secrets_access",
          "kubernetes_api": "kubectl get secrets --all-namespaces",
          "service": "apiserver",
          "rationale": "To ensure that access to secrets is restricted to the smallest possible group of users"
        },
        {
          "name": "core_no_secrets_in_envs",
          "kubernetes_api": "kubectl get pods --all-namespaces -o jsonpath='{.items[*].spec.containers[*].env[*].valueFrom.secretKeyRef}'",
          "service": "core",
          "rationale": "To ensure that secrets are not exposed in environment variables"
        }
      ],
      "mapping_notes": "The existing function 'rbac_minimize_secret_access' partially covers the compliance requirement by minimizing access to secrets via RBAC. However, additional functions are needed to restrict access to secrets at the API server level and to prevent exposure of secrets in environment variables."
    },
    {
      "compliance_id": "5.1.3",
      "title": "Minimize wildcard use in Roles and ClusterRoles",
      "existing_functions_mapped": [
        "rbac_minimize_wildcard_use_roles"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'rbac_minimize_wildcard_use_roles' directly addresses the compliance requirement of minimizing wildcard use in Roles and ClusterRoles. Therefore, no new functions are needed."
    },
    {
      "compliance_id": "5.1.4",
      "title": "Minimize access to create pods",
      "existing_functions_mapped": [
        "rbac_minimize_pod_creation_access"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "rbac_minimize_privileged_service_account_assignment",
          "kubernetes_api": "kubectl get serviceaccounts -n kube-system",
          "service": "apiserver",
          "rationale": "To ensure that privileged service accounts are not assigned to pods unnecessarily"
        },
        {
          "name": "rbac_minimize_hostpath_mount",
          "kubernetes_api": "kubectl get pods -n kube-system",
          "service": "apiserver",
          "rationale": "To ensure that pods do not have access to sensitive hostPaths"
        }
      ],
      "mapping_notes": "The existing function 'rbac_minimize_pod_creation_access' partially covers the compliance requirement by minimizing access to create pods. However, it does not cover the aspects of privileged service account assignment and hostPath mounting. Therefore, two new functions 'rbac_minimize_privileged_service_account_assignment' and 'rbac_minimize_hostpath_mount' are suggested."
    },
    {
      "compliance_id": "5.1.5",
      "title": "Ensure that default service accounts are not actively used.",
      "existing_functions_mapped": [
        "apiserver_service_account_lookup_true",
        "apiserver_service_account_plugin",
        "controllermanager_service_account_credentials",
        "controllermanager_service_account_private_key_file"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "core_default_service_account_usage_check",
          "kubernetes_api": "kubectl get serviceaccounts -A",
          "service": "core",
          "rationale": "To ensure that default service accounts are not actively used, a function is needed to check the usage of default service accounts across all namespaces."
        }
      ],
      "mapping_notes": "The existing functions mapped are related to service account configuration and management, but none of them specifically checks for the active usage of default service accounts. Hence, a new function is suggested to fill this gap."
    },
    {
      "compliance_id": "5.1.6",
      "title": "Ensure that Service Account Tokens are only mounted where necessary",
      "existing_functions_mapped": [
        "apiserver_service_account_plugin",
        "apiserver_service_account_lookup_true"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "core_minimize_service_account_token_mount",
          "kubernetes_api": "kubectl get pods --all-namespaces -o jsonpath='{range .items[*]}{\"\\n\"}{.metadata.name}{\": \"}{.spec.serviceAccountName}{\" \"}{.spec.automountServiceAccountToken}{end}'",
          "service": "core",
          "rationale": "This function is needed to check if service account tokens are being mounted unnecessarily in pods"
        }
      ],
      "mapping_notes": "The existing functions 'apiserver_service_account_plugin' and 'apiserver_service_account_lookup_true' partially cover the compliance requirement by ensuring that the service account plugin is enabled and that service account tokens are verified against the API server. However, a new function 'core_minimize_service_account_token_mount' is needed to check if service account tokens are being mounted in pods where they are not necessary."
    },
    {
      "compliance_id": "5.1.7",
      "title": "Avoid use of system:masters group",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "avoid_system_masters_group_usage",
          "kubernetes_api": "kubectl get clusterrolebindings -o json",
          "service": "apiserver",
          "rationale": "This function is needed to check if any user or service account is granted permissions using the system:masters group"
        }
      ],
      "mapping_notes": "No existing functions in the database directly address the compliance requirement of avoiding the use of system:masters group. A new function 'avoid_system_masters_group_usage' is suggested to fill this gap."
    },
    {
      "compliance_id": "5.1.8",
      "title": "Limit use of the Bind, Impersonate and Escalate permissions in the Kubernetes cluster",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "rbac_limit_bind_permission",
          "kubernetes_api": "kubectl get clusterrolebindings,rolebindings --all-namespaces -o json",
          "service": "rbac",
          "rationale": "To ensure that bind permissions are not granted unless strictly required"
        },
        {
          "name": "rbac_limit_impersonate_permission",
          "kubernetes_api": "kubectl get clusterrolebindings,rolebindings --all-namespaces -o json",
          "service": "rbac",
          "rationale": "To ensure that impersonate permissions are not granted unless strictly required"
        },
        {
          "name": "rbac_limit_escalate_permission",
          "kubernetes_api": "kubectl get clusterrolebindings,rolebindings --all-namespaces -o json",
          "service": "rbac",
          "rationale": "To ensure that escalate permissions are not granted unless strictly required"
        }
      ],
      "mapping_notes": "No existing functions in the database directly address the compliance requirement of limiting the use of Bind, Impersonate, and Escalate permissions. New functions are suggested to cover these requirements."
    },
    {
      "compliance_id": "5.1.9",
      "title": "Minimize access to create persistent volumes",
      "existing_functions_mapped": [
        "rbac_minimize_pv_creation_access"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "core_minimize_hostpath_pv_creation",
          "kubernetes_api": "kubectl get pv -o jsonpath='{.items[?(@.spec.hostPath)].metadata.name}'",
          "service": "core",
          "rationale": "To prevent privilege escalation via the creation of hostPath volumes"
        }
      ],
      "mapping_notes": "The existing function 'rbac_minimize_pv_creation_access' partially covers the compliance requirement by minimizing access to create persistent volumes. However, it does not specifically address the risk of privilege escalation via the creation of hostPath volumes. Therefore, a new function 'core_minimize_hostpath_pv_creation' is suggested to fill this gap."
    },
    {
      "compliance_id": "5.1.10",
      "title": "Minimize access to the proxy sub-resource of nodes",
      "existing_functions_mapped": [
        "rbac_minimize_node_proxy_subresource_access"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'rbac_minimize_node_proxy_subresource_access' directly addresses the compliance requirement of minimizing access to the proxy sub-resource of nodes. Therefore, no new functions are needed."
    },
    {
      "compliance_id": "5.1.11",
      "title": "Minimize access to the approval sub-resource of certificatesigningrequests objects",
      "existing_functions_mapped": [
        "rbac_minimize_csr_approval_access"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'rbac_minimize_csr_approval_access' directly addresses the compliance requirement of minimizing access to the approval sub-resource of certificatesigningrequests objects."
    },
    {
      "compliance_id": "5.1.12",
      "title": "Minimize access to webhook configuration objects",
      "existing_functions_mapped": [
        "rbac_minimize_webhook_config_access"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "rbac_minimize_validatingwebhookconfigurations_access",
          "kubernetes_api": "kubectl get validatingwebhookconfigurations --all-namespaces -o json",
          "service": "apiserver",
          "rationale": "To ensure that access to validatingwebhookconfigurations is minimized"
        },
        {
          "name": "rbac_minimize_mutatingwebhookconfigurations_access",
          "kubernetes_api": "kubectl get mutatingwebhookconfigurations --all-namespaces -o json",
          "service": "apiserver",
          "rationale": "To ensure that access to mutatingwebhookconfigurations is minimized"
        }
      ],
      "mapping_notes": "The existing function 'rbac_minimize_webhook_config_access' partially covers the compliance requirement. However, it does not specifically address access to 'validatingwebhookconfigurations' and 'mutatingwebhookconfigurations'. Therefore, two new functions are suggested to cover these aspects."
    },
    {
      "compliance_id": "5.1.13",
      "title": "Minimize access to the service account token creation",
      "existing_functions_mapped": [
        "rbac_minimize_service_account_token_creation"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'rbac_minimize_service_account_token_creation' directly addresses the compliance requirement of minimizing access to the service account token creation. Therefore, no new functions are needed."
    },
    {
      "compliance_id": "5.2.1",
      "title": "Ensure that the cluster has at least one active policy control mechanism in place",
      "existing_functions_mapped": [
        "apiserver_auth_mode_include_rbac",
        "apiserver_auth_mode_not_always_allow",
        "apiserver_security_context_deny_plugin",
        "apiserver_service_account_plugin",
        "apiserver_node_restriction_plugin",
        "apiserver_always_pull_images_plugin",
        "apiserver_namespace_lifecycle_plugin"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "apiserver_policy_control_mechanism_check",
          "kubernetes_api": "kubectl get pods -n kube-system",
          "service": "apiserver",
          "rationale": "To ensure that at least one policy control mechanism is active in the cluster"
        }
      ],
      "mapping_notes": "The existing functions mapped are related to policy control mechanisms in the apiserver. However, none of them directly checks if at least one policy control mechanism is active, hence the need for a new function."
    },
    {
      "compliance_id": "5.2.2",
      "title": "Minimize the admission of privileged containers",
      "existing_functions_mapped": [
        "core_minimize_privileged_containers"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'core_minimize_privileged_containers' directly addresses the compliance requirement of minimizing the admission of privileged containers."
    },
    {
      "compliance_id": "5.2.4",
      "title": "Minimize the admission of containers wishing to share the host IPC namespace",
      "existing_functions_mapped": [
        "core_minimize_hostIPC_containers"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'core_minimize_hostIPC_containers' directly addresses the compliance requirement of minimizing the admission of containers wishing to share the host IPC namespace."
    },
    {
      "compliance_id": "5.2.5",
      "title": "Minimize the admission of containers wishing to share the host network namespace",
      "existing_functions_mapped": [
        "core_minimize_hostNetwork_containers"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'core_minimize_hostNetwork_containers' directly addresses the compliance requirement of minimizing the admission of containers wishing to share the host network namespace."
    },
    {
      "compliance_id": "5.2.6",
      "title": "Minimize the admission of containers with allowPrivilegeEscalation",
      "existing_functions_mapped": [
        "core_minimize_allowPrivilegeEscalation_containers"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'core_minimize_allowPrivilegeEscalation_containers' directly addresses the compliance requirement of minimizing the admission of containers with allowPrivilegeEscalation set to true."
    },
    {
      "compliance_id": "5.2.7",
      "title": "Minimize the admission of root containers",
      "existing_functions_mapped": [
        "core_minimize_root_containers_admission"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'core_minimize_root_containers_admission' directly addresses the compliance requirement of minimizing the admission of root containers."
    },
    {
      "compliance_id": "5.2.8",
      "title": "Minimize the admission of containers with the NET_RAW capability",
      "existing_functions_mapped": [
        "core_minimize_net_raw_capability_admission"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'core_minimize_net_raw_capability_admission' directly addresses the compliance requirement of minimizing the admission of containers with the NET_RAW capability."
    },
    {
      "compliance_id": "5.2.9",
      "title": "Minimize the admission of containers with added capabilities",
      "existing_functions_mapped": [
        "core_minimize_containers_added_capabilities",
        "core_minimize_containers_capabilities_assigned"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing functions 'core_minimize_containers_added_capabilities' and 'core_minimize_containers_capabilities_assigned' adequately cover the compliance requirement of minimizing the admission of containers with added capabilities."
    },
    {
      "compliance_id": "5.2.10",
      "title": "Minimize the admission of containers with capabilities assigned",
      "existing_functions_mapped": [
        "core_minimize_containers_capabilities_assigned"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'core_minimize_containers_capabilities_assigned' directly addresses the compliance requirement of minimizing the admission of containers with capabilities assigned. Therefore, no new functions are needed."
    },
    {
      "compliance_id": "5.2.11",
      "title": "Minimize the admission of Windows HostProcess Containers",
      "existing_functions_mapped": [
        "core_minimize_admission_windows_hostprocess_containers"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'core_minimize_admission_windows_hostprocess_containers' directly addresses the compliance requirement of minimizing the admission of Windows HostProcess containers."
    },
    {
      "compliance_id": "5.2.12",
      "title": "Minimize the admission of HostPath volumes",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "core_minimize_admission_hostpath_volumes",
          "kubernetes_api": "kubectl get pods --all-namespaces -o jsonpath='{range .items[*]}{.metadata.name}{\"\\t\"}{.spec.volumes[*].hostPath.path}{\"\\n\"}{end}'",
          "service": "core",
          "rationale": "This function is needed to check if any pod is using hostPath volumes, which is not recommended for security reasons."
        }
      ],
      "mapping_notes": "No existing functions in the database directly address the compliance requirement of minimizing the admission of HostPath volumes. A new function is proposed to fill this gap."
    },
    {
      "compliance_id": "5.2.13",
      "title": "Minimize the admission of containers which use HostPorts",
      "existing_functions_mapped": [
        "core_minimize_admission_hostport_containers"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'core_minimize_admission_hostport_containers' directly addresses the compliance requirement to minimize the admission of containers which use HostPorts."
    },
    {
      "compliance_id": "5.3.1",
      "title": "Ensure that the CNI in use supports Network Policies",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "cni_network_policy_support_check",
          "kubernetes_api": "kubectl get pods -n kube-system",
          "service": "core",
          "rationale": "This function is needed to check if the CNI in use supports Network Policies"
        }
      ],
      "mapping_notes": "No existing functions in the database directly relate to the compliance requirement of ensuring the CNI in use supports Network Policies. A new function, cni_network_policy_support_check, is suggested to fill this gap."
    },
    {
      "compliance_id": "5.3.2",
      "title": "Ensure that all Namespaces have Network Policies defined",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "core_namespace_network_policy_check",
          "kubernetes_api": "kubectl get networkpolicies --all-namespaces",
          "service": "core",
          "rationale": "This function is needed to ensure that all namespaces have network policies defined, as per compliance requirement 5.3.2"
        }
      ],
      "mapping_notes": "No existing functions in the database directly relate to checking for network policies in all namespaces. A new function 'core_namespace_network_policy_check' is suggested to fill this gap."
    },
    {
      "compliance_id": "5.4.1",
      "title": "Prefer using secrets as files over secrets as environment variables",
      "existing_functions_mapped": [
        "core_no_secrets_envs"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "core_secrets_as_files",
          "kubernetes_api": "kubectl get pods -o jsonpath='{.items[*].spec.volumes[*].secret}'",
          "service": "core",
          "rationale": "This function is needed to check if secrets are being used as files, which is the preferred method over environment variables."
        }
      ],
      "mapping_notes": "The existing function 'core_no_secrets_envs' can be used to check if secrets are being used as environment variables. However, there is no existing function to check if secrets are being used as files. Therefore, a new function 'core_secrets_as_files' is suggested."
    },
    {
      "compliance_id": "5.4.2",
      "title": "Consider external secret storage",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "external_secret_storage_check",
          "kubernetes_api": "kubectl get secrets -n kube-system",
          "service": "core",
          "rationale": "To ensure that secrets are not being stored directly in Kubernetes but in an external secrets management system"
        },
        {
          "name": "external_secret_storage_authentication_check",
          "kubernetes_api": "kubectl get secrets -n kube-system",
          "service": "core",
          "rationale": "To ensure that the external secrets management system requires authentication to access secrets"
        },
        {
          "name": "external_secret_storage_audit_check",
          "kubernetes_api": "kubectl get secrets -n kube-system",
          "service": "core",
          "rationale": "To ensure that the external secrets management system has auditing of access to and use of secrets"
        },
        {
          "name": "external_secret_storage_encryption_check",
          "kubernetes_api": "kubectl get secrets -n kube-system",
          "service": "core",
          "rationale": "To ensure that the external secrets management system encrypts secrets"
        },
        {
          "name": "external_secret_storage_rotation_check",
          "kubernetes_api": "kubectl get secrets -n kube-system",
          "service": "core",
          "rationale": "To ensure that the external secrets management system supports easy rotation of secrets"
        }
      ],
      "mapping_notes": "No existing functions in the database directly address the requirements of this compliance item. New functions are suggested to cover the requirements."
    },
    {
      "compliance_id": "5.5.1",
      "title": "Configure Image Provenance using ImagePolicyWebhook admission controller",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "apiserver_image_policy_webhook_config",
          "kubernetes_api": "kubectl get apiservices v1.admissionregistration.k8s.io -o jsonpath='{.spec.service.name}'",
          "service": "apiserver",
          "rationale": "To ensure that the ImagePolicyWebhook admission controller is configured for image provenance"
        }
      ],
      "mapping_notes": "No existing functions in the database directly relate to the configuration of ImagePolicyWebhook admission controller for image provenance. A new function is suggested to check the configuration of this admission controller."
    },
    {
      "compliance_id": "5.7.1",
      "title": "Create administrative boundaries between resources using namespaces",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "namespace_isolation_check",
          "kubernetes_api": "kubectl get namespaces",
          "service": "core",
          "rationale": "To ensure that resources are properly isolated using namespaces"
        }
      ],
      "mapping_notes": "No existing functions in the database directly address the requirement of creating administrative boundaries between resources using namespaces. A new function, namespace_isolation_check, is suggested to fill this gap."
    },
    {
      "compliance_id": "5.7.2",
      "title": "Ensure that the seccomp profile is set to docker/default in your pod definitions",
      "existing_functions_mapped": [
        "core_seccomp_profile_docker_default"
      ],
      "coverage_assessment": "complete",
      "new_functions_needed": [],
      "mapping_notes": "The existing function 'core_seccomp_profile_docker_default' directly addresses the compliance requirement of ensuring the seccomp profile is set to docker/default in pod definitions."
    },
    {
      "compliance_id": "5.7.3",
      "title": "Apply Security Context to Your Pods and Containers",
      "existing_functions_mapped": [
        "apiserver_security_context_deny_plugin",
        "core_minimize_allowPrivilegeEscalation_containers",
        "core_minimize_containers_added_capabilities",
        "core_minimize_containers_capabilities_assigned",
        "core_minimize_hostIPC_containers",
        "core_minimize_hostNetwork_containers",
        "core_minimize_hostPID_containers",
        "core_minimize_net_raw_capability_admission",
        "core_minimize_privileged_containers",
        "core_minimize_root_containers_admission"
      ],
      "coverage_assessment": "partial",
      "new_functions_needed": [
        {
          "name": "core_security_context_check",
          "kubernetes_api": "kubectl get pods --all-namespaces -o jsonpath='{range .items[*]}{.metadata.name}{\"\\t\"}{.spec.securityContext}{\"\\n\"}'",
          "service": "core",
          "rationale": "To ensure that all pods have a security context applied"
        }
      ],
      "mapping_notes": "The existing functions provide partial coverage for the compliance item. They cover various aspects of the security context such as privilege escalation, capabilities, and host settings. However, there is no function that checks if a security context is applied to all pods and containers, hence the need for a new function."
    },
    {
      "compliance_id": "5.7.4",
      "title": "The default namespace should not be used",
      "existing_functions_mapped": [],
      "coverage_assessment": "none",
      "new_functions_needed": [
        {
          "name": "default_namespace_usage_check",
          "kubernetes_api": "kubectl get all --all-namespaces",
          "service": "core",
          "rationale": "This function is needed to check if any resources are being used in the default namespace, which is against the compliance requirement."
        }
      ],
      "mapping_notes": "No existing functions in the database directly address the compliance requirement of not using the default namespace. A new function 'default_namespace_usage_check' is suggested to fill this gap."
    }
  ],
  "new_functions_suggested": [
    {
      "name": "apiserver_pod_spec_file_permissions",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l <file_path>",
      "service": "apiserver",
      "rationale": "This function is needed to check the permissions of the API server pod specification file and ensure they are set to 644 or more restrictive."
    },
    {
      "name": "apiserver_pod_spec_file_ownership",
      "kubernetes_api": "kubectl exec -it <pod_name> -- chown root:root <file_path>",
      "service": "apiserver",
      "rationale": "This function is needed to ensure that the API server pod specification file ownership is set to root:root, which is a requirement for compliance item 1.1.2"
    },
    {
      "name": "controllermanager_pod_spec_file_permissions",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l <file_path>",
      "service": "controllermanager",
      "rationale": "This function is needed to check the permissions of the controller manager pod specification file and ensure they are set to 644 or more restrictive."
    },
    {
      "name": "controllermanager_pod_spec_file_ownership",
      "kubernetes_api": "kubectl exec -it <pod_name> -- chown root:root <file_path>",
      "service": "controllermanager",
      "rationale": "This function is needed to ensure that the controller manager pod specification file ownership is set to root:root, which is a security best practice to prevent unauthorized modifications."
    },
    {
      "name": "scheduler_pod_spec_file_permissions",
      "kubernetes_api": "kubectl get pods -n kube-system",
      "service": "scheduler",
      "rationale": "To ensure that the scheduler pod specification file permissions are set to 644 or more restrictive"
    },
    {
      "name": "scheduler_pod_spec_file_ownership",
      "kubernetes_api": "kubectl exec -it <pod_name> -- chown root:root <scheduler_pod_spec_file>",
      "service": "scheduler",
      "rationale": "This function is needed to ensure that the scheduler pod specification file ownership is set to root:root, which is a security best practice to prevent unauthorized modifications."
    },
    {
      "name": "etcd_pod_spec_file_permissions",
      "kubernetes_api": "kubectl exec -it etcd-master -- ls -l /etc/kubernetes/manifests/etcd.yaml",
      "service": "etcd",
      "rationale": "This function is needed to check the permissions of the etcd pod specification file and ensure they are set to 644 or more restrictive"
    },
    {
      "name": "etcd_pod_spec_file_ownership",
      "kubernetes_api": "kubectl exec -it etcd-master -- chown root:root /etc/kubernetes/manifests/etcd.yaml",
      "service": "etcd",
      "rationale": "This function is needed to ensure that the etcd pod specification file ownership is set to root:root, which is a security best practice to prevent unauthorized modifications."
    },
    {
      "name": "container_network_interface_file_permissions",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/cni/net.d/",
      "service": "core",
      "rationale": "This function is needed to check the permissions of the Container Network Interface files and ensure they are set to 644 or more restrictive"
    },
    {
      "name": "container_network_interface_file_ownership",
      "kubernetes_api": "kubectl exec -it <pod_name> -- chown root:root <cni_file_path>",
      "service": "core",
      "rationale": "This function is needed to ensure that the Container Network Interface file ownership is set to root:root, which is a security best practice to prevent unauthorized modifications."
    },
    {
      "name": "etcd_data_directory_permissions_check",
      "kubernetes_api": "kubectl exec etcd-master -n kube-system -- ls -l /var/lib/etcd",
      "service": "etcd",
      "rationale": "This function is needed to check the permissions of the etcd data directory and ensure they are set to 700 or more restrictive"
    },
    {
      "name": "etcd_data_directory_ownership_check",
      "kubernetes_api": "kubectl exec -it etcd-master -- chown -R etcd:etcd /var/lib/etcd",
      "service": "etcd",
      "rationale": "This function is needed to ensure that the etcd data directory ownership is set to etcd:etcd, which is a critical security measure to protect the data stored in etcd."
    },
    {
      "name": "admin_conf_file_permissions",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/admin.conf",
      "service": "apiserver",
      "rationale": "To ensure that the admin.conf file permissions are set to 644"
    },
    {
      "name": "apiserver_admin_conf_file_ownership",
      "kubernetes_api": "ls -l /etc/kubernetes/admin.conf",
      "service": "apiserver",
      "rationale": "To ensure that the admin.conf file ownership is set to root:root, a new function is needed that checks the ownership of this file."
    },
    {
      "name": "scheduler_conf_file_permissions",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/scheduler.conf",
      "service": "scheduler",
      "rationale": "This function is needed to check the permissions of the scheduler.conf file and ensure they are set to 644 or more restrictive."
    },
    {
      "name": "scheduler_conf_file_ownership",
      "kubernetes_api": "kubectl exec -it <pod_name> -n kube-system -- ls -l /etc/kubernetes/scheduler.conf",
      "service": "scheduler",
      "rationale": "This function is needed to ensure that the scheduler.conf file ownership is set to root:root, which is a critical security measure to prevent unauthorized access or modifications."
    },
    {
      "name": "controllermanager_conf_file_permissions",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/controller-manager.conf",
      "service": "controllermanager",
      "rationale": "This function is needed to check the permissions of the controller-manager.conf file and ensure they are set to 644 or more restrictive."
    },
    {
      "name": "controllermanager_conf_file_ownership",
      "kubernetes_api": "kubectl exec -it <pod_name> -n kube-system -- ls -l /etc/kubernetes/controller-manager.conf",
      "service": "controllermanager",
      "rationale": "This function is needed to ensure that the controller-manager.conf file ownership is set to root:root, which is a critical security measure to prevent unauthorized access or modifications."
    },
    {
      "name": "kubernetes_pki_directory_file_ownership_check",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/pki/",
      "service": "apiserver",
      "rationale": "This function is needed to ensure that the Kubernetes PKI directory and file ownership is set to root:root, which is a critical security measure to prevent unauthorized access or modifications."
    },
    {
      "name": "apiserver_pki_cert_file_permissions",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/pki/",
      "service": "apiserver",
      "rationale": "To ensure that the Kubernetes PKI certificate files have permissions of 600 or more restrictive"
    },
    {
      "name": "kubernetes_pki_key_file_permissions_check",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/pki/",
      "service": "core",
      "rationale": "This function is needed to ensure that the Kubernetes PKI key files have permissions of 600."
    },
    {
      "name": "etcd_certfile_and_keyfile_set",
      "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[?(@.metadata.labels.component==\"etcd\")].spec.containers[0].command}'",
      "service": "etcd",
      "rationale": "To ensure that the --etcd-certfile and --etcd-keyfile arguments are set as appropriate, a specific function is needed to check these arguments in the etcd configuration."
    },
    {
      "name": "apiserver_tls_cert_file_set",
      "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[*].spec.containers[*].command}' | grep -- '--tls-cert-file'",
      "service": "apiserver",
      "rationale": "To ensure that the --tls-cert-file argument is set as appropriate"
    },
    {
      "name": "apiserver_tls_private_key_file_set",
      "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[*].spec.containers[*].command}' | grep -- '--tls-private-key-file'",
      "service": "apiserver",
      "rationale": "To ensure that the --tls-private-key-file argument is set as appropriate"
    },
    {
      "name": "controllermanager_terminated_pod_gc_threshold_set",
      "kubernetes_api": "kubectl get pods -n kube-system",
      "service": "controllermanager",
      "rationale": "This function is needed to ensure that the garbage collector is activated on pod termination as appropriate, which is a requirement of compliance item 1.3.1."
    },
    {
      "name": "apiserver_root_ca_file_set",
      "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{range .items[*]}{.spec.containers[*].command}{\"\\n\"}{end}' | grep kube-apiserver | grep -- --root-ca-file",
      "service": "apiserver",
      "rationale": "To ensure that the --root-ca-file argument is set as appropriate in the API server"
    },
    {
      "name": "etcd_cert_file_and_key_file_set",
      "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[*].spec.containers[*].command}'",
      "service": "etcd",
      "rationale": "To ensure that the --cert-file and --key-file arguments are set as appropriate for etcd service"
    },
    {
      "name": "apiserver_no_auto_tls",
      "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[?(@.metadata.labels.component==\"kube-apiserver\")].spec.containers[0].command}'",
      "service": "apiserver",
      "rationale": "To ensure that the --auto-tls argument is not set to true in the apiserver"
    },
    {
      "name": "etcd_peer_cert_file_set",
      "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[*].spec.containers[*].command}' | grep -- --peer-cert-file",
      "service": "etcd",
      "rationale": "To ensure that the --peer-cert-file argument is set as appropriate"
    },
    {
      "name": "etcd_peer_key_file_set",
      "kubernetes_api": "kubectl get pods -n kube-system -o jsonpath='{.items[*].spec.containers[*].command}' | grep -- --peer-key-file",
      "service": "etcd",
      "rationale": "To ensure that the --peer-key-file argument is set as appropriate"
    },
    {
      "name": "apiserver_disable_user_client_cert_auth",
      "kubernetes_api": "kubectl get --raw /api/v1/nodes | jq -r '.items[].status.addresses[] | select(.type == \"InternalIP\") .address'",
      "service": "apiserver",
      "rationale": "To ensure that client certificate authentication is not used for users, a function is needed to disable this authentication method for user accounts in the API server."
    },
    {
      "name": "apiserver_disable_service_account_token_for_users",
      "kubernetes_api": "kubectl get serviceaccounts -A",
      "service": "apiserver",
      "rationale": "To ensure that service account tokens are not used for user authentication, a function is needed to check and disable this feature for all users."
    },
    {
      "name": "apiserver_bootstrap_token_auth_check",
      "kubernetes_api": "kubectl get clusterrolebindings system:node-bootstrapper -o json",
      "service": "apiserver",
      "rationale": "To ensure bootstrap tokens are not used for general authentication"
    },
    {
      "name": "apiserver_audit_policy_file_set",
      "kubernetes_api": "kubectl get pods -n kube-system",
      "service": "apiserver",
      "rationale": "This function is needed to ensure that the --audit-policy-file flag is set, which is a requirement for enabling logging of requests made to the API server."
    },
    {
      "name": "apiserver_audit_policy_security_concerns_check",
      "kubernetes_api": "kubectl get auditpolicies.audit.k8s.io -n kube-system",
      "service": "apiserver",
      "rationale": "To ensure that the audit policy created for the cluster covers key security concerns"
    },
    {
      "name": "proxy_kubeconfig_file_permissions",
      "kubernetes_api": "kubectl exec -it kube-proxy -- ls -l /etc/kubernetes/proxy-kubeconfig",
      "service": "kube-proxy",
      "rationale": "This function is needed to check the permissions of the proxy kubeconfig file and ensure they are set to 644 or more restrictive."
    },
    {
      "name": "kube_proxy_kubeconfig_file_ownership",
      "kubernetes_api": "ls -l /etc/kubernetes/proxy.conf",
      "service": "kube-proxy",
      "rationale": "To ensure the kube-proxy kubeconfig file is owned by root:root"
    },
    {
      "name": "apiserver_ca_file_permissions_check",
      "kubernetes_api": "kubectl get pods -n kube-system",
      "service": "apiserver",
      "rationale": "To ensure that the certificate authorities file permissions are set to 600 or more restrictive"
    },
    {
      "name": "kubelet_ca_file_permissions_check",
      "kubernetes_api": "kubectl get pods -n kube-system",
      "service": "kubelet",
      "rationale": "To ensure that the certificate authorities file permissions are set to 600 or more restrictive"
    },
    {
      "name": "check_client_ca_file_ownership",
      "kubernetes_api": "kubectl exec -it <pod_name> -- ls -l /etc/kubernetes/pki",
      "service": "apiserver",
      "rationale": "To ensure that the client certificate authorities file ownership is set to root:root"
    },
    {
      "name": "kubelet_no_hostname_override",
      "kubernetes_api": "kubectl get nodes -o jsonpath='{.items[*].spec.taints}'",
      "service": "kubelet",
      "rationale": "This function is needed to ensure that the --hostname-override argument is not set in kubelet configuration"
    },
    {
      "name": "kubelet_set_pod_pid_limit",
      "kubernetes_api": "kubectl describe node | grep -i 'PodPidsLimit'",
      "service": "kubelet",
      "rationale": "This function is needed to ensure that the Kubelet sets limits on the number of PIDs that can be created by pods running on the node."
    },
    {
      "name": "apiserver_restrict_secrets_access",
      "kubernetes_api": "kubectl get secrets --all-namespaces",
      "service": "apiserver",
      "rationale": "To ensure that access to secrets is restricted to the smallest possible group of users"
    },
    {
      "name": "core_no_secrets_in_envs",
      "kubernetes_api": "kubectl get pods --all-namespaces -o jsonpath='{.items[*].spec.containers[*].env[*].valueFrom.secretKeyRef}'",
      "service": "core",
      "rationale": "To ensure that secrets are not exposed in environment variables"
    },
    {
      "name": "rbac_minimize_privileged_service_account_assignment",
      "kubernetes_api": "kubectl get serviceaccounts -n kube-system",
      "service": "apiserver",
      "rationale": "To ensure that privileged service accounts are not assigned to pods unnecessarily"
    },
    {
      "name": "rbac_minimize_hostpath_mount",
      "kubernetes_api": "kubectl get pods -n kube-system",
      "service": "apiserver",
      "rationale": "To ensure that pods do not have access to sensitive hostPaths"
    },
    {
      "name": "core_default_service_account_usage_check",
      "kubernetes_api": "kubectl get serviceaccounts -A",
      "service": "core",
      "rationale": "To ensure that default service accounts are not actively used, a function is needed to check the usage of default service accounts across all namespaces."
    },
    {
      "name": "core_minimize_service_account_token_mount",
      "kubernetes_api": "kubectl get pods --all-namespaces -o jsonpath='{range .items[*]}{\"\\n\"}{.metadata.name}{\": \"}{.spec.serviceAccountName}{\" \"}{.spec.automountServiceAccountToken}{end}'",
      "service": "core",
      "rationale": "This function is needed to check if service account tokens are being mounted unnecessarily in pods"
    },
    {
      "name": "avoid_system_masters_group_usage",
      "kubernetes_api": "kubectl get clusterrolebindings -o json",
      "service": "apiserver",
      "rationale": "This function is needed to check if any user or service account is granted permissions using the system:masters group"
    },
    {
      "name": "rbac_limit_bind_permission",
      "kubernetes_api": "kubectl get clusterrolebindings,rolebindings --all-namespaces -o json",
      "service": "rbac",
      "rationale": "To ensure that bind permissions are not granted unless strictly required"
    },
    {
      "name": "rbac_limit_impersonate_permission",
      "kubernetes_api": "kubectl get clusterrolebindings,rolebindings --all-namespaces -o json",
      "service": "rbac",
      "rationale": "To ensure that impersonate permissions are not granted unless strictly required"
    },
    {
      "name": "rbac_limit_escalate_permission",
      "kubernetes_api": "kubectl get clusterrolebindings,rolebindings --all-namespaces -o json",
      "service": "rbac",
      "rationale": "To ensure that escalate permissions are not granted unless strictly required"
    },
    {
      "name": "core_minimize_hostpath_pv_creation",
      "kubernetes_api": "kubectl get pv -o jsonpath='{.items[?(@.spec.hostPath)].metadata.name}'",
      "service": "core",
      "rationale": "To prevent privilege escalation via the creation of hostPath volumes"
    },
    {
      "name": "rbac_minimize_validatingwebhookconfigurations_access",
      "kubernetes_api": "kubectl get validatingwebhookconfigurations --all-namespaces -o json",
      "service": "apiserver",
      "rationale": "To ensure that access to validatingwebhookconfigurations is minimized"
    },
    {
      "name": "rbac_minimize_mutatingwebhookconfigurations_access",
      "kubernetes_api": "kubectl get mutatingwebhookconfigurations --all-namespaces -o json",
      "service": "apiserver",
      "rationale": "To ensure that access to mutatingwebhookconfigurations is minimized"
    },
    {
      "name": "apiserver_policy_control_mechanism_check",
      "kubernetes_api": "kubectl get pods -n kube-system",
      "service": "apiserver",
      "rationale": "To ensure that at least one policy control mechanism is active in the cluster"
    },
    {
      "name": "core_minimize_admission_hostpath_volumes",
      "kubernetes_api": "kubectl get pods --all-namespaces -o jsonpath='{range .items[*]}{.metadata.name}{\"\\t\"}{.spec.volumes[*].hostPath.path}{\"\\n\"}{end}'",
      "service": "core",
      "rationale": "This function is needed to check if any pod is using hostPath volumes, which is not recommended for security reasons."
    },
    {
      "name": "cni_network_policy_support_check",
      "kubernetes_api": "kubectl get pods -n kube-system",
      "service": "core",
      "rationale": "This function is needed to check if the CNI in use supports Network Policies"
    },
    {
      "name": "core_namespace_network_policy_check",
      "kubernetes_api": "kubectl get networkpolicies --all-namespaces",
      "service": "core",
      "rationale": "This function is needed to ensure that all namespaces have network policies defined, as per compliance requirement 5.3.2"
    },
    {
      "name": "core_secrets_as_files",
      "kubernetes_api": "kubectl get pods -o jsonpath='{.items[*].spec.volumes[*].secret}'",
      "service": "core",
      "rationale": "This function is needed to check if secrets are being used as files, which is the preferred method over environment variables."
    },
    {
      "name": "external_secret_storage_check",
      "kubernetes_api": "kubectl get secrets -n kube-system",
      "service": "core",
      "rationale": "To ensure that secrets are not being stored directly in Kubernetes but in an external secrets management system"
    },
    {
      "name": "external_secret_storage_authentication_check",
      "kubernetes_api": "kubectl get secrets -n kube-system",
      "service": "core",
      "rationale": "To ensure that the external secrets management system requires authentication to access secrets"
    },
    {
      "name": "external_secret_storage_audit_check",
      "kubernetes_api": "kubectl get secrets -n kube-system",
      "service": "core",
      "rationale": "To ensure that the external secrets management system has auditing of access to and use of secrets"
    },
    {
      "name": "external_secret_storage_encryption_check",
      "kubernetes_api": "kubectl get secrets -n kube-system",
      "service": "core",
      "rationale": "To ensure that the external secrets management system encrypts secrets"
    },
    {
      "name": "external_secret_storage_rotation_check",
      "kubernetes_api": "kubectl get secrets -n kube-system",
      "service": "core",
      "rationale": "To ensure that the external secrets management system supports easy rotation of secrets"
    },
    {
      "name": "apiserver_image_policy_webhook_config",
      "kubernetes_api": "kubectl get apiservices v1.admissionregistration.k8s.io -o jsonpath='{.spec.service.name}'",
      "service": "apiserver",
      "rationale": "To ensure that the ImagePolicyWebhook admission controller is configured for image provenance"
    },
    {
      "name": "namespace_isolation_check",
      "kubernetes_api": "kubectl get namespaces",
      "service": "core",
      "rationale": "To ensure that resources are properly isolated using namespaces"
    },
    {
      "name": "core_security_context_check",
      "kubernetes_api": "kubectl get pods --all-namespaces -o jsonpath='{range .items[*]}{.metadata.name}{\"\\t\"}{.spec.securityContext}{\"\\n\"}'",
      "service": "core",
      "rationale": "To ensure that all pods have a security context applied"
    },
    {
      "name": "default_namespace_usage_check",
      "kubernetes_api": "kubectl get all --all-namespaces",
      "service": "core",
      "rationale": "This function is needed to check if any resources are being used in the default namespace, which is against the compliance requirement."
    }
  ]
}