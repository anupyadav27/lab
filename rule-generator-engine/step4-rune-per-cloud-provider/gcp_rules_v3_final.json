[
  {
    "rule_id": "gcp.iam.serviceAccount.strong_authn_enabled",
    "assertion_id": "identity_access.authentication.strong_authn_enabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.serviceAccount",
    "adapter": "gcp.iam.serviceAccount",
    "adapter_evidence_type": "gcp.iam.serviceAccount[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_authn_factors_required": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for strong_authn_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.serviceAccount",
      "evidence_path": "gcp.iam.serviceAccount[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam strong_authn_enabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for strong_authn_enabled",
    "remediation": "Configure iam with security best practices for strong_authn_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.serviceAccount.service_authn_configured",
    "assertion_id": "identity_access.authentication.service_authn_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.serviceAccount",
    "adapter": "gcp.iam.serviceAccount",
    "adapter_evidence_type": "gcp.iam.serviceAccount[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for service_authn_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.serviceAccount",
      "evidence_path": "gcp.iam.serviceAccount[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam service_authn_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for service_authn_configured",
    "remediation": "Configure iam with security best practices for service_authn_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.serviceAccount.legacy_authn_disabled",
    "assertion_id": "identity_access.authentication.legacy_authn_disabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.serviceAccount",
    "adapter": "gcp.iam.serviceAccount",
    "adapter_evidence_type": "gcp.iam.serviceAccount[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for legacy_authn_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.serviceAccount",
      "evidence_path": "gcp.iam.serviceAccount[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam legacy_authn_disabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for legacy_authn_disabled",
    "remediation": "Configure iam with security best practices for legacy_authn_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.serviceAccount.session_timeout_configured",
    "assertion_id": "identity_access.authentication.session_timeout_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.serviceAccount",
    "adapter": "gcp.iam.serviceAccount",
    "adapter_evidence_type": "gcp.iam.serviceAccount[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for session_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.serviceAccount",
      "evidence_path": "gcp.iam.serviceAccount[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam session_timeout_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for session_timeout_configured",
    "remediation": "Configure iam with security best practices for session_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.workload_identity_pool.strong_authn_enabled",
    "assertion_id": "identity_access.authentication.strong_authn_enabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.workload_identity_pool",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_authn_factors_required": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for strong_authn_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.workload_identity_pool",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam strong_authn_enabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for strong_authn_enabled",
    "remediation": "Configure iam with security best practices for strong_authn_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.workload_identity_pool.service_authn_configured",
    "assertion_id": "identity_access.authentication.service_authn_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.workload_identity_pool",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for service_authn_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.workload_identity_pool",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam service_authn_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for service_authn_configured",
    "remediation": "Configure iam with security best practices for service_authn_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.workload_identity_pool.legacy_authn_disabled",
    "assertion_id": "identity_access.authentication.legacy_authn_disabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.workload_identity_pool",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for legacy_authn_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.workload_identity_pool",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam legacy_authn_disabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for legacy_authn_disabled",
    "remediation": "Configure iam with security best practices for legacy_authn_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.workload_identity_pool.session_timeout_configured",
    "assertion_id": "identity_access.authentication.session_timeout_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.workload_identity_pool",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for session_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.workload_identity_pool",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam session_timeout_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for session_timeout_configured",
    "remediation": "Configure iam with security best practices for session_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.organization_policy_constraints.strong_authn_enabled",
    "assertion_id": "identity_access.authentication.strong_authn_enabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.organization_policy_constraints",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_authn_factors_required": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for strong_authn_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.organization_policy_constraints",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam strong_authn_enabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for strong_authn_enabled",
    "remediation": "Configure iam with security best practices for strong_authn_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.organization_policy_constraints.service_authn_configured",
    "assertion_id": "identity_access.authentication.service_authn_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.organization_policy_constraints",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for service_authn_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.organization_policy_constraints",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam service_authn_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for service_authn_configured",
    "remediation": "Configure iam with security best practices for service_authn_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.organization_policy_constraints.legacy_authn_disabled",
    "assertion_id": "identity_access.authentication.legacy_authn_disabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.organization_policy_constraints",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for legacy_authn_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.organization_policy_constraints",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam legacy_authn_disabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for legacy_authn_disabled",
    "remediation": "Configure iam with security best practices for legacy_authn_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.organization_policy_constraints.session_timeout_configured",
    "assertion_id": "identity_access.authentication.session_timeout_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.organization_policy_constraints",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for session_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.organization_policy_constraints",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam session_timeout_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for session_timeout_configured",
    "remediation": "Configure iam with security best practices for session_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.group_authentication_policy.strong_authn_enabled",
    "assertion_id": "identity_access.authentication.strong_authn_enabled",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.group_authentication_policy",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_authn_factors_required": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for strong_authn_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.group_authentication_policy",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity strong_authn_enabled implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for strong_authn_enabled",
    "remediation": "Configure cloudidentity with security best practices for strong_authn_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.group_authentication_policy.service_authn_configured",
    "assertion_id": "identity_access.authentication.service_authn_configured",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.group_authentication_policy",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for service_authn_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.group_authentication_policy",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity service_authn_configured implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for service_authn_configured",
    "remediation": "Configure cloudidentity with security best practices for service_authn_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.group_authentication_policy.legacy_authn_disabled",
    "assertion_id": "identity_access.authentication.legacy_authn_disabled",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.group_authentication_policy",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for legacy_authn_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.group_authentication_policy",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity legacy_authn_disabled implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for legacy_authn_disabled",
    "remediation": "Configure cloudidentity with security best practices for legacy_authn_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.group_authentication_policy.session_timeout_configured",
    "assertion_id": "identity_access.authentication.session_timeout_configured",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.group_authentication_policy",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for session_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.group_authentication_policy",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity session_timeout_configured implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for session_timeout_configured",
    "remediation": "Configure cloudidentity with security best practices for session_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.sso_configuration.strong_authn_enabled",
    "assertion_id": "identity_access.authentication.strong_authn_enabled",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.sso_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_authn_factors_required": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for strong_authn_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.sso_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity strong_authn_enabled implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for strong_authn_enabled",
    "remediation": "Configure cloudidentity with security best practices for strong_authn_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.sso_configuration.service_authn_configured",
    "assertion_id": "identity_access.authentication.service_authn_configured",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.sso_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for service_authn_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.sso_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity service_authn_configured implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for service_authn_configured",
    "remediation": "Configure cloudidentity with security best practices for service_authn_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.sso_configuration.legacy_authn_disabled",
    "assertion_id": "identity_access.authentication.legacy_authn_disabled",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.sso_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for legacy_authn_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.sso_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity legacy_authn_disabled implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for legacy_authn_disabled",
    "remediation": "Configure cloudidentity with security best practices for legacy_authn_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.sso_configuration.session_timeout_configured",
    "assertion_id": "identity_access.authentication.session_timeout_configured",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.sso_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for session_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.sso_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity session_timeout_configured implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for session_timeout_configured",
    "remediation": "Configure cloudidentity with security best practices for session_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.authentication_configuration.strong_authn_enabled",
    "assertion_id": "identity_access.authentication.strong_authn_enabled",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.authentication_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_authn_factors_required": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for strong_authn_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.authentication_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager strong_authn_enabled implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for strong_authn_enabled",
    "remediation": "Configure accesscontextmanager with security best practices for strong_authn_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.authentication_configuration.service_authn_configured",
    "assertion_id": "identity_access.authentication.service_authn_configured",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.authentication_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for service_authn_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.authentication_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager service_authn_configured implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for service_authn_configured",
    "remediation": "Configure accesscontextmanager with security best practices for service_authn_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.authentication_configuration.legacy_authn_disabled",
    "assertion_id": "identity_access.authentication.legacy_authn_disabled",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.authentication_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for legacy_authn_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.authentication_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager legacy_authn_disabled implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for legacy_authn_disabled",
    "remediation": "Configure accesscontextmanager with security best practices for legacy_authn_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.authentication_configuration.session_timeout_configured",
    "assertion_id": "identity_access.authentication.session_timeout_configured",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.authentication_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for session_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.authentication_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager session_timeout_configured implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for session_timeout_configured",
    "remediation": "Configure accesscontextmanager with security best practices for session_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.service_account_key_rotation.strong_authn_enabled",
    "assertion_id": "identity_access.authentication.strong_authn_enabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.service_account_key_rotation",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_authn_factors_required": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "iam must implement security controls for strong_authn_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account_key_rotation",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam strong_authn_enabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for strong_authn_enabled",
    "remediation": "Configure iam with security best practices for strong_authn_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.service_account_key_rotation.service_authn_configured",
    "assertion_id": "identity_access.authentication.service_authn_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.service_account_key_rotation",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "iam must implement security controls for service_authn_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account_key_rotation",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam service_authn_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for service_authn_configured",
    "remediation": "Configure iam with security best practices for service_authn_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.service_account_key_rotation.legacy_authn_disabled",
    "assertion_id": "identity_access.authentication.legacy_authn_disabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.service_account_key_rotation",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "iam must implement security controls for legacy_authn_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account_key_rotation",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam legacy_authn_disabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for legacy_authn_disabled",
    "remediation": "Configure iam with security best practices for legacy_authn_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.service_account_key_rotation.session_timeout_configured",
    "assertion_id": "identity_access.authentication.session_timeout_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.service_account_key_rotation",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "iam must implement security controls for session_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account_key_rotation",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam session_timeout_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for session_timeout_configured",
    "remediation": "Configure iam with security best practices for session_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.role_based_access_control.permission_boundaries_enforced",
    "assertion_id": "identity_access.authorization.permission_boundaries_enforced",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.role_based_access_control",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for permission_boundaries_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.role_based_access_control",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam permission_boundaries_enforced implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for permission_boundaries_enforced",
    "remediation": "Configure iam with security best practices for permission_boundaries_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.role_based_access_control.resource_policies_configured",
    "assertion_id": "identity_access.authorization.resource_policies_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.role_based_access_control",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for resource_policies_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.role_based_access_control",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam resource_policies_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for resource_policies_configured",
    "remediation": "Configure iam with security best practices for resource_policies_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.role_based_access_control.conditional_access_enabled",
    "assertion_id": "identity_access.authorization.conditional_access_enabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.role_based_access_control",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for conditional_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.role_based_access_control",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam conditional_access_enabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for conditional_access_enabled",
    "remediation": "Configure iam with security best practices for conditional_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.conditional_access_policies.permission_boundaries_enforced",
    "assertion_id": "identity_access.authorization.permission_boundaries_enforced",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.conditional_access_policies",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for permission_boundaries_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.conditional_access_policies",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam permission_boundaries_enforced implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for permission_boundaries_enforced",
    "remediation": "Configure iam with security best practices for permission_boundaries_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.conditional_access_policies.resource_policies_configured",
    "assertion_id": "identity_access.authorization.resource_policies_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.conditional_access_policies",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for resource_policies_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.conditional_access_policies",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam resource_policies_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for resource_policies_configured",
    "remediation": "Configure iam with security best practices for resource_policies_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.conditional_access_policies.conditional_access_enabled",
    "assertion_id": "identity_access.authorization.conditional_access_enabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.conditional_access_policies",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for conditional_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.conditional_access_policies",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam conditional_access_enabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for conditional_access_enabled",
    "remediation": "Configure iam with security best practices for conditional_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.organization_policy_enforcement.permission_boundaries_enforced",
    "assertion_id": "identity_access.authorization.permission_boundaries_enforced",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.organization_policy_enforcement",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for permission_boundaries_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.organization_policy_enforcement",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam permission_boundaries_enforced implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for permission_boundaries_enforced",
    "remediation": "Configure iam with security best practices for permission_boundaries_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.organization_policy_enforcement.resource_policies_configured",
    "assertion_id": "identity_access.authorization.resource_policies_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.organization_policy_enforcement",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for resource_policies_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.organization_policy_enforcement",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam resource_policies_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for resource_policies_configured",
    "remediation": "Configure iam with security best practices for resource_policies_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.organization_policy_enforcement.conditional_access_enabled",
    "assertion_id": "identity_access.authorization.conditional_access_enabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.organization_policy_enforcement",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for conditional_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.organization_policy_enforcement",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam conditional_access_enabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for conditional_access_enabled",
    "remediation": "Configure iam with security best practices for conditional_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.group_membership_policies.permission_boundaries_enforced",
    "assertion_id": "identity_access.authorization.permission_boundaries_enforced",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.group_membership_policies",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for permission_boundaries_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.group_membership_policies",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity permission_boundaries_enforced implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for permission_boundaries_enforced",
    "remediation": "Configure cloudidentity with security best practices for permission_boundaries_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.group_membership_policies.resource_policies_configured",
    "assertion_id": "identity_access.authorization.resource_policies_configured",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.group_membership_policies",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for resource_policies_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.group_membership_policies",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity resource_policies_configured implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for resource_policies_configured",
    "remediation": "Configure cloudidentity with security best practices for resource_policies_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.group_membership_policies.conditional_access_enabled",
    "assertion_id": "identity_access.authorization.conditional_access_enabled",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.group_membership_policies",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for conditional_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.group_membership_policies",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity conditional_access_enabled implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for conditional_access_enabled",
    "remediation": "Configure cloudidentity with security best practices for conditional_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.access_control_lists.permission_boundaries_enforced",
    "assertion_id": "identity_access.authorization.permission_boundaries_enforced",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.access_control_lists",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for permission_boundaries_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.access_control_lists",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity permission_boundaries_enforced implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for permission_boundaries_enforced",
    "remediation": "Configure cloudidentity with security best practices for permission_boundaries_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.access_control_lists.resource_policies_configured",
    "assertion_id": "identity_access.authorization.resource_policies_configured",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.access_control_lists",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for resource_policies_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.access_control_lists",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity resource_policies_configured implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for resource_policies_configured",
    "remediation": "Configure cloudidentity with security best practices for resource_policies_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.access_control_lists.conditional_access_enabled",
    "assertion_id": "identity_access.authorization.conditional_access_enabled",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.access_control_lists",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for conditional_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.access_control_lists",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity conditional_access_enabled implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for conditional_access_enabled",
    "remediation": "Configure cloudidentity with security best practices for conditional_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.access_level_conditions.permission_boundaries_enforced",
    "assertion_id": "identity_access.authorization.permission_boundaries_enforced",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.access_level_conditions",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for permission_boundaries_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.access_level_conditions",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager permission_boundaries_enforced implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for permission_boundaries_enforced",
    "remediation": "Configure accesscontextmanager with security best practices for permission_boundaries_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.access_level_conditions.resource_policies_configured",
    "assertion_id": "identity_access.authorization.resource_policies_configured",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.access_level_conditions",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for resource_policies_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.access_level_conditions",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager resource_policies_configured implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for resource_policies_configured",
    "remediation": "Configure accesscontextmanager with security best practices for resource_policies_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.access_level_conditions.conditional_access_enabled",
    "assertion_id": "identity_access.authorization.conditional_access_enabled",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.access_level_conditions",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for conditional_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.access_level_conditions",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager conditional_access_enabled implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for conditional_access_enabled",
    "remediation": "Configure accesscontextmanager with security best practices for conditional_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.service_perimeter_policies.permission_boundaries_enforced",
    "assertion_id": "identity_access.authorization.permission_boundaries_enforced",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.service_perimeter_policies",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for permission_boundaries_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.service_perimeter_policies",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager permission_boundaries_enforced implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for permission_boundaries_enforced",
    "remediation": "Configure accesscontextmanager with security best practices for permission_boundaries_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.service_perimeter_policies.resource_policies_configured",
    "assertion_id": "identity_access.authorization.resource_policies_configured",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.service_perimeter_policies",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for resource_policies_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.service_perimeter_policies",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager resource_policies_configured implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for resource_policies_configured",
    "remediation": "Configure accesscontextmanager with security best practices for resource_policies_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.service_perimeter_policies.conditional_access_enabled",
    "assertion_id": "identity_access.authorization.conditional_access_enabled",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.service_perimeter_policies",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for conditional_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.service_perimeter_policies",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager conditional_access_enabled implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for conditional_access_enabled",
    "remediation": "Configure accesscontextmanager with security best practices for conditional_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.federation_configuration.external_idp_configured",
    "assertion_id": "identity_access.federation.external_idp_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.federation_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for external_idp_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.federation_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam external_idp_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for external_idp_configured",
    "remediation": "Configure iam with security best practices for external_idp_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.federation_configuration.trust_relationships_managed",
    "assertion_id": "identity_access.federation.trust_relationships_managed",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.federation_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for trust_relationships_managed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.federation_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam trust_relationships_managed implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for trust_relationships_managed",
    "remediation": "Configure iam with security best practices for trust_relationships_managed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.federation_configuration.cross_account_access_controlled",
    "assertion_id": "identity_access.federation.cross_account_access_controlled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.federation_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for cross_account_access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.federation_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam cross_account_access_controlled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for cross_account_access_controlled",
    "remediation": "Configure iam with security best practices for cross_account_access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.federation_configuration.external_idp_configured",
    "assertion_id": "identity_access.federation.external_idp_configured",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.federation_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for external_idp_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.federation_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity external_idp_configured implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for external_idp_configured",
    "remediation": "Configure cloudidentity with security best practices for external_idp_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.federation_configuration.trust_relationships_managed",
    "assertion_id": "identity_access.federation.trust_relationships_managed",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.federation_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for trust_relationships_managed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.federation_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity trust_relationships_managed implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for trust_relationships_managed",
    "remediation": "Configure cloudidentity with security best practices for trust_relationships_managed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.federation_configuration.cross_account_access_controlled",
    "assertion_id": "identity_access.federation.cross_account_access_controlled",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.federation_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for cross_account_access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.federation_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity cross_account_access_controlled implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for cross_account_access_controlled",
    "remediation": "Configure cloudidentity with security best practices for cross_account_access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.external_identity_conditions.external_idp_configured",
    "assertion_id": "identity_access.federation.external_idp_configured",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.external_identity_conditions",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for external_idp_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.external_identity_conditions",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager external_idp_configured implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for external_idp_configured",
    "remediation": "Configure accesscontextmanager with security best practices for external_idp_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.external_identity_conditions.trust_relationships_managed",
    "assertion_id": "identity_access.federation.trust_relationships_managed",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.external_identity_conditions",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for trust_relationships_managed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.external_identity_conditions",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager trust_relationships_managed implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for trust_relationships_managed",
    "remediation": "Configure accesscontextmanager with security best practices for trust_relationships_managed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.external_identity_conditions.cross_account_access_controlled",
    "assertion_id": "identity_access.federation.cross_account_access_controlled",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.external_identity_conditions",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for cross_account_access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.external_identity_conditions",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager cross_account_access_controlled implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for cross_account_access_controlled",
    "remediation": "Configure accesscontextmanager with security best practices for cross_account_access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.mfa_enforcement.enforced_for_privileged_users",
    "assertion_id": "identity_access.mfa.enforced_for_privileged_users",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.mfa_enforcement",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "privilege_threshold": "enum[admin,power_user,standard]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for enforced_for_privileged_users to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.mfa_enforcement",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam enforced_for_privileged_users implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for enforced_for_privileged_users",
    "remediation": "Configure iam with security best practices for enforced_for_privileged_users",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.mfa_enforcement.backup_methods_configured",
    "assertion_id": "identity_access.mfa.backup_methods_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.mfa_enforcement",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for backup_methods_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.mfa_enforcement",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam backup_methods_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for backup_methods_configured",
    "remediation": "Configure iam with security best practices for backup_methods_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.mfa_enforcement.hardware_tokens_required_for_privileged",
    "assertion_id": "identity_access.mfa.hardware_tokens_required_for_privileged",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.mfa_enforcement",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "privilege_threshold": "enum[admin,power_user]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for hardware_tokens_required_for_privileged to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.mfa_enforcement",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam hardware_tokens_required_for_privileged implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for hardware_tokens_required_for_privileged",
    "remediation": "Configure iam with security best practices for hardware_tokens_required_for_privileged",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.security_key_enforcement.enforced_for_privileged_users",
    "assertion_id": "identity_access.mfa.enforced_for_privileged_users",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.security_key_enforcement",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "privilege_threshold": "enum[admin,power_user,standard]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for enforced_for_privileged_users to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.security_key_enforcement",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam enforced_for_privileged_users implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for enforced_for_privileged_users",
    "remediation": "Configure iam with security best practices for enforced_for_privileged_users",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.security_key_enforcement.backup_methods_configured",
    "assertion_id": "identity_access.mfa.backup_methods_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.security_key_enforcement",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for backup_methods_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.security_key_enforcement",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam backup_methods_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for backup_methods_configured",
    "remediation": "Configure iam with security best practices for backup_methods_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.security_key_enforcement.hardware_tokens_required_for_privileged",
    "assertion_id": "identity_access.mfa.hardware_tokens_required_for_privileged",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.security_key_enforcement",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "privilege_threshold": "enum[admin,power_user]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for hardware_tokens_required_for_privileged to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.security_key_enforcement",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam hardware_tokens_required_for_privileged implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for hardware_tokens_required_for_privileged",
    "remediation": "Configure iam with security best practices for hardware_tokens_required_for_privileged",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.mfa_configuration.enforced_for_privileged_users",
    "assertion_id": "identity_access.mfa.enforced_for_privileged_users",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.mfa_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "privilege_threshold": "enum[admin,power_user,standard]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "cloudidentity must implement security controls for enforced_for_privileged_users to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.mfa_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity enforced_for_privileged_users implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for enforced_for_privileged_users",
    "remediation": "Configure cloudidentity with security best practices for enforced_for_privileged_users",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.mfa_configuration.backup_methods_configured",
    "assertion_id": "identity_access.mfa.backup_methods_configured",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.mfa_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "cloudidentity must implement security controls for backup_methods_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.mfa_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity backup_methods_configured implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for backup_methods_configured",
    "remediation": "Configure cloudidentity with security best practices for backup_methods_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.mfa_configuration.hardware_tokens_required_for_privileged",
    "assertion_id": "identity_access.mfa.hardware_tokens_required_for_privileged",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.mfa_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "privilege_threshold": "enum[admin,power_user]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "cloudidentity must implement security controls for hardware_tokens_required_for_privileged to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.mfa_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity hardware_tokens_required_for_privileged implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for hardware_tokens_required_for_privileged",
    "remediation": "Configure cloudidentity with security best practices for hardware_tokens_required_for_privileged",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.mfa_configuration.enforced_for_privileged_users",
    "assertion_id": "identity_access.mfa.enforced_for_privileged_users",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.mfa_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "privilege_threshold": "enum[admin,power_user,standard]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for enforced_for_privileged_users to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.mfa_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager enforced_for_privileged_users implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for enforced_for_privileged_users",
    "remediation": "Configure accesscontextmanager with security best practices for enforced_for_privileged_users",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.mfa_configuration.backup_methods_configured",
    "assertion_id": "identity_access.mfa.backup_methods_configured",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.mfa_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for backup_methods_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.mfa_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager backup_methods_configured implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for backup_methods_configured",
    "remediation": "Configure accesscontextmanager with security best practices for backup_methods_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.mfa_configuration.hardware_tokens_required_for_privileged",
    "assertion_id": "identity_access.mfa.hardware_tokens_required_for_privileged",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.mfa_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "privilege_threshold": "enum[admin,power_user]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for hardware_tokens_required_for_privileged to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.mfa_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager hardware_tokens_required_for_privileged implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for hardware_tokens_required_for_privileged",
    "remediation": "Configure accesscontextmanager with security best practices for hardware_tokens_required_for_privileged",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.session_duration_limits.session_duration_limited",
    "assertion_id": "identity_access.session_management.session_duration_limited",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.session_duration_limits",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for session_duration_limited to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.session_duration_limits",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam session_duration_limited implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for session_duration_limited",
    "remediation": "Configure iam with security best practices for session_duration_limited",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.session_duration_limits.temporary_credentials_controlled",
    "assertion_id": "identity_access.session_management.temporary_credentials_controlled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.session_duration_limits",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for temporary_credentials_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.session_duration_limits",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam temporary_credentials_controlled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for temporary_credentials_controlled",
    "remediation": "Configure iam with security best practices for temporary_credentials_controlled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.temporary_credentials_rotation.session_duration_limited",
    "assertion_id": "identity_access.session_management.session_duration_limited",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.temporary_credentials_rotation",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for session_duration_limited to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.temporary_credentials_rotation",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam session_duration_limited implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for session_duration_limited",
    "remediation": "Configure iam with security best practices for session_duration_limited",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.temporary_credentials_rotation.temporary_credentials_controlled",
    "assertion_id": "identity_access.session_management.temporary_credentials_controlled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.temporary_credentials_rotation",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for temporary_credentials_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.temporary_credentials_rotation",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam temporary_credentials_controlled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for temporary_credentials_controlled",
    "remediation": "Configure iam with security best practices for temporary_credentials_controlled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.session_management_configuration.session_duration_limited",
    "assertion_id": "identity_access.session_management.session_duration_limited",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.session_management_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "cloudidentity must implement security controls for session_duration_limited to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.session_management_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity session_duration_limited implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for session_duration_limited",
    "remediation": "Configure cloudidentity with security best practices for session_duration_limited",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.session_management_configuration.temporary_credentials_controlled",
    "assertion_id": "identity_access.session_management.temporary_credentials_controlled",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.session_management_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "cloudidentity must implement security controls for temporary_credentials_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.session_management_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity temporary_credentials_controlled implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for temporary_credentials_controlled",
    "remediation": "Configure cloudidentity with security best practices for temporary_credentials_controlled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.session_management_configuration.session_duration_limited",
    "assertion_id": "identity_access.session_management.session_duration_limited",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.session_management_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for session_duration_limited to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.session_management_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager session_duration_limited implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for session_duration_limited",
    "remediation": "Configure accesscontextmanager with security best practices for session_duration_limited",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.session_management_configuration.temporary_credentials_controlled",
    "assertion_id": "identity_access.session_management.temporary_credentials_controlled",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.session_management_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for temporary_credentials_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.session_management_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager temporary_credentials_controlled implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for temporary_credentials_controlled",
    "remediation": "Configure accesscontextmanager with security best practices for temporary_credentials_controlled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.role_definition_configuration.least_privilege_roles",
    "assertion_id": "rbac_entitlements.role_definition.least_privilege_roles",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.role_definition_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for least_privilege_roles to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.role_definition_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam least_privilege_roles implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for least_privilege_roles",
    "remediation": "Configure iam with security best practices for least_privilege_roles",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.role_definition_configuration.service_linked_roles_used",
    "assertion_id": "rbac_entitlements.role_definition.service_linked_roles_used",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.role_definition_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for service_linked_roles_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.role_definition_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam service_linked_roles_used implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for service_linked_roles_used",
    "remediation": "Configure iam with security best practices for service_linked_roles_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.role_definition_configuration.least_privilege_roles",
    "assertion_id": "rbac_entitlements.role_definition.least_privilege_roles",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.role_definition_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for least_privilege_roles to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.role_definition_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager least_privilege_roles implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for least_privilege_roles",
    "remediation": "Configure resourcemanager with security best practices for least_privilege_roles",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.role_definition_configuration.service_linked_roles_used",
    "assertion_id": "rbac_entitlements.role_definition.service_linked_roles_used",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.role_definition_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for service_linked_roles_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.role_definition_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager service_linked_roles_used implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for service_linked_roles_used",
    "remediation": "Configure resourcemanager with security best practices for service_linked_roles_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.role_definition_configuration.least_privilege_roles",
    "assertion_id": "rbac_entitlements.role_definition.least_privilege_roles",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.role_definition_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for least_privilege_roles to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.role_definition_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager least_privilege_roles implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for least_privilege_roles",
    "remediation": "Configure resourcemanager with security best practices for least_privilege_roles",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.role_definition_configuration.service_linked_roles_used",
    "assertion_id": "rbac_entitlements.role_definition.service_linked_roles_used",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.role_definition_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for service_linked_roles_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.role_definition_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager service_linked_roles_used implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for service_linked_roles_used",
    "remediation": "Configure resourcemanager with security best practices for service_linked_roles_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.role_assignment_configuration.principals_limited",
    "assertion_id": "rbac_entitlements.role_assignment.principals_limited",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.role_assignment_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for principals_limited to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.role_assignment_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam principals_limited implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for principals_limited",
    "remediation": "Configure iam with security best practices for principals_limited",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.role_assignment_configuration.just_in_time_access_enabled",
    "assertion_id": "rbac_entitlements.role_assignment.just_in_time_access_enabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.role_assignment_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for just_in_time_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.role_assignment_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam just_in_time_access_enabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for just_in_time_access_enabled",
    "remediation": "Configure iam with security best practices for just_in_time_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.role_assignment_configuration.principals_limited",
    "assertion_id": "rbac_entitlements.role_assignment.principals_limited",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.role_assignment_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for principals_limited to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.role_assignment_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager principals_limited implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for principals_limited",
    "remediation": "Configure resourcemanager with security best practices for principals_limited",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.role_assignment_configuration.just_in_time_access_enabled",
    "assertion_id": "rbac_entitlements.role_assignment.just_in_time_access_enabled",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.role_assignment_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for just_in_time_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.role_assignment_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager just_in_time_access_enabled implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for just_in_time_access_enabled",
    "remediation": "Configure resourcemanager with security best practices for just_in_time_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.role_assignment_configuration.principals_limited",
    "assertion_id": "rbac_entitlements.role_assignment.principals_limited",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.role_assignment_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for principals_limited to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.role_assignment_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager principals_limited implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for principals_limited",
    "remediation": "Configure resourcemanager with security best practices for principals_limited",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.role_assignment_configuration.just_in_time_access_enabled",
    "assertion_id": "rbac_entitlements.role_assignment.just_in_time_access_enabled",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.role_assignment_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for just_in_time_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.role_assignment_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager just_in_time_access_enabled implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for just_in_time_access_enabled",
    "remediation": "Configure resourcemanager with security best practices for just_in_time_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.least_privilege_configuration.access_reviews_conducted",
    "assertion_id": "rbac_entitlements.least_privilege.access_reviews_conducted",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.least_privilege_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "review_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for access_reviews_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.least_privilege_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam access_reviews_conducted implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for access_reviews_conducted",
    "remediation": "Configure iam with security best practices for access_reviews_conducted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.least_privilege_configuration.unused_permissions_removed",
    "assertion_id": "rbac_entitlements.least_privilege.unused_permissions_removed",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.least_privilege_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for unused_permissions_removed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.least_privilege_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam unused_permissions_removed implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for unused_permissions_removed",
    "remediation": "Configure iam with security best practices for unused_permissions_removed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.least_privilege_configuration.access_reviews_conducted",
    "assertion_id": "rbac_entitlements.least_privilege.access_reviews_conducted",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.least_privilege_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "review_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for access_reviews_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.least_privilege_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager access_reviews_conducted implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for access_reviews_conducted",
    "remediation": "Configure resourcemanager with security best practices for access_reviews_conducted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.least_privilege_configuration.unused_permissions_removed",
    "assertion_id": "rbac_entitlements.least_privilege.unused_permissions_removed",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.least_privilege_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for unused_permissions_removed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.least_privilege_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager unused_permissions_removed implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for unused_permissions_removed",
    "remediation": "Configure resourcemanager with security best practices for unused_permissions_removed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.least_privilege_configuration.access_reviews_conducted",
    "assertion_id": "rbac_entitlements.least_privilege.access_reviews_conducted",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.least_privilege_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "review_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for access_reviews_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.least_privilege_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager access_reviews_conducted implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for access_reviews_conducted",
    "remediation": "Configure resourcemanager with security best practices for access_reviews_conducted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.least_privilege_configuration.unused_permissions_removed",
    "assertion_id": "rbac_entitlements.least_privilege.unused_permissions_removed",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.least_privilege_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for unused_permissions_removed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.least_privilege_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager unused_permissions_removed implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for unused_permissions_removed",
    "remediation": "Configure resourcemanager with security best practices for unused_permissions_removed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.entitlement_management_configuration.lifecycle_managed",
    "assertion_id": "rbac_entitlements.entitlement_management.lifecycle_managed",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.entitlement_management_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for lifecycle_managed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.entitlement_management_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam lifecycle_managed implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for lifecycle_managed",
    "remediation": "Configure iam with security best practices for lifecycle_managed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.entitlement_management_configuration.temporary_access_controlled",
    "assertion_id": "rbac_entitlements.entitlement_management.temporary_access_controlled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.entitlement_management_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "max_temporary_duration_hours": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for temporary_access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.entitlement_management_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam temporary_access_controlled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for temporary_access_controlled",
    "remediation": "Configure iam with security best practices for temporary_access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.entitlement_management_configuration.lifecycle_managed",
    "assertion_id": "rbac_entitlements.entitlement_management.lifecycle_managed",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.entitlement_management_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for lifecycle_managed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.entitlement_management_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager lifecycle_managed implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for lifecycle_managed",
    "remediation": "Configure resourcemanager with security best practices for lifecycle_managed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.entitlement_management_configuration.temporary_access_controlled",
    "assertion_id": "rbac_entitlements.entitlement_management.temporary_access_controlled",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.entitlement_management_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "max_temporary_duration_hours": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for temporary_access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.entitlement_management_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager temporary_access_controlled implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for temporary_access_controlled",
    "remediation": "Configure resourcemanager with security best practices for temporary_access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.entitlement_management_configuration.lifecycle_managed",
    "assertion_id": "rbac_entitlements.entitlement_management.lifecycle_managed",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.entitlement_management_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for lifecycle_managed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.entitlement_management_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager lifecycle_managed implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for lifecycle_managed",
    "remediation": "Configure resourcemanager with security best practices for lifecycle_managed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.entitlement_management_configuration.temporary_access_controlled",
    "assertion_id": "rbac_entitlements.entitlement_management.temporary_access_controlled",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.entitlement_management_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "max_temporary_duration_hours": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for temporary_access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.entitlement_management_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager temporary_access_controlled implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for temporary_access_controlled",
    "remediation": "Configure resourcemanager with security best practices for temporary_access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_encryption_at_rest.encrypted_storage_enabled",
    "assertion_id": "secrets_key_mgmt.secret_storage.encrypted_storage_enabled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_encryption_at_rest",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for encrypted_storage_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_encryption_at_rest",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager encrypted_storage_enabled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for encrypted_storage_enabled",
    "remediation": "Configure secretmanager with security best practices for encrypted_storage_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_encryption_at_rest.access_controlled",
    "assertion_id": "secrets_key_mgmt.secret_storage.access_controlled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_encryption_at_rest",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_encryption_at_rest",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager access_controlled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for access_controlled",
    "remediation": "Configure secretmanager with security best practices for access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_access_control.encrypted_storage_enabled",
    "assertion_id": "secrets_key_mgmt.secret_storage.encrypted_storage_enabled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_access_control",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "secretmanager must implement security controls for encrypted_storage_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_access_control",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager encrypted_storage_enabled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for encrypted_storage_enabled",
    "remediation": "Configure secretmanager with security best practices for encrypted_storage_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_access_control.access_controlled",
    "assertion_id": "secrets_key_mgmt.secret_storage.access_controlled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_access_control",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "secretmanager must implement security controls for access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_access_control",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager access_controlled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for access_controlled",
    "remediation": "Configure secretmanager with security best practices for access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_rotation_policy.encrypted_storage_enabled",
    "assertion_id": "secrets_key_mgmt.secret_storage.encrypted_storage_enabled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_rotation_policy",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "secretmanager must implement security controls for encrypted_storage_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_rotation_policy",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager encrypted_storage_enabled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for encrypted_storage_enabled",
    "remediation": "Configure secretmanager with security best practices for encrypted_storage_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_rotation_policy.access_controlled",
    "assertion_id": "secrets_key_mgmt.secret_storage.access_controlled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_rotation_policy",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "secretmanager must implement security controls for access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_rotation_policy",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager access_controlled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for access_controlled",
    "remediation": "Configure secretmanager with security best practices for access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.secret_storage_configuration.encrypted_storage_enabled",
    "assertion_id": "secrets_key_mgmt.secret_storage.encrypted_storage_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.secret_storage_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "kms must implement security controls for encrypted_storage_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.secret_storage_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms encrypted_storage_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for encrypted_storage_enabled",
    "remediation": "Configure kms with security best practices for encrypted_storage_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.secret_storage_configuration.access_controlled",
    "assertion_id": "secrets_key_mgmt.secret_storage.access_controlled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.secret_storage_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "kms must implement security controls for access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.secret_storage_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms access_controlled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for access_controlled",
    "remediation": "Configure kms with security best practices for access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.automatic_rotation.automatic_rotation_enabled",
    "assertion_id": "secrets_key_mgmt.key_rotation.automatic_rotation_enabled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.automatic_rotation",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for automatic_rotation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.automatic_rotation",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager automatic_rotation_enabled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for automatic_rotation_enabled",
    "remediation": "Configure secretmanager with security best practices for automatic_rotation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.automatic_rotation.manual_rotation_scheduled",
    "assertion_id": "secrets_key_mgmt.key_rotation.manual_rotation_scheduled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.automatic_rotation",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for manual_rotation_scheduled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.automatic_rotation",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager manual_rotation_scheduled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for manual_rotation_scheduled",
    "remediation": "Configure secretmanager with security best practices for manual_rotation_scheduled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.rotation_schedule.automatic_rotation_enabled",
    "assertion_id": "secrets_key_mgmt.key_rotation.automatic_rotation_enabled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.rotation_schedule",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "secretmanager must implement security controls for automatic_rotation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.rotation_schedule",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager automatic_rotation_enabled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for automatic_rotation_enabled",
    "remediation": "Configure secretmanager with security best practices for automatic_rotation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.rotation_schedule.manual_rotation_scheduled",
    "assertion_id": "secrets_key_mgmt.key_rotation.manual_rotation_scheduled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.rotation_schedule",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "secretmanager must implement security controls for manual_rotation_scheduled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.rotation_schedule",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager manual_rotation_scheduled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for manual_rotation_scheduled",
    "remediation": "Configure secretmanager with security best practices for manual_rotation_scheduled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.key_rotation_configuration.automatic_rotation_enabled",
    "assertion_id": "secrets_key_mgmt.key_rotation.automatic_rotation_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.key_rotation_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "kms must implement security controls for automatic_rotation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key_rotation_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms automatic_rotation_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for automatic_rotation_enabled",
    "remediation": "Configure kms with security best practices for automatic_rotation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.key_rotation_configuration.manual_rotation_scheduled",
    "assertion_id": "secrets_key_mgmt.key_rotation.manual_rotation_scheduled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.key_rotation_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "kms must implement security controls for manual_rotation_scheduled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key_rotation_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms manual_rotation_scheduled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for manual_rotation_scheduled",
    "remediation": "Configure kms with security best practices for manual_rotation_scheduled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.key_protection_configuration.hsm_protection_enabled",
    "assertion_id": "secrets_key_mgmt.key_protection.hsm_protection_enabled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.key_protection_configuration",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for hsm_protection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.key_protection_configuration",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager hsm_protection_enabled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for hsm_protection_enabled",
    "remediation": "Configure secretmanager with security best practices for hsm_protection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.key_protection_configuration.key_access_logged",
    "assertion_id": "secrets_key_mgmt.key_protection.key_access_logged",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.key_protection_configuration",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for key_access_logged to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.key_protection_configuration",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager key_access_logged implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for key_access_logged",
    "remediation": "Configure secretmanager with security best practices for key_access_logged",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.key_protection_configuration.hsm_protection_enabled",
    "assertion_id": "secrets_key_mgmt.key_protection.hsm_protection_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.key_protection_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for hsm_protection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key_protection_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms hsm_protection_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for hsm_protection_enabled",
    "remediation": "Configure kms with security best practices for hsm_protection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.key_protection_configuration.key_access_logged",
    "assertion_id": "secrets_key_mgmt.key_protection.key_access_logged",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.key_protection_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for key_access_logged to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key_protection_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms key_access_logged implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for key_access_logged",
    "remediation": "Configure kms with security best practices for key_access_logged",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_retrieval_configuration.secure_injection_enabled",
    "assertion_id": "secrets_key_mgmt.secret_retrieval.secure_injection_enabled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_retrieval_configuration",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for secure_injection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_retrieval_configuration",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager secure_injection_enabled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for secure_injection_enabled",
    "remediation": "Configure secretmanager with security best practices for secure_injection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_retrieval_configuration.workload_identity_used",
    "assertion_id": "secrets_key_mgmt.secret_retrieval.workload_identity_used",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_retrieval_configuration",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for workload_identity_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_retrieval_configuration",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager workload_identity_used implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for workload_identity_used",
    "remediation": "Configure secretmanager with security best practices for workload_identity_used",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.secret_retrieval_configuration.secure_injection_enabled",
    "assertion_id": "secrets_key_mgmt.secret_retrieval.secure_injection_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.secret_retrieval_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for secure_injection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.secret_retrieval_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms secure_injection_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for secure_injection_enabled",
    "remediation": "Configure kms with security best practices for secure_injection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.secret_retrieval_configuration.workload_identity_used",
    "assertion_id": "secrets_key_mgmt.secret_retrieval.workload_identity_used",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.secret_retrieval_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for workload_identity_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.secret_retrieval_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms workload_identity_used implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for workload_identity_used",
    "remediation": "Configure kms with security best practices for workload_identity_used",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.customer_managed_encryption.default_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.default_encryption_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.customer_managed_encryption",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for default_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.customer_managed_encryption",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms default_encryption_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for default_encryption_enabled",
    "remediation": "Configure kms with security best practices for default_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.customer_managed_encryption.customer_managed_keys_used_buckets",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_buckets",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.customer_managed_encryption",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for customer_managed_keys_used_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.customer_managed_encryption",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms customer_managed_keys_used_buckets implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for customer_managed_keys_used_buckets",
    "remediation": "Configure kms with security best practices for customer_managed_keys_used_buckets",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.customer_managed_encryption.customer_managed_keys_used_databases",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_databases",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.customer_managed_encryption",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for customer_managed_keys_used_databases to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.customer_managed_encryption",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms customer_managed_keys_used_databases implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for customer_managed_keys_used_databases",
    "remediation": "Configure kms with security best practices for customer_managed_keys_used_databases",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.customer_managed_encryption.customer_managed_keys_used_disks",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_disks",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.customer_managed_encryption",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for customer_managed_keys_used_disks to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.customer_managed_encryption",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms customer_managed_keys_used_disks implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for customer_managed_keys_used_disks",
    "remediation": "Configure kms with security best practices for customer_managed_keys_used_disks",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.customer_managed_encryption.database_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.database_encryption_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.customer_managed_encryption",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for database_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.customer_managed_encryption",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms database_encryption_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for database_encryption_enabled",
    "remediation": "Configure kms with security best practices for database_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.customer_managed_encryption.volume_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.volume_encryption_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.customer_managed_encryption",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for volume_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.customer_managed_encryption",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms volume_encryption_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for volume_encryption_enabled",
    "remediation": "Configure kms with security best practices for volume_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.encryption_key_usage.default_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.default_encryption_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.encryption_key_usage",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for default_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.encryption_key_usage",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms default_encryption_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for default_encryption_enabled",
    "remediation": "Configure kms with security best practices for default_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.encryption_key_usage.customer_managed_keys_used_buckets",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_buckets",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.encryption_key_usage",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for customer_managed_keys_used_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.encryption_key_usage",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms customer_managed_keys_used_buckets implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for customer_managed_keys_used_buckets",
    "remediation": "Configure kms with security best practices for customer_managed_keys_used_buckets",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.encryption_key_usage.customer_managed_keys_used_databases",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_databases",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.encryption_key_usage",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for customer_managed_keys_used_databases to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.encryption_key_usage",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms customer_managed_keys_used_databases implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for customer_managed_keys_used_databases",
    "remediation": "Configure kms with security best practices for customer_managed_keys_used_databases",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.encryption_key_usage.customer_managed_keys_used_disks",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_disks",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.encryption_key_usage",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for customer_managed_keys_used_disks to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.encryption_key_usage",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms customer_managed_keys_used_disks implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for customer_managed_keys_used_disks",
    "remediation": "Configure kms with security best practices for customer_managed_keys_used_disks",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.encryption_key_usage.database_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.database_encryption_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.encryption_key_usage",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for database_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.encryption_key_usage",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms database_encryption_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for database_encryption_enabled",
    "remediation": "Configure kms with security best practices for database_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.encryption_key_usage.volume_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.volume_encryption_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.encryption_key_usage",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for volume_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.encryption_key_usage",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms volume_encryption_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for volume_encryption_enabled",
    "remediation": "Configure kms with security best practices for volume_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_encryption_default.default_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.default_encryption_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_encryption_default",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for default_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_encryption_default",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage default_encryption_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for default_encryption_enabled",
    "remediation": "Configure storage with security best practices for default_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_encryption_default.customer_managed_keys_used_buckets",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_buckets",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_encryption_default",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for customer_managed_keys_used_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_encryption_default",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage customer_managed_keys_used_buckets implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for customer_managed_keys_used_buckets",
    "remediation": "Configure storage with security best practices for customer_managed_keys_used_buckets",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_encryption_default.customer_managed_keys_used_databases",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_databases",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_encryption_default",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for customer_managed_keys_used_databases to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_encryption_default",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage customer_managed_keys_used_databases implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for customer_managed_keys_used_databases",
    "remediation": "Configure storage with security best practices for customer_managed_keys_used_databases",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_encryption_default.customer_managed_keys_used_disks",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_disks",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_encryption_default",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for customer_managed_keys_used_disks to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_encryption_default",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage customer_managed_keys_used_disks implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for customer_managed_keys_used_disks",
    "remediation": "Configure storage with security best practices for customer_managed_keys_used_disks",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_encryption_default.database_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.database_encryption_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_encryption_default",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for database_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_encryption_default",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage database_encryption_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for database_encryption_enabled",
    "remediation": "Configure storage with security best practices for database_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_encryption_default.volume_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.volume_encryption_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_encryption_default",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for volume_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_encryption_default",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage volume_encryption_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for volume_encryption_enabled",
    "remediation": "Configure storage with security best practices for volume_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_customer_managed_encryption.default_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.default_encryption_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_customer_managed_encryption",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for default_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_customer_managed_encryption",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage default_encryption_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for default_encryption_enabled",
    "remediation": "Configure storage with security best practices for default_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_customer_managed_encryption.customer_managed_keys_used_buckets",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_buckets",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_customer_managed_encryption",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for customer_managed_keys_used_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_customer_managed_encryption",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage customer_managed_keys_used_buckets implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for customer_managed_keys_used_buckets",
    "remediation": "Configure storage with security best practices for customer_managed_keys_used_buckets",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_customer_managed_encryption.customer_managed_keys_used_databases",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_databases",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_customer_managed_encryption",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for customer_managed_keys_used_databases to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_customer_managed_encryption",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage customer_managed_keys_used_databases implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for customer_managed_keys_used_databases",
    "remediation": "Configure storage with security best practices for customer_managed_keys_used_databases",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_customer_managed_encryption.customer_managed_keys_used_disks",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_disks",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_customer_managed_encryption",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for customer_managed_keys_used_disks to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_customer_managed_encryption",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage customer_managed_keys_used_disks implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for customer_managed_keys_used_disks",
    "remediation": "Configure storage with security best practices for customer_managed_keys_used_disks",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_customer_managed_encryption.database_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.database_encryption_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_customer_managed_encryption",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for database_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_customer_managed_encryption",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage database_encryption_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for database_encryption_enabled",
    "remediation": "Configure storage with security best practices for database_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_customer_managed_encryption.volume_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.volume_encryption_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_customer_managed_encryption",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for volume_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_customer_managed_encryption",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage volume_encryption_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for volume_encryption_enabled",
    "remediation": "Configure storage with security best practices for volume_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_encryption_key.default_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.default_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_encryption_key",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for default_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_encryption_key",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute default_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for default_encryption_enabled",
    "remediation": "Configure compute with security best practices for default_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_encryption_key.customer_managed_keys_used_buckets",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_buckets",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_encryption_key",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for customer_managed_keys_used_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_encryption_key",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute customer_managed_keys_used_buckets implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for customer_managed_keys_used_buckets",
    "remediation": "Configure compute with security best practices for customer_managed_keys_used_buckets",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_encryption_key.customer_managed_keys_used_databases",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_databases",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_encryption_key",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for customer_managed_keys_used_databases to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_encryption_key",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute customer_managed_keys_used_databases implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for customer_managed_keys_used_databases",
    "remediation": "Configure compute with security best practices for customer_managed_keys_used_databases",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_encryption_key.customer_managed_keys_used_disks",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_disks",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_encryption_key",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for customer_managed_keys_used_disks to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_encryption_key",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute customer_managed_keys_used_disks implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for customer_managed_keys_used_disks",
    "remediation": "Configure compute with security best practices for customer_managed_keys_used_disks",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_encryption_key.database_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.database_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_encryption_key",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for database_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_encryption_key",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute database_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for database_encryption_enabled",
    "remediation": "Configure compute with security best practices for database_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_encryption_key.volume_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.volume_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_encryption_key",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for volume_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_encryption_key",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute volume_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for volume_encryption_enabled",
    "remediation": "Configure compute with security best practices for volume_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_customer_managed_encryption.default_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.default_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_customer_managed_encryption",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for default_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_customer_managed_encryption",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute default_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for default_encryption_enabled",
    "remediation": "Configure compute with security best practices for default_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_customer_managed_encryption.customer_managed_keys_used_buckets",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_buckets",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_customer_managed_encryption",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for customer_managed_keys_used_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_customer_managed_encryption",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute customer_managed_keys_used_buckets implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for customer_managed_keys_used_buckets",
    "remediation": "Configure compute with security best practices for customer_managed_keys_used_buckets",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_customer_managed_encryption.customer_managed_keys_used_databases",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_databases",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_customer_managed_encryption",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for customer_managed_keys_used_databases to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_customer_managed_encryption",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute customer_managed_keys_used_databases implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for customer_managed_keys_used_databases",
    "remediation": "Configure compute with security best practices for customer_managed_keys_used_databases",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_customer_managed_encryption.customer_managed_keys_used_disks",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_disks",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_customer_managed_encryption",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for customer_managed_keys_used_disks to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_customer_managed_encryption",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute customer_managed_keys_used_disks implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for customer_managed_keys_used_disks",
    "remediation": "Configure compute with security best practices for customer_managed_keys_used_disks",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_customer_managed_encryption.database_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.database_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_customer_managed_encryption",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for database_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_customer_managed_encryption",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute database_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for database_encryption_enabled",
    "remediation": "Configure compute with security best practices for database_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_customer_managed_encryption.volume_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.volume_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_customer_managed_encryption",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for volume_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_customer_managed_encryption",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute volume_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for volume_encryption_enabled",
    "remediation": "Configure compute with security best practices for volume_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.encryption_at_rest_configuration.default_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.default_encryption_enabled",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for default_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.encryption_at_rest_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database default_encryption_enabled implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for default_encryption_enabled",
    "remediation": "Configure database with security best practices for default_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.encryption_at_rest_configuration.customer_managed_keys_used_buckets",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_buckets",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for customer_managed_keys_used_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.encryption_at_rest_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database customer_managed_keys_used_buckets implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for customer_managed_keys_used_buckets",
    "remediation": "Configure database with security best practices for customer_managed_keys_used_buckets",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.encryption_at_rest_configuration.customer_managed_keys_used_databases",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_databases",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for customer_managed_keys_used_databases to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.encryption_at_rest_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database customer_managed_keys_used_databases implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for customer_managed_keys_used_databases",
    "remediation": "Configure database with security best practices for customer_managed_keys_used_databases",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.encryption_at_rest_configuration.customer_managed_keys_used_disks",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_disks",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for customer_managed_keys_used_disks to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.encryption_at_rest_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database customer_managed_keys_used_disks implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for customer_managed_keys_used_disks",
    "remediation": "Configure database with security best practices for customer_managed_keys_used_disks",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.encryption_at_rest_configuration.database_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.database_encryption_enabled",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for database_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.encryption_at_rest_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database database_encryption_enabled implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for database_encryption_enabled",
    "remediation": "Configure database with security best practices for database_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.encryption_at_rest_configuration.volume_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.volume_encryption_enabled",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for volume_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.encryption_at_rest_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database volume_encryption_enabled implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for volume_encryption_enabled",
    "remediation": "Configure database with security best practices for volume_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.encryption_at_rest_configuration.default_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.default_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for default_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.encryption_at_rest_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute default_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for default_encryption_enabled",
    "remediation": "Configure compute with security best practices for default_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.encryption_at_rest_configuration.customer_managed_keys_used_buckets",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_buckets",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for customer_managed_keys_used_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.encryption_at_rest_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute customer_managed_keys_used_buckets implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for customer_managed_keys_used_buckets",
    "remediation": "Configure compute with security best practices for customer_managed_keys_used_buckets",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.encryption_at_rest_configuration.customer_managed_keys_used_databases",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_databases",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for customer_managed_keys_used_databases to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.encryption_at_rest_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute customer_managed_keys_used_databases implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for customer_managed_keys_used_databases",
    "remediation": "Configure compute with security best practices for customer_managed_keys_used_databases",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.encryption_at_rest_configuration.customer_managed_keys_used_disks",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_disks",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for customer_managed_keys_used_disks to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.encryption_at_rest_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute customer_managed_keys_used_disks implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for customer_managed_keys_used_disks",
    "remediation": "Configure compute with security best practices for customer_managed_keys_used_disks",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.encryption_at_rest_configuration.database_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.database_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for database_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.encryption_at_rest_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute database_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for database_encryption_enabled",
    "remediation": "Configure compute with security best practices for database_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.encryption_at_rest_configuration.volume_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.volume_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for volume_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.encryption_at_rest_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute volume_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for volume_encryption_enabled",
    "remediation": "Configure compute with security best practices for volume_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.encryption_in_transit_configuration.tls_enforced",
    "assertion_id": "crypto_data_protection.encryption_in_transit.tls_enforced",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_tls_version": "enum[tls1.2,tls1.3]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for tls_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.encryption_in_transit_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms tls_enforced implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for tls_enforced",
    "remediation": "Configure kms with security best practices for tls_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.encryption_in_transit_configuration.mtls_enabled",
    "assertion_id": "crypto_data_protection.encryption_in_transit.mtls_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for mtls_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.encryption_in_transit_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms mtls_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for mtls_enabled",
    "remediation": "Configure kms with security best practices for mtls_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.encryption_in_transit_configuration.private_endpoints_used",
    "assertion_id": "crypto_data_protection.encryption_in_transit.private_endpoints_used",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for private_endpoints_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.encryption_in_transit_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms private_endpoints_used implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for private_endpoints_used",
    "remediation": "Configure kms with security best practices for private_endpoints_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.encryption_in_transit_configuration.tls_enforced",
    "assertion_id": "crypto_data_protection.encryption_in_transit.tls_enforced",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_tls_version": "enum[tls1.2,tls1.3]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for tls_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.encryption_in_transit_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage tls_enforced implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for tls_enforced",
    "remediation": "Configure storage with security best practices for tls_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.encryption_in_transit_configuration.mtls_enabled",
    "assertion_id": "crypto_data_protection.encryption_in_transit.mtls_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for mtls_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.encryption_in_transit_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage mtls_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for mtls_enabled",
    "remediation": "Configure storage with security best practices for mtls_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.encryption_in_transit_configuration.private_endpoints_used",
    "assertion_id": "crypto_data_protection.encryption_in_transit.private_endpoints_used",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for private_endpoints_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.encryption_in_transit_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage private_endpoints_used implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for private_endpoints_used",
    "remediation": "Configure storage with security best practices for private_endpoints_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.encryption_in_transit_configuration.tls_enforced",
    "assertion_id": "crypto_data_protection.encryption_in_transit.tls_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_tls_version": "enum[tls1.2,tls1.3]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for tls_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.encryption_in_transit_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute tls_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for tls_enforced",
    "remediation": "Configure compute with security best practices for tls_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.encryption_in_transit_configuration.mtls_enabled",
    "assertion_id": "crypto_data_protection.encryption_in_transit.mtls_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for mtls_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.encryption_in_transit_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute mtls_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for mtls_enabled",
    "remediation": "Configure compute with security best practices for mtls_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.encryption_in_transit_configuration.private_endpoints_used",
    "assertion_id": "crypto_data_protection.encryption_in_transit.private_endpoints_used",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for private_endpoints_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.encryption_in_transit_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_endpoints_used implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_endpoints_used",
    "remediation": "Configure compute with security best practices for private_endpoints_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.encryption_in_transit_configuration.tls_enforced",
    "assertion_id": "crypto_data_protection.encryption_in_transit.tls_enforced",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_tls_version": "enum[tls1.2,tls1.3]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for tls_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.encryption_in_transit_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database tls_enforced implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for tls_enforced",
    "remediation": "Configure database with security best practices for tls_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.encryption_in_transit_configuration.mtls_enabled",
    "assertion_id": "crypto_data_protection.encryption_in_transit.mtls_enabled",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for mtls_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.encryption_in_transit_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database mtls_enabled implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for mtls_enabled",
    "remediation": "Configure database with security best practices for mtls_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.encryption_in_transit_configuration.private_endpoints_used",
    "assertion_id": "crypto_data_protection.encryption_in_transit.private_endpoints_used",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for private_endpoints_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.encryption_in_transit_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database private_endpoints_used implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for private_endpoints_used",
    "remediation": "Configure database with security best practices for private_endpoints_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.encryption_in_transit_configuration.tls_enforced",
    "assertion_id": "crypto_data_protection.encryption_in_transit.tls_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_tls_version": "enum[tls1.2,tls1.3]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for tls_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.encryption_in_transit_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute tls_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for tls_enforced",
    "remediation": "Configure compute with security best practices for tls_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.encryption_in_transit_configuration.mtls_enabled",
    "assertion_id": "crypto_data_protection.encryption_in_transit.mtls_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for mtls_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.encryption_in_transit_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute mtls_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for mtls_enabled",
    "remediation": "Configure compute with security best practices for mtls_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.encryption_in_transit_configuration.private_endpoints_used",
    "assertion_id": "crypto_data_protection.encryption_in_transit.private_endpoints_used",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for private_endpoints_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.encryption_in_transit_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_endpoints_used implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_endpoints_used",
    "remediation": "Configure compute with security best practices for private_endpoints_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.key_rotation_policy.kms_configured",
    "assertion_id": "crypto_data_protection.key_management.kms_configured",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.key_rotation_policy",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for kms_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key_rotation_policy",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms kms_configured implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for kms_configured",
    "remediation": "Configure kms with security best practices for kms_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.key_rotation_policy.key_policies_enforced",
    "assertion_id": "crypto_data_protection.key_management.key_policies_enforced",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.key_rotation_policy",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for key_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key_rotation_policy",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms key_policies_enforced implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for key_policies_enforced",
    "remediation": "Configure kms with security best practices for key_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.key_protection_level.kms_configured",
    "assertion_id": "crypto_data_protection.key_management.kms_configured",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.key_protection_level",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for kms_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key_protection_level",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms kms_configured implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for kms_configured",
    "remediation": "Configure kms with security best practices for kms_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.key_protection_level.key_policies_enforced",
    "assertion_id": "crypto_data_protection.key_management.key_policies_enforced",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.key_protection_level",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for key_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key_protection_level",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms key_policies_enforced implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for key_policies_enforced",
    "remediation": "Configure kms with security best practices for key_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.crypto_key_access_control.kms_configured",
    "assertion_id": "crypto_data_protection.key_management.kms_configured",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.crypto_key_access_control",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for kms_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.crypto_key_access_control",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms kms_configured implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for kms_configured",
    "remediation": "Configure kms with security best practices for kms_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.crypto_key_access_control.key_policies_enforced",
    "assertion_id": "crypto_data_protection.key_management.key_policies_enforced",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.crypto_key_access_control",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for key_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.crypto_key_access_control",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms key_policies_enforced implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for key_policies_enforced",
    "remediation": "Configure kms with security best practices for key_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.key_management_configuration.kms_configured",
    "assertion_id": "crypto_data_protection.key_management.kms_configured",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.key_management_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for kms_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.key_management_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage kms_configured implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for kms_configured",
    "remediation": "Configure storage with security best practices for kms_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.key_management_configuration.key_policies_enforced",
    "assertion_id": "crypto_data_protection.key_management.key_policies_enforced",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.key_management_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for key_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.key_management_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage key_policies_enforced implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for key_policies_enforced",
    "remediation": "Configure storage with security best practices for key_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.key_management_configuration.kms_configured",
    "assertion_id": "crypto_data_protection.key_management.kms_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.key_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for kms_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.key_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute kms_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for kms_configured",
    "remediation": "Configure compute with security best practices for kms_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.key_management_configuration.key_policies_enforced",
    "assertion_id": "crypto_data_protection.key_management.key_policies_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.key_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for key_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.key_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute key_policies_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for key_policies_enforced",
    "remediation": "Configure compute with security best practices for key_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.key_management_configuration.kms_configured",
    "assertion_id": "crypto_data_protection.key_management.kms_configured",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.key_management_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for kms_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.key_management_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database kms_configured implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for kms_configured",
    "remediation": "Configure database with security best practices for kms_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.key_management_configuration.key_policies_enforced",
    "assertion_id": "crypto_data_protection.key_management.key_policies_enforced",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.key_management_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for key_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.key_management_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database key_policies_enforced implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for key_policies_enforced",
    "remediation": "Configure database with security best practices for key_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.key_management_configuration.kms_configured",
    "assertion_id": "crypto_data_protection.key_management.kms_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.key_management_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for kms_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.key_management_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute kms_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for kms_configured",
    "remediation": "Configure compute with security best practices for kms_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.key_management_configuration.key_policies_enforced",
    "assertion_id": "crypto_data_protection.key_management.key_policies_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.key_management_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for key_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.key_management_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute key_policies_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for key_policies_enforced",
    "remediation": "Configure compute with security best practices for key_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.certificate_management_configuration.auto_renewal_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.auto_renewal_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.certificate_management_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for auto_renewal_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.certificate_management_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms auto_renewal_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for auto_renewal_enabled",
    "remediation": "Configure kms with security best practices for auto_renewal_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.certificate_management_configuration.certificate_validation_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.certificate_validation_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.certificate_management_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for certificate_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.certificate_management_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms certificate_validation_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for certificate_validation_enabled",
    "remediation": "Configure kms with security best practices for certificate_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.certificate_management_configuration.auto_renewal_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.auto_renewal_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.certificate_management_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for auto_renewal_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.certificate_management_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage auto_renewal_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for auto_renewal_enabled",
    "remediation": "Configure storage with security best practices for auto_renewal_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.certificate_management_configuration.certificate_validation_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.certificate_validation_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.certificate_management_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for certificate_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.certificate_management_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage certificate_validation_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for certificate_validation_enabled",
    "remediation": "Configure storage with security best practices for certificate_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.certificate_management_configuration.auto_renewal_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.auto_renewal_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.certificate_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for auto_renewal_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.certificate_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute auto_renewal_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for auto_renewal_enabled",
    "remediation": "Configure compute with security best practices for auto_renewal_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.certificate_management_configuration.certificate_validation_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.certificate_validation_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.certificate_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for certificate_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.certificate_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute certificate_validation_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for certificate_validation_enabled",
    "remediation": "Configure compute with security best practices for certificate_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.certificate_management_configuration.auto_renewal_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.auto_renewal_enabled",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.certificate_management_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for auto_renewal_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.certificate_management_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database auto_renewal_enabled implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for auto_renewal_enabled",
    "remediation": "Configure database with security best practices for auto_renewal_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.certificate_management_configuration.certificate_validation_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.certificate_validation_enabled",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.certificate_management_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for certificate_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.certificate_management_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database certificate_validation_enabled implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for certificate_validation_enabled",
    "remediation": "Configure database with security best practices for certificate_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.certificate_management_configuration.auto_renewal_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.auto_renewal_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.certificate_management_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for auto_renewal_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.certificate_management_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute auto_renewal_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for auto_renewal_enabled",
    "remediation": "Configure compute with security best practices for auto_renewal_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.certificate_management_configuration.certificate_validation_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.certificate_validation_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.certificate_management_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for certificate_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.certificate_management_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute certificate_validation_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for certificate_validation_enabled",
    "remediation": "Configure compute with security best practices for certificate_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.crypto_policies_configuration.algorithm_standards_enforced",
    "assertion_id": "crypto_data_protection.crypto_policies.algorithm_standards_enforced",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "min_key_size_bits": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for algorithm_standards_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.crypto_policies_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms algorithm_standards_enforced implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for algorithm_standards_enforced",
    "remediation": "Configure kms with security best practices for algorithm_standards_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.crypto_policies_configuration.compliance_standards_met",
    "assertion_id": "crypto_data_protection.crypto_policies.compliance_standards_met",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for compliance_standards_met to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.crypto_policies_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms compliance_standards_met implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for compliance_standards_met",
    "remediation": "Configure kms with security best practices for compliance_standards_met",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.crypto_policies_configuration.algorithm_standards_enforced",
    "assertion_id": "crypto_data_protection.crypto_policies.algorithm_standards_enforced",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "min_key_size_bits": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for algorithm_standards_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.crypto_policies_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage algorithm_standards_enforced implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for algorithm_standards_enforced",
    "remediation": "Configure storage with security best practices for algorithm_standards_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.crypto_policies_configuration.compliance_standards_met",
    "assertion_id": "crypto_data_protection.crypto_policies.compliance_standards_met",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for compliance_standards_met to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.crypto_policies_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage compliance_standards_met implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for compliance_standards_met",
    "remediation": "Configure storage with security best practices for compliance_standards_met",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.crypto_policies_configuration.algorithm_standards_enforced",
    "assertion_id": "crypto_data_protection.crypto_policies.algorithm_standards_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "min_key_size_bits": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for algorithm_standards_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.crypto_policies_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute algorithm_standards_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for algorithm_standards_enforced",
    "remediation": "Configure compute with security best practices for algorithm_standards_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.crypto_policies_configuration.compliance_standards_met",
    "assertion_id": "crypto_data_protection.crypto_policies.compliance_standards_met",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for compliance_standards_met to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.crypto_policies_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute compliance_standards_met implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for compliance_standards_met",
    "remediation": "Configure compute with security best practices for compliance_standards_met",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.crypto_policies_configuration.algorithm_standards_enforced",
    "assertion_id": "crypto_data_protection.crypto_policies.algorithm_standards_enforced",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "min_key_size_bits": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for algorithm_standards_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.crypto_policies_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database algorithm_standards_enforced implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for algorithm_standards_enforced",
    "remediation": "Configure database with security best practices for algorithm_standards_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.crypto_policies_configuration.compliance_standards_met",
    "assertion_id": "crypto_data_protection.crypto_policies.compliance_standards_met",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for compliance_standards_met to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.crypto_policies_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database compliance_standards_met implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for compliance_standards_met",
    "remediation": "Configure database with security best practices for compliance_standards_met",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.crypto_policies_configuration.algorithm_standards_enforced",
    "assertion_id": "crypto_data_protection.crypto_policies.algorithm_standards_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "min_key_size_bits": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for algorithm_standards_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.crypto_policies_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute algorithm_standards_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for algorithm_standards_enforced",
    "remediation": "Configure compute with security best practices for algorithm_standards_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.crypto_policies_configuration.compliance_standards_met",
    "assertion_id": "crypto_data_protection.crypto_policies.compliance_standards_met",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for compliance_standards_met to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.crypto_policies_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute compliance_standards_met implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for compliance_standards_met",
    "remediation": "Configure compute with security best practices for compliance_standards_met",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.data_classification_configuration.sensitivity_labels_applied",
    "assertion_id": "data_protection_storage.data_classification.sensitivity_labels_applied",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.data_classification_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for sensitivity_labels_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.data_classification_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage sensitivity_labels_applied implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for sensitivity_labels_applied",
    "remediation": "Configure storage with security best practices for sensitivity_labels_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.data_classification_configuration.automatic_classification_enabled",
    "assertion_id": "data_protection_storage.data_classification.automatic_classification_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.data_classification_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for automatic_classification_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.data_classification_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage automatic_classification_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for automatic_classification_enabled",
    "remediation": "Configure storage with security best practices for automatic_classification_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.data_classification_configuration.sensitivity_labels_applied",
    "assertion_id": "data_protection_storage.data_classification.sensitivity_labels_applied",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.data_classification_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for sensitivity_labels_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.data_classification_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute sensitivity_labels_applied implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for sensitivity_labels_applied",
    "remediation": "Configure compute with security best practices for sensitivity_labels_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.data_classification_configuration.automatic_classification_enabled",
    "assertion_id": "data_protection_storage.data_classification.automatic_classification_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.data_classification_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for automatic_classification_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.data_classification_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute automatic_classification_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for automatic_classification_enabled",
    "remediation": "Configure compute with security best practices for automatic_classification_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.data_classification_configuration.sensitivity_labels_applied",
    "assertion_id": "data_protection_storage.data_classification.sensitivity_labels_applied",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.data_classification_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for sensitivity_labels_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.data_classification_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute sensitivity_labels_applied implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for sensitivity_labels_applied",
    "remediation": "Configure compute with security best practices for sensitivity_labels_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.data_classification_configuration.automatic_classification_enabled",
    "assertion_id": "data_protection_storage.data_classification.automatic_classification_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.data_classification_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for automatic_classification_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.data_classification_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute automatic_classification_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for automatic_classification_enabled",
    "remediation": "Configure compute with security best practices for automatic_classification_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.sensitive_data_detection.sensitivity_labels_applied",
    "assertion_id": "data_protection_storage.data_classification.sensitivity_labels_applied",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.sensitive_data_detection",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for sensitivity_labels_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.sensitive_data_detection",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute sensitivity_labels_applied implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for sensitivity_labels_applied",
    "remediation": "Configure compute with security best practices for sensitivity_labels_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.sensitive_data_detection.automatic_classification_enabled",
    "assertion_id": "data_protection_storage.data_classification.automatic_classification_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.sensitive_data_detection",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for automatic_classification_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.sensitive_data_detection",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute automatic_classification_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for automatic_classification_enabled",
    "remediation": "Configure compute with security best practices for automatic_classification_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.data_classification_labels.sensitivity_labels_applied",
    "assertion_id": "data_protection_storage.data_classification.sensitivity_labels_applied",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.data_classification_labels",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for sensitivity_labels_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.data_classification_labels",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute sensitivity_labels_applied implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for sensitivity_labels_applied",
    "remediation": "Configure compute with security best practices for sensitivity_labels_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.data_classification_labels.automatic_classification_enabled",
    "assertion_id": "data_protection_storage.data_classification.automatic_classification_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.data_classification_labels",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for automatic_classification_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.data_classification_labels",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute automatic_classification_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for automatic_classification_enabled",
    "remediation": "Configure compute with security best practices for automatic_classification_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.data_retention_configuration.retention_policies_enforced",
    "assertion_id": "data_protection_storage.data_retention.retention_policies_enforced",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.data_retention_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for retention_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.data_retention_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage retention_policies_enforced implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for retention_policies_enforced",
    "remediation": "Configure storage with security best practices for retention_policies_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.data_retention_configuration.secure_deletion_enabled",
    "assertion_id": "data_protection_storage.data_retention.secure_deletion_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.data_retention_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for secure_deletion_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.data_retention_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage secure_deletion_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for secure_deletion_enabled",
    "remediation": "Configure storage with security best practices for secure_deletion_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.data_retention_configuration.retention_policies_enforced",
    "assertion_id": "data_protection_storage.data_retention.retention_policies_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.data_retention_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for retention_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.data_retention_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute retention_policies_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for retention_policies_enforced",
    "remediation": "Configure compute with security best practices for retention_policies_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.data_retention_configuration.secure_deletion_enabled",
    "assertion_id": "data_protection_storage.data_retention.secure_deletion_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.data_retention_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for secure_deletion_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.data_retention_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute secure_deletion_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for secure_deletion_enabled",
    "remediation": "Configure compute with security best practices for secure_deletion_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.data_retention_configuration.retention_policies_enforced",
    "assertion_id": "data_protection_storage.data_retention.retention_policies_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.data_retention_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for retention_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.data_retention_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute retention_policies_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for retention_policies_enforced",
    "remediation": "Configure compute with security best practices for retention_policies_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.data_retention_configuration.secure_deletion_enabled",
    "assertion_id": "data_protection_storage.data_retention.secure_deletion_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.data_retention_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for secure_deletion_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.data_retention_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute secure_deletion_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for secure_deletion_enabled",
    "remediation": "Configure compute with security best practices for secure_deletion_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.data_retention_configuration.retention_policies_enforced",
    "assertion_id": "data_protection_storage.data_retention.retention_policies_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.data_retention_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for retention_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.data_retention_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute retention_policies_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for retention_policies_enforced",
    "remediation": "Configure compute with security best practices for retention_policies_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.data_retention_configuration.secure_deletion_enabled",
    "assertion_id": "data_protection_storage.data_retention.secure_deletion_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.data_retention_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for secure_deletion_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.data_retention_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute secure_deletion_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for secure_deletion_enabled",
    "remediation": "Configure compute with security best practices for secure_deletion_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.backup_recovery_configuration.backup_encryption_enabled",
    "assertion_id": "data_protection_storage.backup_recovery.backup_encryption_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.backup_recovery_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for backup_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.backup_recovery_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage backup_encryption_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for backup_encryption_enabled",
    "remediation": "Configure storage with security best practices for backup_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.backup_recovery_configuration.backup_retention_configured",
    "assertion_id": "data_protection_storage.backup_recovery.backup_retention_configured",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.backup_recovery_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for backup_retention_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.backup_recovery_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage backup_retention_configured implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for backup_retention_configured",
    "remediation": "Configure storage with security best practices for backup_retention_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.backup_recovery_configuration.backup_encryption_enabled",
    "assertion_id": "data_protection_storage.backup_recovery.backup_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.backup_recovery_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for backup_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.backup_recovery_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute backup_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for backup_encryption_enabled",
    "remediation": "Configure compute with security best practices for backup_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.backup_recovery_configuration.backup_retention_configured",
    "assertion_id": "data_protection_storage.backup_recovery.backup_retention_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.backup_recovery_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for backup_retention_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.backup_recovery_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute backup_retention_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for backup_retention_configured",
    "remediation": "Configure compute with security best practices for backup_retention_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.backup_recovery_configuration.backup_encryption_enabled",
    "assertion_id": "data_protection_storage.backup_recovery.backup_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.backup_recovery_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for backup_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.backup_recovery_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute backup_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for backup_encryption_enabled",
    "remediation": "Configure compute with security best practices for backup_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.backup_recovery_configuration.backup_retention_configured",
    "assertion_id": "data_protection_storage.backup_recovery.backup_retention_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.backup_recovery_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for backup_retention_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.backup_recovery_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute backup_retention_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for backup_retention_configured",
    "remediation": "Configure compute with security best practices for backup_retention_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.backup_recovery_configuration.backup_encryption_enabled",
    "assertion_id": "data_protection_storage.backup_recovery.backup_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.backup_recovery_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for backup_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.backup_recovery_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute backup_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for backup_encryption_enabled",
    "remediation": "Configure compute with security best practices for backup_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.backup_recovery_configuration.backup_retention_configured",
    "assertion_id": "data_protection_storage.backup_recovery.backup_retention_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.backup_recovery_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for backup_retention_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.backup_recovery_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute backup_retention_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for backup_retention_configured",
    "remediation": "Configure compute with security best practices for backup_retention_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.data_masking_configuration.sensitive_data_masked",
    "assertion_id": "data_protection_storage.data_masking.sensitive_data_masked",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.data_masking_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for sensitive_data_masked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.data_masking_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage sensitive_data_masked implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for sensitive_data_masked",
    "remediation": "Configure storage with security best practices for sensitive_data_masked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.data_masking_configuration.sensitive_data_masked",
    "assertion_id": "data_protection_storage.data_masking.sensitive_data_masked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.data_masking_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for sensitive_data_masked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.data_masking_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute sensitive_data_masked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for sensitive_data_masked",
    "remediation": "Configure compute with security best practices for sensitive_data_masked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.data_masking_configuration.sensitive_data_masked",
    "assertion_id": "data_protection_storage.data_masking.sensitive_data_masked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.data_masking_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for sensitive_data_masked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.data_masking_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute sensitive_data_masked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for sensitive_data_masked",
    "remediation": "Configure compute with security best practices for sensitive_data_masked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.data_masking_configuration.sensitive_data_masked",
    "assertion_id": "data_protection_storage.data_masking.sensitive_data_masked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.data_masking_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for sensitive_data_masked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.data_masking_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute sensitive_data_masked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for sensitive_data_masked",
    "remediation": "Configure compute with security best practices for sensitive_data_masked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_public_access_prevention.public_access_blocked",
    "assertion_id": "data_protection_storage.storage_security.public_access_blocked",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_public_access_prevention",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for public_access_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_public_access_prevention",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage public_access_blocked implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for public_access_blocked",
    "remediation": "Configure storage with security best practices for public_access_blocked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_public_access_prevention.access_logging_enabled",
    "assertion_id": "data_protection_storage.storage_security.access_logging_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_public_access_prevention",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for access_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_public_access_prevention",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage access_logging_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for access_logging_enabled",
    "remediation": "Configure storage with security best practices for access_logging_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_uniform_bucket_level_access.public_access_blocked",
    "assertion_id": "data_protection_storage.storage_security.public_access_blocked",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_uniform_bucket_level_access",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for public_access_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_uniform_bucket_level_access",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage public_access_blocked implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for public_access_blocked",
    "remediation": "Configure storage with security best practices for public_access_blocked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_uniform_bucket_level_access.access_logging_enabled",
    "assertion_id": "data_protection_storage.storage_security.access_logging_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_uniform_bucket_level_access",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for access_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_uniform_bucket_level_access",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage access_logging_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for access_logging_enabled",
    "remediation": "Configure storage with security best practices for access_logging_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_iam_policy.public_access_blocked",
    "assertion_id": "data_protection_storage.storage_security.public_access_blocked",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_iam_policy",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for public_access_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_iam_policy",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage public_access_blocked implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for public_access_blocked",
    "remediation": "Configure storage with security best practices for public_access_blocked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_iam_policy.access_logging_enabled",
    "assertion_id": "data_protection_storage.storage_security.access_logging_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_iam_policy",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for access_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_iam_policy",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage access_logging_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for access_logging_enabled",
    "remediation": "Configure storage with security best practices for access_logging_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.storage_security_configuration.public_access_blocked",
    "assertion_id": "data_protection_storage.storage_security.public_access_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.bigquery.storage_security_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for public_access_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.storage_security_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute public_access_blocked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for public_access_blocked",
    "remediation": "Configure compute with security best practices for public_access_blocked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.storage_security_configuration.access_logging_enabled",
    "assertion_id": "data_protection_storage.storage_security.access_logging_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.bigquery.storage_security_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for access_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.storage_security_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute access_logging_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for access_logging_enabled",
    "remediation": "Configure compute with security best practices for access_logging_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.storage_security_configuration.public_access_blocked",
    "assertion_id": "data_protection_storage.storage_security.public_access_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.dataproc.storage_security_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for public_access_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.storage_security_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute public_access_blocked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for public_access_blocked",
    "remediation": "Configure compute with security best practices for public_access_blocked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.storage_security_configuration.access_logging_enabled",
    "assertion_id": "data_protection_storage.storage_security.access_logging_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.dataproc.storage_security_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for access_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.storage_security_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute access_logging_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for access_logging_enabled",
    "remediation": "Configure compute with security best practices for access_logging_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.storage_security_configuration.public_access_blocked",
    "assertion_id": "data_protection_storage.storage_security.public_access_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.dlp.storage_security_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for public_access_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.storage_security_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute public_access_blocked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for public_access_blocked",
    "remediation": "Configure compute with security best practices for public_access_blocked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.storage_security_configuration.access_logging_enabled",
    "assertion_id": "data_protection_storage.storage_security.access_logging_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.dlp.storage_security_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for access_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.storage_security_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute access_logging_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for access_logging_enabled",
    "remediation": "Configure compute with security best practices for access_logging_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.network_segmentation_configuration.vpc_isolation_enforced",
    "assertion_id": "network_perimeter.network_segmentation.vpc_isolation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.network_segmentation_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for vpc_isolation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.network_segmentation_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpc_isolation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpc_isolation_enforced",
    "remediation": "Configure compute with security best practices for vpc_isolation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.network_segmentation_configuration.subnet_segmentation_configured",
    "assertion_id": "network_perimeter.network_segmentation.subnet_segmentation_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.network_segmentation_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for subnet_segmentation_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.network_segmentation_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute subnet_segmentation_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for subnet_segmentation_configured",
    "remediation": "Configure compute with security best practices for subnet_segmentation_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.network_segmentation_configuration.vpc_isolation_enforced",
    "assertion_id": "network_perimeter.network_segmentation.vpc_isolation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.network_segmentation_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for vpc_isolation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.network_segmentation_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpc_isolation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpc_isolation_enforced",
    "remediation": "Configure compute with security best practices for vpc_isolation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.network_segmentation_configuration.subnet_segmentation_configured",
    "assertion_id": "network_perimeter.network_segmentation.subnet_segmentation_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.network_segmentation_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for subnet_segmentation_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.network_segmentation_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute subnet_segmentation_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for subnet_segmentation_configured",
    "remediation": "Configure compute with security best practices for subnet_segmentation_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.network_segmentation_configuration.vpc_isolation_enforced",
    "assertion_id": "network_perimeter.network_segmentation.vpc_isolation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.network_segmentation_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for vpc_isolation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.network_segmentation_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpc_isolation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpc_isolation_enforced",
    "remediation": "Configure compute with security best practices for vpc_isolation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.network_segmentation_configuration.subnet_segmentation_configured",
    "assertion_id": "network_perimeter.network_segmentation.subnet_segmentation_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.network_segmentation_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for subnet_segmentation_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.network_segmentation_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute subnet_segmentation_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for subnet_segmentation_configured",
    "remediation": "Configure compute with security best practices for subnet_segmentation_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.network_segmentation_configuration.vpc_isolation_enforced",
    "assertion_id": "network_perimeter.network_segmentation.vpc_isolation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.network_segmentation_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for vpc_isolation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.network_segmentation_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpc_isolation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpc_isolation_enforced",
    "remediation": "Configure compute with security best practices for vpc_isolation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.network_segmentation_configuration.subnet_segmentation_configured",
    "assertion_id": "network_perimeter.network_segmentation.subnet_segmentation_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.network_segmentation_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for subnet_segmentation_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.network_segmentation_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute subnet_segmentation_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for subnet_segmentation_configured",
    "remediation": "Configure compute with security best practices for subnet_segmentation_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.firewall_rules_configuration.deny_all_default",
    "assertion_id": "network_perimeter.firewall_rules.deny_all_default",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for deny_all_default to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute deny_all_default implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for deny_all_default",
    "remediation": "Configure compute with security best practices for deny_all_default",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.firewall_rules_configuration.ssh_rdp_restricted",
    "assertion_id": "network_perimeter.firewall_rules.ssh_rdp_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "allowed_cidrs": "array[cidr]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for ssh_rdp_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssh_rdp_restricted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssh_rdp_restricted",
    "remediation": "Configure compute with security best practices for ssh_rdp_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.firewall_rules_configuration.waf_enabled",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "waf_mode": "enum[block,detect]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for waf_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled",
    "remediation": "Configure compute with security best practices for waf_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.firewall_rules_configuration.waf_enabled_at_edge",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled_at_edge",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for waf_enabled_at_edge to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled_at_edge implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled_at_edge",
    "remediation": "Configure compute with security best practices for waf_enabled_at_edge",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.firewall_rules_configuration.egress_filtering_enabled",
    "assertion_id": "network_perimeter.firewall_rules.egress_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for egress_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute egress_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for egress_filtering_enabled",
    "remediation": "Configure compute with security best practices for egress_filtering_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.firewall_rules_configuration.deny_all_default",
    "assertion_id": "network_perimeter.firewall_rules.deny_all_default",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for deny_all_default to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute deny_all_default implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for deny_all_default",
    "remediation": "Configure compute with security best practices for deny_all_default",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.firewall_rules_configuration.ssh_rdp_restricted",
    "assertion_id": "network_perimeter.firewall_rules.ssh_rdp_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "allowed_cidrs": "array[cidr]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for ssh_rdp_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssh_rdp_restricted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssh_rdp_restricted",
    "remediation": "Configure compute with security best practices for ssh_rdp_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.firewall_rules_configuration.waf_enabled",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "waf_mode": "enum[block,detect]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for waf_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled",
    "remediation": "Configure compute with security best practices for waf_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.firewall_rules_configuration.waf_enabled_at_edge",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled_at_edge",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for waf_enabled_at_edge to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled_at_edge implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled_at_edge",
    "remediation": "Configure compute with security best practices for waf_enabled_at_edge",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.firewall_rules_configuration.egress_filtering_enabled",
    "assertion_id": "network_perimeter.firewall_rules.egress_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for egress_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute egress_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for egress_filtering_enabled",
    "remediation": "Configure compute with security best practices for egress_filtering_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.security_policy_rules.deny_all_default",
    "assertion_id": "network_perimeter.firewall_rules.deny_all_default",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.security_policy_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for deny_all_default to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.security_policy_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute deny_all_default implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for deny_all_default",
    "remediation": "Configure compute with security best practices for deny_all_default",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.security_policy_rules.ssh_rdp_restricted",
    "assertion_id": "network_perimeter.firewall_rules.ssh_rdp_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.security_policy_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "allowed_cidrs": "array[cidr]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for ssh_rdp_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.security_policy_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssh_rdp_restricted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssh_rdp_restricted",
    "remediation": "Configure compute with security best practices for ssh_rdp_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.security_policy_rules.waf_enabled",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.security_policy_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "waf_mode": "enum[block,detect]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for waf_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.security_policy_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled",
    "remediation": "Configure compute with security best practices for waf_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.security_policy_rules.waf_enabled_at_edge",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled_at_edge",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.security_policy_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for waf_enabled_at_edge to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.security_policy_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled_at_edge implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled_at_edge",
    "remediation": "Configure compute with security best practices for waf_enabled_at_edge",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.security_policy_rules.egress_filtering_enabled",
    "assertion_id": "network_perimeter.firewall_rules.egress_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.security_policy_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for egress_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.security_policy_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute egress_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for egress_filtering_enabled",
    "remediation": "Configure compute with security best practices for egress_filtering_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.waf_rules.deny_all_default",
    "assertion_id": "network_perimeter.firewall_rules.deny_all_default",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.waf_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for deny_all_default to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.waf_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute deny_all_default implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for deny_all_default",
    "remediation": "Configure compute with security best practices for deny_all_default",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.waf_rules.ssh_rdp_restricted",
    "assertion_id": "network_perimeter.firewall_rules.ssh_rdp_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.waf_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "allowed_cidrs": "array[cidr]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for ssh_rdp_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.waf_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssh_rdp_restricted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssh_rdp_restricted",
    "remediation": "Configure compute with security best practices for ssh_rdp_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.waf_rules.waf_enabled",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.waf_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "waf_mode": "enum[block,detect]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for waf_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.waf_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled",
    "remediation": "Configure compute with security best practices for waf_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.waf_rules.waf_enabled_at_edge",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled_at_edge",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.waf_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for waf_enabled_at_edge to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.waf_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled_at_edge implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled_at_edge",
    "remediation": "Configure compute with security best practices for waf_enabled_at_edge",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.waf_rules.egress_filtering_enabled",
    "assertion_id": "network_perimeter.firewall_rules.egress_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.waf_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for egress_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.waf_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute egress_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for egress_filtering_enabled",
    "remediation": "Configure compute with security best practices for egress_filtering_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.firewall_rules_configuration.deny_all_default",
    "assertion_id": "network_perimeter.firewall_rules.deny_all_default",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for deny_all_default to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute deny_all_default implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for deny_all_default",
    "remediation": "Configure compute with security best practices for deny_all_default",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.firewall_rules_configuration.ssh_rdp_restricted",
    "assertion_id": "network_perimeter.firewall_rules.ssh_rdp_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "allowed_cidrs": "array[cidr]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for ssh_rdp_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssh_rdp_restricted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssh_rdp_restricted",
    "remediation": "Configure compute with security best practices for ssh_rdp_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.firewall_rules_configuration.waf_enabled",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "waf_mode": "enum[block,detect]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for waf_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled",
    "remediation": "Configure compute with security best practices for waf_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.firewall_rules_configuration.waf_enabled_at_edge",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled_at_edge",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for waf_enabled_at_edge to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled_at_edge implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled_at_edge",
    "remediation": "Configure compute with security best practices for waf_enabled_at_edge",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.firewall_rules_configuration.egress_filtering_enabled",
    "assertion_id": "network_perimeter.firewall_rules.egress_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for egress_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute egress_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for egress_filtering_enabled",
    "remediation": "Configure compute with security best practices for egress_filtering_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.ddos_protection.deny_all_default",
    "assertion_id": "network_perimeter.firewall_rules.deny_all_default",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.ddos_protection",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for deny_all_default to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.ddos_protection",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute deny_all_default implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for deny_all_default",
    "remediation": "Configure compute with security best practices for deny_all_default",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.ddos_protection.ssh_rdp_restricted",
    "assertion_id": "network_perimeter.firewall_rules.ssh_rdp_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.ddos_protection",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "allowed_cidrs": "array[cidr]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for ssh_rdp_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.ddos_protection",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssh_rdp_restricted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssh_rdp_restricted",
    "remediation": "Configure compute with security best practices for ssh_rdp_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.ddos_protection.waf_enabled",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.ddos_protection",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "waf_mode": "enum[block,detect]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for waf_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.ddos_protection",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled",
    "remediation": "Configure compute with security best practices for waf_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.ddos_protection.waf_enabled_at_edge",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled_at_edge",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.ddos_protection",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for waf_enabled_at_edge to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.ddos_protection",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled_at_edge implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled_at_edge",
    "remediation": "Configure compute with security best practices for waf_enabled_at_edge",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.ddos_protection.egress_filtering_enabled",
    "assertion_id": "network_perimeter.firewall_rules.egress_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.ddos_protection",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for egress_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.ddos_protection",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute egress_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for egress_filtering_enabled",
    "remediation": "Configure compute with security best practices for egress_filtering_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.dns_security_configuration.dns_filtering_enabled",
    "assertion_id": "network_perimeter.dns_security.dns_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.dns_security_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for dns_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.dns_security_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute dns_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for dns_filtering_enabled",
    "remediation": "Configure compute with security best practices for dns_filtering_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.dns_security_configuration.private_dns_zones_used",
    "assertion_id": "network_perimeter.dns_security.private_dns_zones_used",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.dns_security_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for private_dns_zones_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.dns_security_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_dns_zones_used implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_dns_zones_used",
    "remediation": "Configure compute with security best practices for private_dns_zones_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.dns_security_configuration.dns_filtering_enabled",
    "assertion_id": "network_perimeter.dns_security.dns_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.dns_security_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for dns_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.dns_security_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute dns_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for dns_filtering_enabled",
    "remediation": "Configure compute with security best practices for dns_filtering_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.dns_security_configuration.private_dns_zones_used",
    "assertion_id": "network_perimeter.dns_security.private_dns_zones_used",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.dns_security_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for private_dns_zones_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.dns_security_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_dns_zones_used implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_dns_zones_used",
    "remediation": "Configure compute with security best practices for private_dns_zones_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.dns_security_configuration.dns_filtering_enabled",
    "assertion_id": "network_perimeter.dns_security.dns_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.dns_security_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for dns_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.dns_security_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute dns_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for dns_filtering_enabled",
    "remediation": "Configure compute with security best practices for dns_filtering_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.dns_security_configuration.private_dns_zones_used",
    "assertion_id": "network_perimeter.dns_security.private_dns_zones_used",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.dns_security_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for private_dns_zones_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.dns_security_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_dns_zones_used implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_dns_zones_used",
    "remediation": "Configure compute with security best practices for private_dns_zones_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.dns_security_configuration.dns_filtering_enabled",
    "assertion_id": "network_perimeter.dns_security.dns_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.dns_security_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for dns_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.dns_security_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute dns_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for dns_filtering_enabled",
    "remediation": "Configure compute with security best practices for dns_filtering_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.dns_security_configuration.private_dns_zones_used",
    "assertion_id": "network_perimeter.dns_security.private_dns_zones_used",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.dns_security_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for private_dns_zones_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.dns_security_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_dns_zones_used implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_dns_zones_used",
    "remediation": "Configure compute with security best practices for private_dns_zones_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.load_balancing_configuration.ssl_termination_configured",
    "assertion_id": "network_perimeter.load_balancing.ssl_termination_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.load_balancing_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for ssl_termination_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.load_balancing_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssl_termination_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssl_termination_configured",
    "remediation": "Configure compute with security best practices for ssl_termination_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.load_balancing_configuration.health_checks_configured",
    "assertion_id": "network_perimeter.load_balancing.health_checks_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.load_balancing_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for health_checks_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.load_balancing_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute health_checks_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for health_checks_configured",
    "remediation": "Configure compute with security best practices for health_checks_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.load_balancing_configuration.ssl_termination_configured",
    "assertion_id": "network_perimeter.load_balancing.ssl_termination_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.load_balancing_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for ssl_termination_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.load_balancing_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssl_termination_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssl_termination_configured",
    "remediation": "Configure compute with security best practices for ssl_termination_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.load_balancing_configuration.health_checks_configured",
    "assertion_id": "network_perimeter.load_balancing.health_checks_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.load_balancing_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for health_checks_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.load_balancing_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute health_checks_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for health_checks_configured",
    "remediation": "Configure compute with security best practices for health_checks_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.load_balancing_configuration.ssl_termination_configured",
    "assertion_id": "network_perimeter.load_balancing.ssl_termination_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.load_balancing_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for ssl_termination_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.load_balancing_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssl_termination_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssl_termination_configured",
    "remediation": "Configure compute with security best practices for ssl_termination_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.load_balancing_configuration.health_checks_configured",
    "assertion_id": "network_perimeter.load_balancing.health_checks_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.load_balancing_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for health_checks_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.load_balancing_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute health_checks_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for health_checks_configured",
    "remediation": "Configure compute with security best practices for health_checks_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.load_balancing_configuration.ssl_termination_configured",
    "assertion_id": "network_perimeter.load_balancing.ssl_termination_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.load_balancing_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for ssl_termination_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.load_balancing_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssl_termination_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssl_termination_configured",
    "remediation": "Configure compute with security best practices for ssl_termination_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.load_balancing_configuration.health_checks_configured",
    "assertion_id": "network_perimeter.load_balancing.health_checks_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.load_balancing_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for health_checks_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.load_balancing_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute health_checks_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for health_checks_configured",
    "remediation": "Configure compute with security best practices for health_checks_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.vpn_connectivity_configuration.vpn_encryption_enabled",
    "assertion_id": "network_perimeter.vpn_connectivity.vpn_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.vpn_connectivity_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for vpn_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.vpn_connectivity_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpn_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpn_encryption_enabled",
    "remediation": "Configure compute with security best practices for vpn_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.vpn_connectivity_configuration.vpn_monitoring_enabled",
    "assertion_id": "network_perimeter.vpn_connectivity.vpn_monitoring_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.vpn_connectivity_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for vpn_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.vpn_connectivity_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpn_monitoring_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpn_monitoring_enabled",
    "remediation": "Configure compute with security best practices for vpn_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.vpn_connectivity_configuration.vpn_encryption_enabled",
    "assertion_id": "network_perimeter.vpn_connectivity.vpn_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.vpn_connectivity_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for vpn_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.vpn_connectivity_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpn_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpn_encryption_enabled",
    "remediation": "Configure compute with security best practices for vpn_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.vpn_connectivity_configuration.vpn_monitoring_enabled",
    "assertion_id": "network_perimeter.vpn_connectivity.vpn_monitoring_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.vpn_connectivity_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for vpn_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.vpn_connectivity_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpn_monitoring_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpn_monitoring_enabled",
    "remediation": "Configure compute with security best practices for vpn_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.vpn_connectivity_configuration.vpn_encryption_enabled",
    "assertion_id": "network_perimeter.vpn_connectivity.vpn_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.vpn_connectivity_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for vpn_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.vpn_connectivity_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpn_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpn_encryption_enabled",
    "remediation": "Configure compute with security best practices for vpn_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.vpn_connectivity_configuration.vpn_monitoring_enabled",
    "assertion_id": "network_perimeter.vpn_connectivity.vpn_monitoring_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.vpn_connectivity_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for vpn_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.vpn_connectivity_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpn_monitoring_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpn_monitoring_enabled",
    "remediation": "Configure compute with security best practices for vpn_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.vpn_connectivity_configuration.vpn_encryption_enabled",
    "assertion_id": "network_perimeter.vpn_connectivity.vpn_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.vpn_connectivity_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for vpn_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.vpn_connectivity_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpn_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpn_encryption_enabled",
    "remediation": "Configure compute with security best practices for vpn_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.vpn_connectivity_configuration.vpn_monitoring_enabled",
    "assertion_id": "network_perimeter.vpn_connectivity.vpn_monitoring_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.vpn_connectivity_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for vpn_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.vpn_connectivity_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpn_monitoring_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpn_monitoring_enabled",
    "remediation": "Configure compute with security best practices for vpn_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_shielded_vm.baseline_configuration_applied",
    "assertion_id": "compute_host_security.os_hardening.baseline_configuration_applied",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_shielded_vm",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for baseline_configuration_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_shielded_vm",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute baseline_configuration_applied implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for baseline_configuration_applied",
    "remediation": "Configure compute with security best practices for baseline_configuration_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_shielded_vm.unnecessary_services_disabled",
    "assertion_id": "compute_host_security.os_hardening.unnecessary_services_disabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_shielded_vm",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for unnecessary_services_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_shielded_vm",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute unnecessary_services_disabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for unnecessary_services_disabled",
    "remediation": "Configure compute with security best practices for unnecessary_services_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_os_integrity_monitoring.baseline_configuration_applied",
    "assertion_id": "compute_host_security.os_hardening.baseline_configuration_applied",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_os_integrity_monitoring",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for baseline_configuration_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_os_integrity_monitoring",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute baseline_configuration_applied implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for baseline_configuration_applied",
    "remediation": "Configure compute with security best practices for baseline_configuration_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_os_integrity_monitoring.unnecessary_services_disabled",
    "assertion_id": "compute_host_security.os_hardening.unnecessary_services_disabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_os_integrity_monitoring",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for unnecessary_services_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_os_integrity_monitoring",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute unnecessary_services_disabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for unnecessary_services_disabled",
    "remediation": "Configure compute with security best practices for unnecessary_services_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_secure_boot.baseline_configuration_applied",
    "assertion_id": "compute_host_security.os_hardening.baseline_configuration_applied",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_secure_boot",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for baseline_configuration_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_secure_boot",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute baseline_configuration_applied implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for baseline_configuration_applied",
    "remediation": "Configure compute with security best practices for baseline_configuration_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_secure_boot.unnecessary_services_disabled",
    "assertion_id": "compute_host_security.os_hardening.unnecessary_services_disabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_secure_boot",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for unnecessary_services_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_secure_boot",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute unnecessary_services_disabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for unnecessary_services_disabled",
    "remediation": "Configure compute with security best practices for unnecessary_services_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.os_hardening_configuration.baseline_configuration_applied",
    "assertion_id": "compute_host_security.os_hardening.baseline_configuration_applied",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.os_hardening_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for baseline_configuration_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.os_hardening_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute baseline_configuration_applied implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for baseline_configuration_applied",
    "remediation": "Configure compute with security best practices for baseline_configuration_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.os_hardening_configuration.unnecessary_services_disabled",
    "assertion_id": "compute_host_security.os_hardening.unnecessary_services_disabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.os_hardening_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for unnecessary_services_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.os_hardening_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute unnecessary_services_disabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for unnecessary_services_disabled",
    "remediation": "Configure compute with security best practices for unnecessary_services_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.os_hardening_configuration.baseline_configuration_applied",
    "assertion_id": "compute_host_security.os_hardening.baseline_configuration_applied",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.os_hardening_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for baseline_configuration_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.os_hardening_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter baseline_configuration_applied implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for baseline_configuration_applied",
    "remediation": "Configure securitycenter with security best practices for baseline_configuration_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.os_hardening_configuration.unnecessary_services_disabled",
    "assertion_id": "compute_host_security.os_hardening.unnecessary_services_disabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.os_hardening_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for unnecessary_services_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.os_hardening_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter unnecessary_services_disabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for unnecessary_services_disabled",
    "remediation": "Configure securitycenter with security best practices for unnecessary_services_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_patch_management.automatic_patching_enabled",
    "assertion_id": "compute_host_security.patch_management.automatic_patching_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_patch_management",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for automatic_patching_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_patch_management",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute automatic_patching_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for automatic_patching_enabled",
    "remediation": "Configure compute with security best practices for automatic_patching_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_patch_management.patch_compliance_monitored",
    "assertion_id": "compute_host_security.patch_management.patch_compliance_monitored",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_patch_management",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for patch_compliance_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_patch_management",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute patch_compliance_monitored implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for patch_compliance_monitored",
    "remediation": "Configure compute with security best practices for patch_compliance_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_automatic_updates.automatic_patching_enabled",
    "assertion_id": "compute_host_security.patch_management.automatic_patching_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_automatic_updates",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for automatic_patching_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_automatic_updates",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute automatic_patching_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for automatic_patching_enabled",
    "remediation": "Configure compute with security best practices for automatic_patching_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_automatic_updates.patch_compliance_monitored",
    "assertion_id": "compute_host_security.patch_management.patch_compliance_monitored",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_automatic_updates",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for patch_compliance_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_automatic_updates",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute patch_compliance_monitored implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for patch_compliance_monitored",
    "remediation": "Configure compute with security best practices for patch_compliance_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.patch_management_configuration.automatic_patching_enabled",
    "assertion_id": "compute_host_security.patch_management.automatic_patching_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.patch_management_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for automatic_patching_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.patch_management_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute automatic_patching_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for automatic_patching_enabled",
    "remediation": "Configure compute with security best practices for automatic_patching_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.patch_management_configuration.patch_compliance_monitored",
    "assertion_id": "compute_host_security.patch_management.patch_compliance_monitored",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.patch_management_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for patch_compliance_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.patch_management_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute patch_compliance_monitored implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for patch_compliance_monitored",
    "remediation": "Configure compute with security best practices for patch_compliance_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.patch_management_configuration.automatic_patching_enabled",
    "assertion_id": "compute_host_security.patch_management.automatic_patching_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.patch_management_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for automatic_patching_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.patch_management_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter automatic_patching_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for automatic_patching_enabled",
    "remediation": "Configure securitycenter with security best practices for automatic_patching_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.patch_management_configuration.patch_compliance_monitored",
    "assertion_id": "compute_host_security.patch_management.patch_compliance_monitored",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.patch_management_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for patch_compliance_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.patch_management_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter patch_compliance_monitored implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for patch_compliance_monitored",
    "remediation": "Configure securitycenter with security best practices for patch_compliance_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.endpoint_protection_configuration.antimalware_enabled",
    "assertion_id": "compute_host_security.endpoint_protection.antimalware_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.endpoint_protection_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for antimalware_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.endpoint_protection_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute antimalware_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for antimalware_enabled",
    "remediation": "Configure compute with security best practices for antimalware_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.endpoint_protection_configuration.intrusion_detection_enabled",
    "assertion_id": "compute_host_security.endpoint_protection.intrusion_detection_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.endpoint_protection_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for intrusion_detection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.endpoint_protection_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute intrusion_detection_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for intrusion_detection_enabled",
    "remediation": "Configure compute with security best practices for intrusion_detection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.endpoint_protection_configuration.antimalware_enabled",
    "assertion_id": "compute_host_security.endpoint_protection.antimalware_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.endpoint_protection_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for antimalware_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.endpoint_protection_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute antimalware_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for antimalware_enabled",
    "remediation": "Configure compute with security best practices for antimalware_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.endpoint_protection_configuration.intrusion_detection_enabled",
    "assertion_id": "compute_host_security.endpoint_protection.intrusion_detection_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.endpoint_protection_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for intrusion_detection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.endpoint_protection_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute intrusion_detection_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for intrusion_detection_enabled",
    "remediation": "Configure compute with security best practices for intrusion_detection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.endpoint_protection_configuration.antimalware_enabled",
    "assertion_id": "compute_host_security.endpoint_protection.antimalware_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.endpoint_protection_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for antimalware_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.endpoint_protection_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter antimalware_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for antimalware_enabled",
    "remediation": "Configure securitycenter with security best practices for antimalware_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.endpoint_protection_configuration.intrusion_detection_enabled",
    "assertion_id": "compute_host_security.endpoint_protection.intrusion_detection_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.endpoint_protection_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for intrusion_detection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.endpoint_protection_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter intrusion_detection_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for intrusion_detection_enabled",
    "remediation": "Configure securitycenter with security best practices for intrusion_detection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.vulnerability_management_configuration.scanning_enabled",
    "assertion_id": "compute_host_security.vulnerability_management.scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.vulnerability_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "scan_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.vulnerability_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for scanning_enabled",
    "remediation": "Configure compute with security best practices for scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.vulnerability_management_configuration.remediation_tracked",
    "assertion_id": "compute_host_security.vulnerability_management.remediation_tracked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.vulnerability_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for remediation_tracked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.vulnerability_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute remediation_tracked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for remediation_tracked",
    "remediation": "Configure compute with security best practices for remediation_tracked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.vulnerability_management_configuration.scanning_enabled",
    "assertion_id": "compute_host_security.vulnerability_management.scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.vulnerability_management_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "scan_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.vulnerability_management_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for scanning_enabled",
    "remediation": "Configure compute with security best practices for scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.vulnerability_management_configuration.remediation_tracked",
    "assertion_id": "compute_host_security.vulnerability_management.remediation_tracked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.vulnerability_management_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for remediation_tracked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.vulnerability_management_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute remediation_tracked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for remediation_tracked",
    "remediation": "Configure compute with security best practices for remediation_tracked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.vulnerability_management_configuration.scanning_enabled",
    "assertion_id": "compute_host_security.vulnerability_management.scanning_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.vulnerability_management_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "scan_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.vulnerability_management_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter scanning_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for scanning_enabled",
    "remediation": "Configure securitycenter with security best practices for scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.vulnerability_management_configuration.remediation_tracked",
    "assertion_id": "compute_host_security.vulnerability_management.remediation_tracked",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.vulnerability_management_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for remediation_tracked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.vulnerability_management_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter remediation_tracked implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for remediation_tracked",
    "remediation": "Configure securitycenter with security best practices for remediation_tracked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.compliance_monitoring_configuration.baseline_compliance_checked",
    "assertion_id": "compute_host_security.compliance_monitoring.baseline_compliance_checked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.compliance_monitoring_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for baseline_compliance_checked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.compliance_monitoring_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute baseline_compliance_checked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for baseline_compliance_checked",
    "remediation": "Configure compute with security best practices for baseline_compliance_checked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.compliance_monitoring_configuration.baseline_compliance_checked",
    "assertion_id": "compute_host_security.compliance_monitoring.baseline_compliance_checked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.osconfig.compliance_monitoring_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for baseline_compliance_checked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.compliance_monitoring_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute baseline_compliance_checked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for baseline_compliance_checked",
    "remediation": "Configure compute with security best practices for baseline_compliance_checked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.compliance_monitoring_configuration.baseline_compliance_checked",
    "assertion_id": "compute_host_security.compliance_monitoring.baseline_compliance_checked",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.securitycenter.compliance_monitoring_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for baseline_compliance_checked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.compliance_monitoring_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter baseline_compliance_checked implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for baseline_compliance_checked",
    "remediation": "Configure securitycenter with security best practices for baseline_compliance_checked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_binary_authorization.vulnerability_scanning_enabled",
    "assertion_id": "containers_kubernetes.image_security.vulnerability_scanning_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_binary_authorization",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for vulnerability_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_binary_authorization",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container vulnerability_scanning_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for vulnerability_scanning_enabled",
    "remediation": "Configure container with security best practices for vulnerability_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_binary_authorization.base_images_approved",
    "assertion_id": "containers_kubernetes.image_security.base_images_approved",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_binary_authorization",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for base_images_approved to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_binary_authorization",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container base_images_approved implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for base_images_approved",
    "remediation": "Configure container with security best practices for base_images_approved",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_binary_authorization.image_signing_enabled",
    "assertion_id": "containers_kubernetes.image_security.image_signing_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_binary_authorization",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for image_signing_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_binary_authorization",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container image_signing_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for image_signing_enabled",
    "remediation": "Configure container with security best practices for image_signing_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_image_vulnerability_scanning.vulnerability_scanning_enabled",
    "assertion_id": "containers_kubernetes.image_security.vulnerability_scanning_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_image_vulnerability_scanning",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for vulnerability_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_image_vulnerability_scanning",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container vulnerability_scanning_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for vulnerability_scanning_enabled",
    "remediation": "Configure container with security best practices for vulnerability_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_image_vulnerability_scanning.base_images_approved",
    "assertion_id": "containers_kubernetes.image_security.base_images_approved",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_image_vulnerability_scanning",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for base_images_approved to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_image_vulnerability_scanning",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container base_images_approved implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for base_images_approved",
    "remediation": "Configure container with security best practices for base_images_approved",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_image_vulnerability_scanning.image_signing_enabled",
    "assertion_id": "containers_kubernetes.image_security.image_signing_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_image_vulnerability_scanning",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for image_signing_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_image_vulnerability_scanning",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container image_signing_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for image_signing_enabled",
    "remediation": "Configure container with security best practices for image_signing_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_workload_identity.vulnerability_scanning_enabled",
    "assertion_id": "containers_kubernetes.image_security.vulnerability_scanning_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_workload_identity",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for vulnerability_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_workload_identity",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container vulnerability_scanning_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for vulnerability_scanning_enabled",
    "remediation": "Configure container with security best practices for vulnerability_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_workload_identity.base_images_approved",
    "assertion_id": "containers_kubernetes.image_security.base_images_approved",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_workload_identity",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for base_images_approved to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_workload_identity",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container base_images_approved implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for base_images_approved",
    "remediation": "Configure container with security best practices for base_images_approved",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_workload_identity.image_signing_enabled",
    "assertion_id": "containers_kubernetes.image_security.image_signing_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_workload_identity",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for image_signing_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_workload_identity",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container image_signing_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for image_signing_enabled",
    "remediation": "Configure container with security best practices for image_signing_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.image_security_configuration.vulnerability_scanning_enabled",
    "assertion_id": "containers_kubernetes.image_security.vulnerability_scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.image_security_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for vulnerability_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.image_security_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vulnerability_scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vulnerability_scanning_enabled",
    "remediation": "Configure compute with security best practices for vulnerability_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.image_security_configuration.base_images_approved",
    "assertion_id": "containers_kubernetes.image_security.base_images_approved",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.image_security_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for base_images_approved to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.image_security_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute base_images_approved implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for base_images_approved",
    "remediation": "Configure compute with security best practices for base_images_approved",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.image_security_configuration.image_signing_enabled",
    "assertion_id": "containers_kubernetes.image_security.image_signing_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.image_security_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for image_signing_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.image_security_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute image_signing_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for image_signing_enabled",
    "remediation": "Configure compute with security best practices for image_signing_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.image_attestation_policy.vulnerability_scanning_enabled",
    "assertion_id": "containers_kubernetes.image_security.vulnerability_scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.image_attestation_policy",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for vulnerability_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.image_attestation_policy",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vulnerability_scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vulnerability_scanning_enabled",
    "remediation": "Configure compute with security best practices for vulnerability_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.image_attestation_policy.base_images_approved",
    "assertion_id": "containers_kubernetes.image_security.base_images_approved",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.image_attestation_policy",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for base_images_approved to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.image_attestation_policy",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute base_images_approved implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for base_images_approved",
    "remediation": "Configure compute with security best practices for base_images_approved",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.image_attestation_policy.image_signing_enabled",
    "assertion_id": "containers_kubernetes.image_security.image_signing_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.image_attestation_policy",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for image_signing_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.image_attestation_policy",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute image_signing_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for image_signing_enabled",
    "remediation": "Configure compute with security best practices for image_signing_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.image_attestation_verification.vulnerability_scanning_enabled",
    "assertion_id": "containers_kubernetes.image_security.vulnerability_scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.image_attestation_verification",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for vulnerability_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.image_attestation_verification",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vulnerability_scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vulnerability_scanning_enabled",
    "remediation": "Configure compute with security best practices for vulnerability_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.image_attestation_verification.base_images_approved",
    "assertion_id": "containers_kubernetes.image_security.base_images_approved",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.image_attestation_verification",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for base_images_approved to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.image_attestation_verification",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute base_images_approved implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for base_images_approved",
    "remediation": "Configure compute with security best practices for base_images_approved",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.image_attestation_verification.image_signing_enabled",
    "assertion_id": "containers_kubernetes.image_security.image_signing_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.image_attestation_verification",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for image_signing_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.image_attestation_verification",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute image_signing_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for image_signing_enabled",
    "remediation": "Configure compute with security best practices for image_signing_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_pod_security_standards.runtime_protection_enabled",
    "assertion_id": "containers_kubernetes.runtime_security.runtime_protection_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_pod_security_standards",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for runtime_protection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_pod_security_standards",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container runtime_protection_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for runtime_protection_enabled",
    "remediation": "Configure container with security best practices for runtime_protection_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_pod_security_standards.privileged_containers_restricted",
    "assertion_id": "containers_kubernetes.runtime_security.privileged_containers_restricted",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_pod_security_standards",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for privileged_containers_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_pod_security_standards",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container privileged_containers_restricted implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for privileged_containers_restricted",
    "remediation": "Configure container with security best practices for privileged_containers_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_pod_security_standards.resource_limits_enforced",
    "assertion_id": "containers_kubernetes.runtime_security.resource_limits_enforced",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_pod_security_standards",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for resource_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_pod_security_standards",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container resource_limits_enforced implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for resource_limits_enforced",
    "remediation": "Configure container with security best practices for resource_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_network_policy_enforcement.runtime_protection_enabled",
    "assertion_id": "containers_kubernetes.runtime_security.runtime_protection_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_network_policy_enforcement",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for runtime_protection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_network_policy_enforcement",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container runtime_protection_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for runtime_protection_enabled",
    "remediation": "Configure container with security best practices for runtime_protection_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_network_policy_enforcement.privileged_containers_restricted",
    "assertion_id": "containers_kubernetes.runtime_security.privileged_containers_restricted",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_network_policy_enforcement",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for privileged_containers_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_network_policy_enforcement",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container privileged_containers_restricted implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for privileged_containers_restricted",
    "remediation": "Configure container with security best practices for privileged_containers_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_network_policy_enforcement.resource_limits_enforced",
    "assertion_id": "containers_kubernetes.runtime_security.resource_limits_enforced",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_network_policy_enforcement",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for resource_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_network_policy_enforcement",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container resource_limits_enforced implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for resource_limits_enforced",
    "remediation": "Configure container with security best practices for resource_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_authorized_networks.runtime_protection_enabled",
    "assertion_id": "containers_kubernetes.runtime_security.runtime_protection_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_authorized_networks",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for runtime_protection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_authorized_networks",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container runtime_protection_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for runtime_protection_enabled",
    "remediation": "Configure container with security best practices for runtime_protection_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_authorized_networks.privileged_containers_restricted",
    "assertion_id": "containers_kubernetes.runtime_security.privileged_containers_restricted",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_authorized_networks",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for privileged_containers_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_authorized_networks",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container privileged_containers_restricted implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for privileged_containers_restricted",
    "remediation": "Configure container with security best practices for privileged_containers_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_authorized_networks.resource_limits_enforced",
    "assertion_id": "containers_kubernetes.runtime_security.resource_limits_enforced",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_authorized_networks",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for resource_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_authorized_networks",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container resource_limits_enforced implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for resource_limits_enforced",
    "remediation": "Configure container with security best practices for resource_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.runtime_security_configuration.runtime_protection_enabled",
    "assertion_id": "containers_kubernetes.runtime_security.runtime_protection_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.artifactregistry.runtime_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for runtime_protection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.runtime_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute runtime_protection_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for runtime_protection_enabled",
    "remediation": "Configure compute with security best practices for runtime_protection_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.runtime_security_configuration.privileged_containers_restricted",
    "assertion_id": "containers_kubernetes.runtime_security.privileged_containers_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.artifactregistry.runtime_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for privileged_containers_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.runtime_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute privileged_containers_restricted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for privileged_containers_restricted",
    "remediation": "Configure compute with security best practices for privileged_containers_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.runtime_security_configuration.resource_limits_enforced",
    "assertion_id": "containers_kubernetes.runtime_security.resource_limits_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.artifactregistry.runtime_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for resource_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.runtime_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute resource_limits_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for resource_limits_enforced",
    "remediation": "Configure compute with security best practices for resource_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.runtime_security_configuration.runtime_protection_enabled",
    "assertion_id": "containers_kubernetes.runtime_security.runtime_protection_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.binaryauthorization.runtime_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for runtime_protection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.runtime_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute runtime_protection_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for runtime_protection_enabled",
    "remediation": "Configure compute with security best practices for runtime_protection_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.runtime_security_configuration.privileged_containers_restricted",
    "assertion_id": "containers_kubernetes.runtime_security.privileged_containers_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.binaryauthorization.runtime_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for privileged_containers_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.runtime_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute privileged_containers_restricted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for privileged_containers_restricted",
    "remediation": "Configure compute with security best practices for privileged_containers_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.runtime_security_configuration.resource_limits_enforced",
    "assertion_id": "containers_kubernetes.runtime_security.resource_limits_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.binaryauthorization.runtime_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for resource_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.runtime_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute resource_limits_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for resource_limits_enforced",
    "remediation": "Configure compute with security best practices for resource_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.network_policies_configuration.network_segmentation_enforced",
    "assertion_id": "containers_kubernetes.network_policies.network_segmentation_enforced",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.network_policies_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for network_segmentation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.network_policies_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container network_segmentation_enforced implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for network_segmentation_enforced",
    "remediation": "Configure container with security best practices for network_segmentation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.network_policies_configuration.ingress_egress_controlled",
    "assertion_id": "containers_kubernetes.network_policies.ingress_egress_controlled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.network_policies_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for ingress_egress_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.network_policies_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container ingress_egress_controlled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for ingress_egress_controlled",
    "remediation": "Configure container with security best practices for ingress_egress_controlled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.network_policies_configuration.network_segmentation_enforced",
    "assertion_id": "containers_kubernetes.network_policies.network_segmentation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.network_policies_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for network_segmentation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.network_policies_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute network_segmentation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for network_segmentation_enforced",
    "remediation": "Configure compute with security best practices for network_segmentation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.network_policies_configuration.ingress_egress_controlled",
    "assertion_id": "containers_kubernetes.network_policies.ingress_egress_controlled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.network_policies_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for ingress_egress_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.network_policies_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ingress_egress_controlled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ingress_egress_controlled",
    "remediation": "Configure compute with security best practices for ingress_egress_controlled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.network_policies_configuration.network_segmentation_enforced",
    "assertion_id": "containers_kubernetes.network_policies.network_segmentation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.network_policies_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for network_segmentation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.network_policies_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute network_segmentation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for network_segmentation_enforced",
    "remediation": "Configure compute with security best practices for network_segmentation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.network_policies_configuration.ingress_egress_controlled",
    "assertion_id": "containers_kubernetes.network_policies.ingress_egress_controlled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.network_policies_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for ingress_egress_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.network_policies_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ingress_egress_controlled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ingress_egress_controlled",
    "remediation": "Configure compute with security best practices for ingress_egress_controlled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.rbac_policies_configuration.least_privilege_enforced",
    "assertion_id": "containers_kubernetes.rbac_policies.least_privilege_enforced",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.rbac_policies_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for least_privilege_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.rbac_policies_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container least_privilege_enforced implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for least_privilege_enforced",
    "remediation": "Configure container with security best practices for least_privilege_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.rbac_policies_configuration.service_account_restrictions",
    "assertion_id": "containers_kubernetes.rbac_policies.service_account_restrictions",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.rbac_policies_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for service_account_restrictions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.rbac_policies_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container service_account_restrictions implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for service_account_restrictions",
    "remediation": "Configure container with security best practices for service_account_restrictions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.rbac_policies_configuration.least_privilege_enforced",
    "assertion_id": "containers_kubernetes.rbac_policies.least_privilege_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.rbac_policies_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for least_privilege_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.rbac_policies_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute least_privilege_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for least_privilege_enforced",
    "remediation": "Configure compute with security best practices for least_privilege_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.rbac_policies_configuration.service_account_restrictions",
    "assertion_id": "containers_kubernetes.rbac_policies.service_account_restrictions",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.rbac_policies_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for service_account_restrictions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.rbac_policies_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute service_account_restrictions implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for service_account_restrictions",
    "remediation": "Configure compute with security best practices for service_account_restrictions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.rbac_policies_configuration.least_privilege_enforced",
    "assertion_id": "containers_kubernetes.rbac_policies.least_privilege_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.rbac_policies_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for least_privilege_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.rbac_policies_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute least_privilege_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for least_privilege_enforced",
    "remediation": "Configure compute with security best practices for least_privilege_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.rbac_policies_configuration.service_account_restrictions",
    "assertion_id": "containers_kubernetes.rbac_policies.service_account_restrictions",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.rbac_policies_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for service_account_restrictions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.rbac_policies_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute service_account_restrictions implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for service_account_restrictions",
    "remediation": "Configure compute with security best practices for service_account_restrictions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.admission_control_configuration.policy_validation_enabled",
    "assertion_id": "containers_kubernetes.admission_control.policy_validation_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.admission_control_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for policy_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.admission_control_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container policy_validation_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for policy_validation_enabled",
    "remediation": "Configure container with security best practices for policy_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.admission_control_configuration.security_policies_enforced",
    "assertion_id": "containers_kubernetes.admission_control.security_policies_enforced",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.admission_control_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for security_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.admission_control_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container security_policies_enforced implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for security_policies_enforced",
    "remediation": "Configure container with security best practices for security_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.admission_control_configuration.policy_validation_enabled",
    "assertion_id": "containers_kubernetes.admission_control.policy_validation_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.admission_control_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for policy_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.admission_control_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute policy_validation_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for policy_validation_enabled",
    "remediation": "Configure compute with security best practices for policy_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.admission_control_configuration.security_policies_enforced",
    "assertion_id": "containers_kubernetes.admission_control.security_policies_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.admission_control_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for security_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.admission_control_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute security_policies_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for security_policies_enforced",
    "remediation": "Configure compute with security best practices for security_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.admission_control_configuration.policy_validation_enabled",
    "assertion_id": "containers_kubernetes.admission_control.policy_validation_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.admission_control_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for policy_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.admission_control_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute policy_validation_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for policy_validation_enabled",
    "remediation": "Configure compute with security best practices for policy_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.admission_control_configuration.security_policies_enforced",
    "assertion_id": "containers_kubernetes.admission_control.security_policies_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.admission_control_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for security_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.admission_control_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute security_policies_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for security_policies_enforced",
    "remediation": "Configure compute with security best practices for security_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.function_security_configuration.runtime_security_enabled",
    "assertion_id": "serverless_paas.function_security.runtime_security_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.function_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for runtime_security_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.function_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless runtime_security_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for runtime_security_enabled",
    "remediation": "Configure serverless with security best practices for runtime_security_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.function_security_configuration.execution_timeout_configured",
    "assertion_id": "serverless_paas.function_security.execution_timeout_configured",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.function_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_execution_timeout_seconds": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for execution_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.function_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless execution_timeout_configured implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for execution_timeout_configured",
    "remediation": "Configure serverless with security best practices for execution_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.function_security_configuration.memory_limits_enforced",
    "assertion_id": "serverless_paas.function_security.memory_limits_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.function_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for memory_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.function_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless memory_limits_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for memory_limits_enforced",
    "remediation": "Configure serverless with security best practices for memory_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.function_security_configuration.runtime_security_enabled",
    "assertion_id": "serverless_paas.function_security.runtime_security_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.function_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for runtime_security_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.function_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless runtime_security_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for runtime_security_enabled",
    "remediation": "Configure serverless with security best practices for runtime_security_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.function_security_configuration.execution_timeout_configured",
    "assertion_id": "serverless_paas.function_security.execution_timeout_configured",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.function_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_execution_timeout_seconds": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for execution_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.function_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless execution_timeout_configured implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for execution_timeout_configured",
    "remediation": "Configure serverless with security best practices for execution_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.function_security_configuration.memory_limits_enforced",
    "assertion_id": "serverless_paas.function_security.memory_limits_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.function_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for memory_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.function_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless memory_limits_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for memory_limits_enforced",
    "remediation": "Configure serverless with security best practices for memory_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.function_security_configuration.runtime_security_enabled",
    "assertion_id": "serverless_paas.function_security.runtime_security_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.function_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for runtime_security_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.function_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless runtime_security_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for runtime_security_enabled",
    "remediation": "Configure serverless with security best practices for runtime_security_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.function_security_configuration.execution_timeout_configured",
    "assertion_id": "serverless_paas.function_security.execution_timeout_configured",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.function_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_execution_timeout_seconds": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for execution_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.function_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless execution_timeout_configured implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for execution_timeout_configured",
    "remediation": "Configure serverless with security best practices for execution_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.function_security_configuration.memory_limits_enforced",
    "assertion_id": "serverless_paas.function_security.memory_limits_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.function_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for memory_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.function_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless memory_limits_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for memory_limits_enforced",
    "remediation": "Configure serverless with security best practices for memory_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.api_security_configuration.rate_limiting_enabled",
    "assertion_id": "serverless_paas.api_security.rate_limiting_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.api_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for rate_limiting_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.api_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless rate_limiting_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for rate_limiting_enabled",
    "remediation": "Configure serverless with security best practices for rate_limiting_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.api_security_configuration.authentication_required",
    "assertion_id": "serverless_paas.api_security.authentication_required",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.api_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for authentication_required to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.api_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless authentication_required implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for authentication_required",
    "remediation": "Configure serverless with security best practices for authentication_required",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.api_security_configuration.input_validation_enabled",
    "assertion_id": "serverless_paas.api_security.input_validation_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.api_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for input_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.api_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless input_validation_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for input_validation_enabled",
    "remediation": "Configure serverless with security best practices for input_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.api_security_configuration.rate_limiting_enabled",
    "assertion_id": "serverless_paas.api_security.rate_limiting_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.api_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for rate_limiting_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.api_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless rate_limiting_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for rate_limiting_enabled",
    "remediation": "Configure serverless with security best practices for rate_limiting_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.api_security_configuration.authentication_required",
    "assertion_id": "serverless_paas.api_security.authentication_required",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.api_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for authentication_required to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.api_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless authentication_required implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for authentication_required",
    "remediation": "Configure serverless with security best practices for authentication_required",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.api_security_configuration.input_validation_enabled",
    "assertion_id": "serverless_paas.api_security.input_validation_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.api_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for input_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.api_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless input_validation_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for input_validation_enabled",
    "remediation": "Configure serverless with security best practices for input_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.api_security_configuration.rate_limiting_enabled",
    "assertion_id": "serverless_paas.api_security.rate_limiting_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.api_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for rate_limiting_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.api_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless rate_limiting_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for rate_limiting_enabled",
    "remediation": "Configure serverless with security best practices for rate_limiting_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.api_security_configuration.authentication_required",
    "assertion_id": "serverless_paas.api_security.authentication_required",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.api_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for authentication_required to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.api_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless authentication_required implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for authentication_required",
    "remediation": "Configure serverless with security best practices for authentication_required",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.api_security_configuration.input_validation_enabled",
    "assertion_id": "serverless_paas.api_security.input_validation_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.api_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for input_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.api_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless input_validation_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for input_validation_enabled",
    "remediation": "Configure serverless with security best practices for input_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.paas_security_configuration.platform_hardening_enabled",
    "assertion_id": "serverless_paas.paas_security.platform_hardening_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.paas_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for platform_hardening_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.paas_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless platform_hardening_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for platform_hardening_enabled",
    "remediation": "Configure serverless with security best practices for platform_hardening_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.paas_security_configuration.secure_configuration_enforced",
    "assertion_id": "serverless_paas.paas_security.secure_configuration_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.paas_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for secure_configuration_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.paas_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless secure_configuration_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for secure_configuration_enforced",
    "remediation": "Configure serverless with security best practices for secure_configuration_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.paas_security_configuration.platform_hardening_enabled",
    "assertion_id": "serverless_paas.paas_security.platform_hardening_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.paas_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for platform_hardening_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.paas_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless platform_hardening_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for platform_hardening_enabled",
    "remediation": "Configure serverless with security best practices for platform_hardening_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.paas_security_configuration.secure_configuration_enforced",
    "assertion_id": "serverless_paas.paas_security.secure_configuration_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.paas_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for secure_configuration_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.paas_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless secure_configuration_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for secure_configuration_enforced",
    "remediation": "Configure serverless with security best practices for secure_configuration_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.paas_security_configuration.platform_hardening_enabled",
    "assertion_id": "serverless_paas.paas_security.platform_hardening_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.paas_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for platform_hardening_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.paas_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless platform_hardening_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for platform_hardening_enabled",
    "remediation": "Configure serverless with security best practices for platform_hardening_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.paas_security_configuration.secure_configuration_enforced",
    "assertion_id": "serverless_paas.paas_security.secure_configuration_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.paas_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for secure_configuration_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.paas_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless secure_configuration_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for secure_configuration_enforced",
    "remediation": "Configure serverless with security best practices for secure_configuration_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.event_security_configuration.event_encryption_enabled",
    "assertion_id": "serverless_paas.event_security.event_encryption_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.event_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for event_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.event_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless event_encryption_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for event_encryption_enabled",
    "remediation": "Configure serverless with security best practices for event_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.event_security_configuration.event_validation_enabled",
    "assertion_id": "serverless_paas.event_security.event_validation_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.event_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for event_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.event_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless event_validation_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for event_validation_enabled",
    "remediation": "Configure serverless with security best practices for event_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.event_security_configuration.event_encryption_enabled",
    "assertion_id": "serverless_paas.event_security.event_encryption_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.event_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for event_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.event_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless event_encryption_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for event_encryption_enabled",
    "remediation": "Configure serverless with security best practices for event_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.event_security_configuration.event_validation_enabled",
    "assertion_id": "serverless_paas.event_security.event_validation_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.event_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for event_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.event_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless event_validation_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for event_validation_enabled",
    "remediation": "Configure serverless with security best practices for event_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.event_security_configuration.event_encryption_enabled",
    "assertion_id": "serverless_paas.event_security.event_encryption_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.event_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for event_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.event_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless event_encryption_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for event_encryption_enabled",
    "remediation": "Configure serverless with security best practices for event_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.event_security_configuration.event_validation_enabled",
    "assertion_id": "serverless_paas.event_security.event_validation_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.event_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for event_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.event_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless event_validation_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for event_validation_enabled",
    "remediation": "Configure serverless with security best practices for event_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.resource_limits_configuration.concurrency_limits_enforced",
    "assertion_id": "serverless_paas.resource_limits.concurrency_limits_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.resource_limits_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_concurrent_executions": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for concurrency_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.resource_limits_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless concurrency_limits_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for concurrency_limits_enforced",
    "remediation": "Configure serverless with security best practices for concurrency_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.resource_limits_configuration.cost_controls_enabled",
    "assertion_id": "serverless_paas.resource_limits.cost_controls_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.resource_limits_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for cost_controls_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.resource_limits_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless cost_controls_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for cost_controls_enabled",
    "remediation": "Configure serverless with security best practices for cost_controls_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.resource_limits_configuration.concurrency_limits_enforced",
    "assertion_id": "serverless_paas.resource_limits.concurrency_limits_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.resource_limits_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_concurrent_executions": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for concurrency_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.resource_limits_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless concurrency_limits_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for concurrency_limits_enforced",
    "remediation": "Configure serverless with security best practices for concurrency_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.resource_limits_configuration.cost_controls_enabled",
    "assertion_id": "serverless_paas.resource_limits.cost_controls_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.resource_limits_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for cost_controls_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.resource_limits_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless cost_controls_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for cost_controls_enabled",
    "remediation": "Configure serverless with security best practices for cost_controls_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.resource_limits_configuration.concurrency_limits_enforced",
    "assertion_id": "serverless_paas.resource_limits.concurrency_limits_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.resource_limits_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_concurrent_executions": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for concurrency_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.resource_limits_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless concurrency_limits_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for concurrency_limits_enforced",
    "remediation": "Configure serverless with security best practices for concurrency_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.resource_limits_configuration.cost_controls_enabled",
    "assertion_id": "serverless_paas.resource_limits.cost_controls_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.resource_limits_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for cost_controls_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.resource_limits_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless cost_controls_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for cost_controls_enabled",
    "remediation": "Configure serverless with security best practices for cost_controls_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.registry_security_configuration.access_control_enforced",
    "assertion_id": "supply_chain_registries.registry_security.access_control_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.registry_security_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for access_control_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.registry_security_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute access_control_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for access_control_enforced",
    "remediation": "Configure compute with security best practices for access_control_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.registry_security_configuration.vulnerability_scanning_enabled",
    "assertion_id": "supply_chain_registries.registry_security.vulnerability_scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.registry_security_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for vulnerability_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.registry_security_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vulnerability_scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vulnerability_scanning_enabled",
    "remediation": "Configure compute with security best practices for vulnerability_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.registry_security_configuration.immutable_tags_enforced",
    "assertion_id": "supply_chain_registries.registry_security.immutable_tags_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.registry_security_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for immutable_tags_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.registry_security_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute immutable_tags_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for immutable_tags_enforced",
    "remediation": "Configure compute with security best practices for immutable_tags_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.registry_security_configuration.access_control_enforced",
    "assertion_id": "supply_chain_registries.registry_security.access_control_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.registry_security_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for access_control_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.registry_security_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute access_control_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for access_control_enforced",
    "remediation": "Configure compute with security best practices for access_control_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.registry_security_configuration.vulnerability_scanning_enabled",
    "assertion_id": "supply_chain_registries.registry_security.vulnerability_scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.registry_security_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for vulnerability_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.registry_security_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vulnerability_scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vulnerability_scanning_enabled",
    "remediation": "Configure compute with security best practices for vulnerability_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.registry_security_configuration.immutable_tags_enforced",
    "assertion_id": "supply_chain_registries.registry_security.immutable_tags_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.registry_security_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for immutable_tags_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.registry_security_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute immutable_tags_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for immutable_tags_enforced",
    "remediation": "Configure compute with security best practices for immutable_tags_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.dependency_management_configuration.dependency_scanning_enabled",
    "assertion_id": "supply_chain_registries.dependency_management.dependency_scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.dependency_management_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for dependency_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.dependency_management_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute dependency_scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for dependency_scanning_enabled",
    "remediation": "Configure compute with security best practices for dependency_scanning_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.dependency_management_configuration.license_compliance_checked",
    "assertion_id": "supply_chain_registries.dependency_management.license_compliance_checked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.dependency_management_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for license_compliance_checked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.dependency_management_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute license_compliance_checked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for license_compliance_checked",
    "remediation": "Configure compute with security best practices for license_compliance_checked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.dependency_management_configuration.outdated_dependencies_blocked",
    "assertion_id": "supply_chain_registries.dependency_management.outdated_dependencies_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.dependency_management_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for outdated_dependencies_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.dependency_management_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute outdated_dependencies_blocked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for outdated_dependencies_blocked",
    "remediation": "Configure compute with security best practices for outdated_dependencies_blocked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.dependency_management_configuration.dependency_scanning_enabled",
    "assertion_id": "supply_chain_registries.dependency_management.dependency_scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.dependency_management_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for dependency_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.dependency_management_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute dependency_scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for dependency_scanning_enabled",
    "remediation": "Configure compute with security best practices for dependency_scanning_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.dependency_management_configuration.license_compliance_checked",
    "assertion_id": "supply_chain_registries.dependency_management.license_compliance_checked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.dependency_management_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for license_compliance_checked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.dependency_management_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute license_compliance_checked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for license_compliance_checked",
    "remediation": "Configure compute with security best practices for license_compliance_checked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.dependency_management_configuration.outdated_dependencies_blocked",
    "assertion_id": "supply_chain_registries.dependency_management.outdated_dependencies_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.dependency_management_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for outdated_dependencies_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.dependency_management_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute outdated_dependencies_blocked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for outdated_dependencies_blocked",
    "remediation": "Configure compute with security best practices for outdated_dependencies_blocked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.build_security_configuration.secure_build_environments",
    "assertion_id": "supply_chain_registries.build_security.secure_build_environments",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.build_security_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for secure_build_environments to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.build_security_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute secure_build_environments implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for secure_build_environments",
    "remediation": "Configure compute with security best practices for secure_build_environments",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.build_security_configuration.build_artifacts_signed",
    "assertion_id": "supply_chain_registries.build_security.build_artifacts_signed",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.build_security_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for build_artifacts_signed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.build_security_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute build_artifacts_signed implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for build_artifacts_signed",
    "remediation": "Configure compute with security best practices for build_artifacts_signed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.build_security_configuration.build_secrets_protected",
    "assertion_id": "supply_chain_registries.build_security.build_secrets_protected",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.build_security_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for build_secrets_protected to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.build_security_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute build_secrets_protected implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for build_secrets_protected",
    "remediation": "Configure compute with security best practices for build_secrets_protected",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.build_security_configuration.secure_build_environments",
    "assertion_id": "supply_chain_registries.build_security.secure_build_environments",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.build_security_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for secure_build_environments to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.build_security_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute secure_build_environments implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for secure_build_environments",
    "remediation": "Configure compute with security best practices for secure_build_environments",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.build_security_configuration.build_artifacts_signed",
    "assertion_id": "supply_chain_registries.build_security.build_artifacts_signed",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.build_security_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for build_artifacts_signed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.build_security_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute build_artifacts_signed implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for build_artifacts_signed",
    "remediation": "Configure compute with security best practices for build_artifacts_signed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.build_security_configuration.build_secrets_protected",
    "assertion_id": "supply_chain_registries.build_security.build_secrets_protected",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.build_security_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for build_secrets_protected to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.build_security_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute build_secrets_protected implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for build_secrets_protected",
    "remediation": "Configure compute with security best practices for build_secrets_protected",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.vulnerability_scanning_configuration.continuous_scanning_enabled",
    "assertion_id": "supply_chain_registries.vulnerability_scanning.continuous_scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.vulnerability_scanning_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "scan_frequency_hours": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for continuous_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.vulnerability_scanning_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute continuous_scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for continuous_scanning_enabled",
    "remediation": "Configure compute with security best practices for continuous_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.vulnerability_scanning_configuration.critical_vulnerabilities_blocked",
    "assertion_id": "supply_chain_registries.vulnerability_scanning.critical_vulnerabilities_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.vulnerability_scanning_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for critical_vulnerabilities_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.vulnerability_scanning_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute critical_vulnerabilities_blocked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for critical_vulnerabilities_blocked",
    "remediation": "Configure compute with security best practices for critical_vulnerabilities_blocked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.vulnerability_scanning_configuration.continuous_scanning_enabled",
    "assertion_id": "supply_chain_registries.vulnerability_scanning.continuous_scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.vulnerability_scanning_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "scan_frequency_hours": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for continuous_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.vulnerability_scanning_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute continuous_scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for continuous_scanning_enabled",
    "remediation": "Configure compute with security best practices for continuous_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.vulnerability_scanning_configuration.critical_vulnerabilities_blocked",
    "assertion_id": "supply_chain_registries.vulnerability_scanning.critical_vulnerabilities_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.vulnerability_scanning_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for critical_vulnerabilities_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.vulnerability_scanning_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute critical_vulnerabilities_blocked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for critical_vulnerabilities_blocked",
    "remediation": "Configure compute with security best practices for critical_vulnerabilities_blocked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.signing_verification_configuration.digital_signatures_verified",
    "assertion_id": "supply_chain_registries.signing_verification.digital_signatures_verified",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.signing_verification_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for digital_signatures_verified to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.signing_verification_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute digital_signatures_verified implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for digital_signatures_verified",
    "remediation": "Configure compute with security best practices for digital_signatures_verified",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.signing_verification_configuration.chain_of_trust_maintained",
    "assertion_id": "supply_chain_registries.signing_verification.chain_of_trust_maintained",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.signing_verification_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for chain_of_trust_maintained to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.signing_verification_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute chain_of_trust_maintained implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for chain_of_trust_maintained",
    "remediation": "Configure compute with security best practices for chain_of_trust_maintained",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.signing_verification_configuration.digital_signatures_verified",
    "assertion_id": "supply_chain_registries.signing_verification.digital_signatures_verified",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.signing_verification_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for digital_signatures_verified to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.signing_verification_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute digital_signatures_verified implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for digital_signatures_verified",
    "remediation": "Configure compute with security best practices for digital_signatures_verified",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.signing_verification_configuration.chain_of_trust_maintained",
    "assertion_id": "supply_chain_registries.signing_verification.chain_of_trust_maintained",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.signing_verification_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for chain_of_trust_maintained to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.signing_verification_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute chain_of_trust_maintained implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for chain_of_trust_maintained",
    "remediation": "Configure compute with security best practices for chain_of_trust_maintained",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_collection_configuration.centralized_logging_enabled",
    "assertion_id": "logging_monitoring.log_collection.centralized_logging_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_collection_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for centralized_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_collection_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring centralized_logging_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for centralized_logging_enabled",
    "remediation": "Configure monitoring with security best practices for centralized_logging_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_collection_configuration.log_integrity_protected",
    "assertion_id": "logging_monitoring.log_collection.log_integrity_protected",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_collection_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for log_integrity_protected to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_collection_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring log_integrity_protected implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for log_integrity_protected",
    "remediation": "Configure monitoring with security best practices for log_integrity_protected",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_collection_configuration.structured_logging_enforced",
    "assertion_id": "logging_monitoring.log_collection.structured_logging_enforced",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_collection_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for structured_logging_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_collection_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring structured_logging_enforced implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for structured_logging_enforced",
    "remediation": "Configure monitoring with security best practices for structured_logging_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_collection_configuration.centralized_logging_enabled",
    "assertion_id": "logging_monitoring.log_collection.centralized_logging_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_collection_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for centralized_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_collection_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring centralized_logging_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for centralized_logging_enabled",
    "remediation": "Configure monitoring with security best practices for centralized_logging_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_collection_configuration.log_integrity_protected",
    "assertion_id": "logging_monitoring.log_collection.log_integrity_protected",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_collection_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for log_integrity_protected to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_collection_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring log_integrity_protected implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for log_integrity_protected",
    "remediation": "Configure monitoring with security best practices for log_integrity_protected",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_collection_configuration.structured_logging_enforced",
    "assertion_id": "logging_monitoring.log_collection.structured_logging_enforced",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_collection_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for structured_logging_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_collection_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring structured_logging_enforced implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for structured_logging_enforced",
    "remediation": "Configure monitoring with security best practices for structured_logging_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_collection_configuration.centralized_logging_enabled",
    "assertion_id": "logging_monitoring.log_collection.centralized_logging_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_collection_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for centralized_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_collection_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter centralized_logging_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for centralized_logging_enabled",
    "remediation": "Configure securitycenter with security best practices for centralized_logging_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_collection_configuration.log_integrity_protected",
    "assertion_id": "logging_monitoring.log_collection.log_integrity_protected",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_collection_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for log_integrity_protected to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_collection_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter log_integrity_protected implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for log_integrity_protected",
    "remediation": "Configure securitycenter with security best practices for log_integrity_protected",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_collection_configuration.structured_logging_enforced",
    "assertion_id": "logging_monitoring.log_collection.structured_logging_enforced",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_collection_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for structured_logging_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_collection_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter structured_logging_enforced implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for structured_logging_enforced",
    "remediation": "Configure securitycenter with security best practices for structured_logging_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.monitoring_alerting_configuration.real_time_monitoring_enabled",
    "assertion_id": "logging_monitoring.monitoring_alerting.real_time_monitoring_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.monitoring_alerting_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for real_time_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.monitoring_alerting_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring real_time_monitoring_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for real_time_monitoring_enabled",
    "remediation": "Configure monitoring with security best practices for real_time_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.monitoring_alerting_configuration.alerting_rules_configured",
    "assertion_id": "logging_monitoring.monitoring_alerting.alerting_rules_configured",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.monitoring_alerting_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for alerting_rules_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.monitoring_alerting_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring alerting_rules_configured implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for alerting_rules_configured",
    "remediation": "Configure monitoring with security best practices for alerting_rules_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.monitoring_alerting_configuration.performance_monitoring_enabled",
    "assertion_id": "logging_monitoring.monitoring_alerting.performance_monitoring_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.monitoring_alerting_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for performance_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.monitoring_alerting_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring performance_monitoring_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for performance_monitoring_enabled",
    "remediation": "Configure monitoring with security best practices for performance_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.monitoring_alerting_configuration.real_time_monitoring_enabled",
    "assertion_id": "logging_monitoring.monitoring_alerting.real_time_monitoring_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.monitoring_alerting_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for real_time_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.monitoring_alerting_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring real_time_monitoring_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for real_time_monitoring_enabled",
    "remediation": "Configure monitoring with security best practices for real_time_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.monitoring_alerting_configuration.alerting_rules_configured",
    "assertion_id": "logging_monitoring.monitoring_alerting.alerting_rules_configured",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.monitoring_alerting_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for alerting_rules_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.monitoring_alerting_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring alerting_rules_configured implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for alerting_rules_configured",
    "remediation": "Configure monitoring with security best practices for alerting_rules_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.monitoring_alerting_configuration.performance_monitoring_enabled",
    "assertion_id": "logging_monitoring.monitoring_alerting.performance_monitoring_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.monitoring_alerting_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for performance_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.monitoring_alerting_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring performance_monitoring_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for performance_monitoring_enabled",
    "remediation": "Configure monitoring with security best practices for performance_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.monitoring_alerting_configuration.real_time_monitoring_enabled",
    "assertion_id": "logging_monitoring.monitoring_alerting.real_time_monitoring_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.securitycenter.monitoring_alerting_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for real_time_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.monitoring_alerting_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter real_time_monitoring_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for real_time_monitoring_enabled",
    "remediation": "Configure securitycenter with security best practices for real_time_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.monitoring_alerting_configuration.alerting_rules_configured",
    "assertion_id": "logging_monitoring.monitoring_alerting.alerting_rules_configured",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.securitycenter.monitoring_alerting_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for alerting_rules_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.monitoring_alerting_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter alerting_rules_configured implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for alerting_rules_configured",
    "remediation": "Configure securitycenter with security best practices for alerting_rules_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.monitoring_alerting_configuration.performance_monitoring_enabled",
    "assertion_id": "logging_monitoring.monitoring_alerting.performance_monitoring_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.securitycenter.monitoring_alerting_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for performance_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.monitoring_alerting_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter performance_monitoring_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for performance_monitoring_enabled",
    "remediation": "Configure securitycenter with security best practices for performance_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.audit_logging_configuration.security_events_logged",
    "assertion_id": "logging_monitoring.audit_logging.security_events_logged",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.audit_logging_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for security_events_logged to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.audit_logging_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring security_events_logged implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for security_events_logged",
    "remediation": "Configure monitoring with security best practices for security_events_logged",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.audit_logging_configuration.audit_trail_integrity_maintained",
    "assertion_id": "logging_monitoring.audit_logging.audit_trail_integrity_maintained",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.audit_logging_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for audit_trail_integrity_maintained to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.audit_logging_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring audit_trail_integrity_maintained implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for audit_trail_integrity_maintained",
    "remediation": "Configure monitoring with security best practices for audit_trail_integrity_maintained",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.audit_logging_configuration.compliance_logging_enabled",
    "assertion_id": "logging_monitoring.audit_logging.compliance_logging_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.audit_logging_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for compliance_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.audit_logging_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring compliance_logging_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for compliance_logging_enabled",
    "remediation": "Configure monitoring with security best practices for compliance_logging_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.audit_logging_configuration.security_events_logged",
    "assertion_id": "logging_monitoring.audit_logging.security_events_logged",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.monitoring.audit_logging_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for security_events_logged to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.audit_logging_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring security_events_logged implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for security_events_logged",
    "remediation": "Configure monitoring with security best practices for security_events_logged",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.audit_logging_configuration.audit_trail_integrity_maintained",
    "assertion_id": "logging_monitoring.audit_logging.audit_trail_integrity_maintained",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.monitoring.audit_logging_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for audit_trail_integrity_maintained to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.audit_logging_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring audit_trail_integrity_maintained implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for audit_trail_integrity_maintained",
    "remediation": "Configure monitoring with security best practices for audit_trail_integrity_maintained",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.audit_logging_configuration.compliance_logging_enabled",
    "assertion_id": "logging_monitoring.audit_logging.compliance_logging_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.monitoring.audit_logging_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for compliance_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.audit_logging_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring compliance_logging_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for compliance_logging_enabled",
    "remediation": "Configure monitoring with security best practices for compliance_logging_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.audit_logging_configuration.security_events_logged",
    "assertion_id": "logging_monitoring.audit_logging.security_events_logged",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.securitycenter.audit_logging_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for security_events_logged to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.audit_logging_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter security_events_logged implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for security_events_logged",
    "remediation": "Configure securitycenter with security best practices for security_events_logged",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.audit_logging_configuration.audit_trail_integrity_maintained",
    "assertion_id": "logging_monitoring.audit_logging.audit_trail_integrity_maintained",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.securitycenter.audit_logging_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for audit_trail_integrity_maintained to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.audit_logging_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter audit_trail_integrity_maintained implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for audit_trail_integrity_maintained",
    "remediation": "Configure securitycenter with security best practices for audit_trail_integrity_maintained",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.audit_logging_configuration.compliance_logging_enabled",
    "assertion_id": "logging_monitoring.audit_logging.compliance_logging_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.securitycenter.audit_logging_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for compliance_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.audit_logging_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter compliance_logging_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for compliance_logging_enabled",
    "remediation": "Configure securitycenter with security best practices for compliance_logging_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_retention_configuration.retention_policies_enforced",
    "assertion_id": "logging_monitoring.log_retention.retention_policies_enforced",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_retention_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for retention_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_retention_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring retention_policies_enforced implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for retention_policies_enforced",
    "remediation": "Configure monitoring with security best practices for retention_policies_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_retention_configuration.secure_deletion_enabled",
    "assertion_id": "logging_monitoring.log_retention.secure_deletion_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_retention_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for secure_deletion_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_retention_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring secure_deletion_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for secure_deletion_enabled",
    "remediation": "Configure monitoring with security best practices for secure_deletion_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_retention_configuration.retention_policies_enforced",
    "assertion_id": "logging_monitoring.log_retention.retention_policies_enforced",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_retention_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for retention_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_retention_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring retention_policies_enforced implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for retention_policies_enforced",
    "remediation": "Configure monitoring with security best practices for retention_policies_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_retention_configuration.secure_deletion_enabled",
    "assertion_id": "logging_monitoring.log_retention.secure_deletion_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_retention_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for secure_deletion_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_retention_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring secure_deletion_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for secure_deletion_enabled",
    "remediation": "Configure monitoring with security best practices for secure_deletion_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_retention_configuration.retention_policies_enforced",
    "assertion_id": "logging_monitoring.log_retention.retention_policies_enforced",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_retention_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for retention_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_retention_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter retention_policies_enforced implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for retention_policies_enforced",
    "remediation": "Configure securitycenter with security best practices for retention_policies_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_retention_configuration.secure_deletion_enabled",
    "assertion_id": "logging_monitoring.log_retention.secure_deletion_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_retention_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for secure_deletion_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_retention_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter secure_deletion_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for secure_deletion_enabled",
    "remediation": "Configure securitycenter with security best practices for secure_deletion_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_analysis_configuration.anomaly_detection_enabled",
    "assertion_id": "logging_monitoring.log_analysis.anomaly_detection_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_analysis_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for anomaly_detection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_analysis_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring anomaly_detection_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for anomaly_detection_enabled",
    "remediation": "Configure monitoring with security best practices for anomaly_detection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_analysis_configuration.correlation_analysis_enabled",
    "assertion_id": "logging_monitoring.log_analysis.correlation_analysis_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_analysis_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for correlation_analysis_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_analysis_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring correlation_analysis_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for correlation_analysis_enabled",
    "remediation": "Configure monitoring with security best practices for correlation_analysis_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_analysis_configuration.anomaly_detection_enabled",
    "assertion_id": "logging_monitoring.log_analysis.anomaly_detection_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_analysis_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for anomaly_detection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_analysis_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring anomaly_detection_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for anomaly_detection_enabled",
    "remediation": "Configure monitoring with security best practices for anomaly_detection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_analysis_configuration.correlation_analysis_enabled",
    "assertion_id": "logging_monitoring.log_analysis.correlation_analysis_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_analysis_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for correlation_analysis_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_analysis_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring correlation_analysis_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for correlation_analysis_enabled",
    "remediation": "Configure monitoring with security best practices for correlation_analysis_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_analysis_configuration.anomaly_detection_enabled",
    "assertion_id": "logging_monitoring.log_analysis.anomaly_detection_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_analysis_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for anomaly_detection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_analysis_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter anomaly_detection_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for anomaly_detection_enabled",
    "remediation": "Configure securitycenter with security best practices for anomaly_detection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_analysis_configuration.correlation_analysis_enabled",
    "assertion_id": "logging_monitoring.log_analysis.correlation_analysis_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_analysis_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for correlation_analysis_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_analysis_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter correlation_analysis_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for correlation_analysis_enabled",
    "remediation": "Configure securitycenter with security best practices for correlation_analysis_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.backup_strategy_configuration.automated_backups_enabled",
    "assertion_id": "resilience_recovery.backup_strategy.automated_backups_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.backup_strategy_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for automated_backups_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.backup_strategy_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute automated_backups_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for automated_backups_enabled",
    "remediation": "Configure compute with security best practices for automated_backups_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.backup_strategy_configuration.backup_testing_conducted",
    "assertion_id": "resilience_recovery.backup_strategy.backup_testing_conducted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.backup_strategy_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "test_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for backup_testing_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.backup_strategy_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute backup_testing_conducted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for backup_testing_conducted",
    "remediation": "Configure compute with security best practices for backup_testing_conducted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.backup_strategy_configuration.geographic_redundancy_enabled",
    "assertion_id": "resilience_recovery.backup_strategy.geographic_redundancy_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.backup_strategy_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for geographic_redundancy_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.backup_strategy_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute geographic_redundancy_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for geographic_redundancy_enabled",
    "remediation": "Configure compute with security best practices for geographic_redundancy_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.backup_strategy_configuration.automated_backups_enabled",
    "assertion_id": "resilience_recovery.backup_strategy.automated_backups_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.backup_strategy_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for automated_backups_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.backup_strategy_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage automated_backups_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for automated_backups_enabled",
    "remediation": "Configure storage with security best practices for automated_backups_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.backup_strategy_configuration.backup_testing_conducted",
    "assertion_id": "resilience_recovery.backup_strategy.backup_testing_conducted",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.backup_strategy_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "test_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for backup_testing_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.backup_strategy_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage backup_testing_conducted implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for backup_testing_conducted",
    "remediation": "Configure storage with security best practices for backup_testing_conducted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.backup_strategy_configuration.geographic_redundancy_enabled",
    "assertion_id": "resilience_recovery.backup_strategy.geographic_redundancy_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.backup_strategy_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for geographic_redundancy_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.backup_strategy_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage geographic_redundancy_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for geographic_redundancy_enabled",
    "remediation": "Configure storage with security best practices for geographic_redundancy_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disaster_recovery_configuration.dr_plan_documented",
    "assertion_id": "resilience_recovery.disaster_recovery.dr_plan_documented",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disaster_recovery_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for dr_plan_documented to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disaster_recovery_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute dr_plan_documented implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for dr_plan_documented",
    "remediation": "Configure compute with security best practices for dr_plan_documented",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disaster_recovery_configuration.rto_rpo_defined",
    "assertion_id": "resilience_recovery.disaster_recovery.rto_rpo_defined",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disaster_recovery_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_rto_hours": "integer",
      "max_rpo_hours": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for rto_rpo_defined to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disaster_recovery_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute rto_rpo_defined implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for rto_rpo_defined",
    "remediation": "Configure compute with security best practices for rto_rpo_defined",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disaster_recovery_configuration.cross_region_replication_enabled",
    "assertion_id": "resilience_recovery.disaster_recovery.cross_region_replication_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disaster_recovery_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for cross_region_replication_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disaster_recovery_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute cross_region_replication_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for cross_region_replication_enabled",
    "remediation": "Configure compute with security best practices for cross_region_replication_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.disaster_recovery_configuration.dr_plan_documented",
    "assertion_id": "resilience_recovery.disaster_recovery.dr_plan_documented",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.disaster_recovery_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for dr_plan_documented to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.disaster_recovery_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage dr_plan_documented implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for dr_plan_documented",
    "remediation": "Configure storage with security best practices for dr_plan_documented",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.disaster_recovery_configuration.rto_rpo_defined",
    "assertion_id": "resilience_recovery.disaster_recovery.rto_rpo_defined",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.disaster_recovery_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_rto_hours": "integer",
      "max_rpo_hours": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for rto_rpo_defined to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.disaster_recovery_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage rto_rpo_defined implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for rto_rpo_defined",
    "remediation": "Configure storage with security best practices for rto_rpo_defined",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.disaster_recovery_configuration.cross_region_replication_enabled",
    "assertion_id": "resilience_recovery.disaster_recovery.cross_region_replication_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.disaster_recovery_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for cross_region_replication_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.disaster_recovery_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage cross_region_replication_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for cross_region_replication_enabled",
    "remediation": "Configure storage with security best practices for cross_region_replication_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.high_availability_configuration.load_balancing_configured",
    "assertion_id": "resilience_recovery.high_availability.load_balancing_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.high_availability_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for load_balancing_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.high_availability_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute load_balancing_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for load_balancing_configured",
    "remediation": "Configure compute with security best practices for load_balancing_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.high_availability_configuration.auto_scaling_enabled",
    "assertion_id": "resilience_recovery.high_availability.auto_scaling_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.high_availability_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for auto_scaling_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.high_availability_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute auto_scaling_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for auto_scaling_enabled",
    "remediation": "Configure compute with security best practices for auto_scaling_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.high_availability_configuration.health_checks_configured",
    "assertion_id": "resilience_recovery.high_availability.health_checks_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.high_availability_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for health_checks_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.high_availability_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute health_checks_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for health_checks_configured",
    "remediation": "Configure compute with security best practices for health_checks_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.high_availability_configuration.load_balancing_configured",
    "assertion_id": "resilience_recovery.high_availability.load_balancing_configured",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.high_availability_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for load_balancing_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.high_availability_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage load_balancing_configured implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for load_balancing_configured",
    "remediation": "Configure storage with security best practices for load_balancing_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.high_availability_configuration.auto_scaling_enabled",
    "assertion_id": "resilience_recovery.high_availability.auto_scaling_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.high_availability_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for auto_scaling_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.high_availability_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage auto_scaling_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for auto_scaling_enabled",
    "remediation": "Configure storage with security best practices for auto_scaling_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.high_availability_configuration.health_checks_configured",
    "assertion_id": "resilience_recovery.high_availability.health_checks_configured",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.high_availability_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for health_checks_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.high_availability_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage health_checks_configured implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for health_checks_configured",
    "remediation": "Configure storage with security best practices for health_checks_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.recovery_testing_configuration.dr_drills_conducted",
    "assertion_id": "resilience_recovery.recovery_testing.dr_drills_conducted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.recovery_testing_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "drill_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for dr_drills_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.recovery_testing_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute dr_drills_conducted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for dr_drills_conducted",
    "remediation": "Configure compute with security best practices for dr_drills_conducted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.recovery_testing_configuration.backup_restoration_tested",
    "assertion_id": "resilience_recovery.recovery_testing.backup_restoration_tested",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.recovery_testing_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for backup_restoration_tested to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.recovery_testing_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute backup_restoration_tested implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for backup_restoration_tested",
    "remediation": "Configure compute with security best practices for backup_restoration_tested",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.recovery_testing_configuration.dr_drills_conducted",
    "assertion_id": "resilience_recovery.recovery_testing.dr_drills_conducted",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.recovery_testing_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "drill_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for dr_drills_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.recovery_testing_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage dr_drills_conducted implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for dr_drills_conducted",
    "remediation": "Configure storage with security best practices for dr_drills_conducted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.recovery_testing_configuration.backup_restoration_tested",
    "assertion_id": "resilience_recovery.recovery_testing.backup_restoration_tested",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.recovery_testing_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for backup_restoration_tested to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.recovery_testing_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage backup_restoration_tested implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for backup_restoration_tested",
    "remediation": "Configure storage with security best practices for backup_restoration_tested",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.policy_management_configuration.security_policies_defined",
    "assertion_id": "governance_compliance.policy_management.security_policies_defined",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.policy_management_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for security_policies_defined to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.policy_management_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager security_policies_defined implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for security_policies_defined",
    "remediation": "Configure resourcemanager with security best practices for security_policies_defined",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.policy_management_configuration.policy_compliance_monitored",
    "assertion_id": "governance_compliance.policy_management.policy_compliance_monitored",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.policy_management_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for policy_compliance_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.policy_management_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager policy_compliance_monitored implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for policy_compliance_monitored",
    "remediation": "Configure resourcemanager with security best practices for policy_compliance_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.policy_management_configuration.policy_exceptions_managed",
    "assertion_id": "governance_compliance.policy_management.policy_exceptions_managed",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.policy_management_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for policy_exceptions_managed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.policy_management_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager policy_exceptions_managed implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for policy_exceptions_managed",
    "remediation": "Configure resourcemanager with security best practices for policy_exceptions_managed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.policy_management_configuration.security_policies_defined",
    "assertion_id": "governance_compliance.policy_management.security_policies_defined",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.policy_management_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for security_policies_defined to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.policy_management_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter security_policies_defined implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for security_policies_defined",
    "remediation": "Configure securitycenter with security best practices for security_policies_defined",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.policy_management_configuration.policy_compliance_monitored",
    "assertion_id": "governance_compliance.policy_management.policy_compliance_monitored",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.policy_management_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for policy_compliance_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.policy_management_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter policy_compliance_monitored implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for policy_compliance_monitored",
    "remediation": "Configure securitycenter with security best practices for policy_compliance_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.policy_management_configuration.policy_exceptions_managed",
    "assertion_id": "governance_compliance.policy_management.policy_exceptions_managed",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.policy_management_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for policy_exceptions_managed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.policy_management_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter policy_exceptions_managed implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for policy_exceptions_managed",
    "remediation": "Configure securitycenter with security best practices for policy_exceptions_managed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.policy_management_configuration.security_policies_defined",
    "assertion_id": "governance_compliance.policy_management.security_policies_defined",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.policy_management_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for security_policies_defined to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.policy_management_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute security_policies_defined implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for security_policies_defined",
    "remediation": "Configure compute with security best practices for security_policies_defined",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.policy_management_configuration.policy_compliance_monitored",
    "assertion_id": "governance_compliance.policy_management.policy_compliance_monitored",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.policy_management_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for policy_compliance_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.policy_management_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute policy_compliance_monitored implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for policy_compliance_monitored",
    "remediation": "Configure compute with security best practices for policy_compliance_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.policy_management_configuration.policy_exceptions_managed",
    "assertion_id": "governance_compliance.policy_management.policy_exceptions_managed",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.policy_management_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for policy_exceptions_managed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.policy_management_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute policy_exceptions_managed implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for policy_exceptions_managed",
    "remediation": "Configure compute with security best practices for policy_exceptions_managed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.compliance_framework_configuration.regulatory_requirements_mapped",
    "assertion_id": "governance_compliance.compliance_framework.regulatory_requirements_mapped",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.compliance_framework_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for regulatory_requirements_mapped to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.compliance_framework_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager regulatory_requirements_mapped implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for regulatory_requirements_mapped",
    "remediation": "Configure resourcemanager with security best practices for regulatory_requirements_mapped",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.compliance_framework_configuration.compliance_reporting_enabled",
    "assertion_id": "governance_compliance.compliance_framework.compliance_reporting_enabled",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.compliance_framework_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for compliance_reporting_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.compliance_framework_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager compliance_reporting_enabled implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for compliance_reporting_enabled",
    "remediation": "Configure resourcemanager with security best practices for compliance_reporting_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.compliance_framework_configuration.audit_trail_maintained",
    "assertion_id": "governance_compliance.compliance_framework.audit_trail_maintained",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.compliance_framework_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for audit_trail_maintained to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.compliance_framework_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager audit_trail_maintained implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for audit_trail_maintained",
    "remediation": "Configure resourcemanager with security best practices for audit_trail_maintained",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.compliance_framework_configuration.regulatory_requirements_mapped",
    "assertion_id": "governance_compliance.compliance_framework.regulatory_requirements_mapped",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.compliance_framework_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for regulatory_requirements_mapped to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.compliance_framework_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter regulatory_requirements_mapped implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for regulatory_requirements_mapped",
    "remediation": "Configure securitycenter with security best practices for regulatory_requirements_mapped",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.compliance_framework_configuration.compliance_reporting_enabled",
    "assertion_id": "governance_compliance.compliance_framework.compliance_reporting_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.compliance_framework_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for compliance_reporting_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.compliance_framework_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter compliance_reporting_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for compliance_reporting_enabled",
    "remediation": "Configure securitycenter with security best practices for compliance_reporting_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.compliance_framework_configuration.audit_trail_maintained",
    "assertion_id": "governance_compliance.compliance_framework.audit_trail_maintained",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.compliance_framework_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for audit_trail_maintained to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.compliance_framework_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter audit_trail_maintained implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for audit_trail_maintained",
    "remediation": "Configure securitycenter with security best practices for audit_trail_maintained",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.compliance_framework_configuration.regulatory_requirements_mapped",
    "assertion_id": "governance_compliance.compliance_framework.regulatory_requirements_mapped",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.compliance_framework_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for regulatory_requirements_mapped to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.compliance_framework_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute regulatory_requirements_mapped implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for regulatory_requirements_mapped",
    "remediation": "Configure compute with security best practices for regulatory_requirements_mapped",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.compliance_framework_configuration.compliance_reporting_enabled",
    "assertion_id": "governance_compliance.compliance_framework.compliance_reporting_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.compliance_framework_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for compliance_reporting_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.compliance_framework_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute compliance_reporting_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for compliance_reporting_enabled",
    "remediation": "Configure compute with security best practices for compliance_reporting_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.compliance_framework_configuration.audit_trail_maintained",
    "assertion_id": "governance_compliance.compliance_framework.audit_trail_maintained",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.compliance_framework_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for audit_trail_maintained to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.compliance_framework_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute audit_trail_maintained implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for audit_trail_maintained",
    "remediation": "Configure compute with security best practices for audit_trail_maintained",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.resource_governance_configuration.resource_tagging_enforced",
    "assertion_id": "governance_compliance.resource_governance.resource_tagging_enforced",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.resource_governance_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for resource_tagging_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.resource_governance_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager resource_tagging_enforced implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for resource_tagging_enforced",
    "remediation": "Configure resourcemanager with security best practices for resource_tagging_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.resource_governance_configuration.resource_approval_required",
    "assertion_id": "governance_compliance.resource_governance.resource_approval_required",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.resource_governance_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for resource_approval_required to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.resource_governance_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager resource_approval_required implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for resource_approval_required",
    "remediation": "Configure resourcemanager with security best practices for resource_approval_required",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.resource_governance_configuration.resource_tagging_enforced",
    "assertion_id": "governance_compliance.resource_governance.resource_tagging_enforced",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.resource_governance_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for resource_tagging_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.resource_governance_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter resource_tagging_enforced implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for resource_tagging_enforced",
    "remediation": "Configure securitycenter with security best practices for resource_tagging_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.resource_governance_configuration.resource_approval_required",
    "assertion_id": "governance_compliance.resource_governance.resource_approval_required",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.resource_governance_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for resource_approval_required to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.resource_governance_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter resource_approval_required implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for resource_approval_required",
    "remediation": "Configure securitycenter with security best practices for resource_approval_required",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.resource_governance_configuration.resource_tagging_enforced",
    "assertion_id": "governance_compliance.resource_governance.resource_tagging_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.resource_governance_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for resource_tagging_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.resource_governance_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute resource_tagging_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for resource_tagging_enforced",
    "remediation": "Configure compute with security best practices for resource_tagging_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.resource_governance_configuration.resource_approval_required",
    "assertion_id": "governance_compliance.resource_governance.resource_approval_required",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.resource_governance_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for resource_approval_required to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.resource_governance_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute resource_approval_required implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for resource_approval_required",
    "remediation": "Configure compute with security best practices for resource_approval_required",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.cost_governance_configuration.cost_monitoring_enabled",
    "assertion_id": "governance_compliance.cost_governance.cost_monitoring_enabled",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.cost_governance_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for cost_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.cost_governance_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager cost_monitoring_enabled implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for cost_monitoring_enabled",
    "remediation": "Configure resourcemanager with security best practices for cost_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.cost_governance_configuration.budget_alerts_configured",
    "assertion_id": "governance_compliance.cost_governance.budget_alerts_configured",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.cost_governance_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for budget_alerts_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.cost_governance_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager budget_alerts_configured implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for budget_alerts_configured",
    "remediation": "Configure resourcemanager with security best practices for budget_alerts_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.cost_governance_configuration.cost_monitoring_enabled",
    "assertion_id": "governance_compliance.cost_governance.cost_monitoring_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.cost_governance_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for cost_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.cost_governance_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter cost_monitoring_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for cost_monitoring_enabled",
    "remediation": "Configure securitycenter with security best practices for cost_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.cost_governance_configuration.budget_alerts_configured",
    "assertion_id": "governance_compliance.cost_governance.budget_alerts_configured",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.cost_governance_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for budget_alerts_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.cost_governance_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter budget_alerts_configured implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for budget_alerts_configured",
    "remediation": "Configure securitycenter with security best practices for budget_alerts_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.cost_governance_configuration.cost_monitoring_enabled",
    "assertion_id": "governance_compliance.cost_governance.cost_monitoring_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.cost_governance_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for cost_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.cost_governance_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute cost_monitoring_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for cost_monitoring_enabled",
    "remediation": "Configure compute with security best practices for cost_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.cost_governance_configuration.budget_alerts_configured",
    "assertion_id": "governance_compliance.cost_governance.budget_alerts_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.cost_governance_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for budget_alerts_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.cost_governance_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute budget_alerts_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for budget_alerts_configured",
    "remediation": "Configure compute with security best practices for budget_alerts_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.version_management_configuration.supported_versions_used",
    "assertion_id": "platform_surfaces_versions.version_management.supported_versions_used",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.version_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for supported_versions_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.version_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute supported_versions_used implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for supported_versions_used",
    "remediation": "Configure compute with security best practices for supported_versions_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.version_management_configuration.version_monitoring_enabled",
    "assertion_id": "platform_surfaces_versions.version_management.version_monitoring_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.version_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for version_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.version_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute version_monitoring_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for version_monitoring_enabled",
    "remediation": "Configure compute with security best practices for version_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.version_management_configuration.supported_versions_used",
    "assertion_id": "platform_surfaces_versions.version_management.supported_versions_used",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.version_management_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for supported_versions_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.version_management_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container supported_versions_used implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for supported_versions_used",
    "remediation": "Configure container with security best practices for supported_versions_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.version_management_configuration.version_monitoring_enabled",
    "assertion_id": "platform_surfaces_versions.version_management.version_monitoring_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.version_management_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for version_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.version_management_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container version_monitoring_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for version_monitoring_enabled",
    "remediation": "Configure container with security best practices for version_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.version_management_configuration.supported_versions_used",
    "assertion_id": "platform_surfaces_versions.version_management.supported_versions_used",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.version_management_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for supported_versions_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.version_management_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless supported_versions_used implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for supported_versions_used",
    "remediation": "Configure serverless with security best practices for supported_versions_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.version_management_configuration.version_monitoring_enabled",
    "assertion_id": "platform_surfaces_versions.version_management.version_monitoring_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.version_management_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for version_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.version_management_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless version_monitoring_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for version_monitoring_enabled",
    "remediation": "Configure serverless with security best practices for version_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.deprecation_mgmt_configuration.deprecation_notices_monitored",
    "assertion_id": "platform_surfaces_versions.deprecation_mgmt.deprecation_notices_monitored",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.deprecation_mgmt_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for deprecation_notices_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.deprecation_mgmt_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute deprecation_notices_monitored implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for deprecation_notices_monitored",
    "remediation": "Configure compute with security best practices for deprecation_notices_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.deprecation_mgmt_configuration.migration_planning_enabled",
    "assertion_id": "platform_surfaces_versions.deprecation_mgmt.migration_planning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.deprecation_mgmt_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for migration_planning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.deprecation_mgmt_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute migration_planning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for migration_planning_enabled",
    "remediation": "Configure compute with security best practices for migration_planning_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.deprecation_mgmt_configuration.deprecation_notices_monitored",
    "assertion_id": "platform_surfaces_versions.deprecation_mgmt.deprecation_notices_monitored",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.deprecation_mgmt_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for deprecation_notices_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.deprecation_mgmt_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container deprecation_notices_monitored implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for deprecation_notices_monitored",
    "remediation": "Configure container with security best practices for deprecation_notices_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.deprecation_mgmt_configuration.migration_planning_enabled",
    "assertion_id": "platform_surfaces_versions.deprecation_mgmt.migration_planning_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.deprecation_mgmt_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for migration_planning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.deprecation_mgmt_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container migration_planning_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for migration_planning_enabled",
    "remediation": "Configure container with security best practices for migration_planning_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.deprecation_mgmt_configuration.deprecation_notices_monitored",
    "assertion_id": "platform_surfaces_versions.deprecation_mgmt.deprecation_notices_monitored",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.deprecation_mgmt_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for deprecation_notices_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.deprecation_mgmt_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless deprecation_notices_monitored implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for deprecation_notices_monitored",
    "remediation": "Configure serverless with security best practices for deprecation_notices_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.deprecation_mgmt_configuration.migration_planning_enabled",
    "assertion_id": "platform_surfaces_versions.deprecation_mgmt.migration_planning_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.deprecation_mgmt_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for migration_planning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.deprecation_mgmt_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless migration_planning_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for migration_planning_enabled",
    "remediation": "Configure serverless with security best practices for migration_planning_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.api_management_configuration.api_versioning_enforced",
    "assertion_id": "platform_surfaces_versions.api_management.api_versioning_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.api_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for api_versioning_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.api_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute api_versioning_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for api_versioning_enforced",
    "remediation": "Configure compute with security best practices for api_versioning_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.api_management_configuration.api_security_enforced",
    "assertion_id": "platform_surfaces_versions.api_management.api_security_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.api_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for api_security_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.api_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute api_security_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for api_security_enforced",
    "remediation": "Configure compute with security best practices for api_security_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.api_management_configuration.api_versioning_enforced",
    "assertion_id": "platform_surfaces_versions.api_management.api_versioning_enforced",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.api_management_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for api_versioning_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.api_management_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container api_versioning_enforced implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for api_versioning_enforced",
    "remediation": "Configure container with security best practices for api_versioning_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.api_management_configuration.api_security_enforced",
    "assertion_id": "platform_surfaces_versions.api_management.api_security_enforced",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.api_management_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for api_security_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.api_management_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container api_security_enforced implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for api_security_enforced",
    "remediation": "Configure container with security best practices for api_security_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.api_management_configuration.api_versioning_enforced",
    "assertion_id": "platform_surfaces_versions.api_management.api_versioning_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.api_management_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for api_versioning_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.api_management_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless api_versioning_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for api_versioning_enforced",
    "remediation": "Configure serverless with security best practices for api_versioning_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.api_management_configuration.api_security_enforced",
    "assertion_id": "platform_surfaces_versions.api_management.api_security_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.api_management_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for api_security_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.api_management_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless api_security_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for api_security_enforced",
    "remediation": "Configure serverless with security best practices for api_security_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.platform_monitoring_configuration.platform_health_monitored",
    "assertion_id": "platform_surfaces_versions.platform_monitoring.platform_health_monitored",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.platform_monitoring_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for platform_health_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.platform_monitoring_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute platform_health_monitored implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for platform_health_monitored",
    "remediation": "Configure compute with security best practices for platform_health_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.platform_monitoring_configuration.service_availability_tracked",
    "assertion_id": "platform_surfaces_versions.platform_monitoring.service_availability_tracked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.platform_monitoring_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for service_availability_tracked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.platform_monitoring_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute service_availability_tracked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for service_availability_tracked",
    "remediation": "Configure compute with security best practices for service_availability_tracked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.platform_monitoring_configuration.platform_health_monitored",
    "assertion_id": "platform_surfaces_versions.platform_monitoring.platform_health_monitored",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.platform_monitoring_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for platform_health_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.platform_monitoring_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container platform_health_monitored implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for platform_health_monitored",
    "remediation": "Configure container with security best practices for platform_health_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.platform_monitoring_configuration.service_availability_tracked",
    "assertion_id": "platform_surfaces_versions.platform_monitoring.service_availability_tracked",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.platform_monitoring_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for service_availability_tracked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.platform_monitoring_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container service_availability_tracked implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for service_availability_tracked",
    "remediation": "Configure container with security best practices for service_availability_tracked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.platform_monitoring_configuration.platform_health_monitored",
    "assertion_id": "platform_surfaces_versions.platform_monitoring.platform_health_monitored",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.platform_monitoring_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for platform_health_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.platform_monitoring_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless platform_health_monitored implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for platform_health_monitored",
    "remediation": "Configure serverless with security best practices for platform_health_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.platform_monitoring_configuration.service_availability_tracked",
    "assertion_id": "platform_surfaces_versions.platform_monitoring.service_availability_tracked",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.platform_monitoring_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for service_availability_tracked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.platform_monitoring_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless service_availability_tracked implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for service_availability_tracked",
    "remediation": "Configure serverless with security best practices for service_availability_tracked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.security_updates_configuration.automatic_updates_enabled",
    "assertion_id": "platform_surfaces_versions.security_updates.automatic_updates_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.security_updates_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for automatic_updates_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.security_updates_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute automatic_updates_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for automatic_updates_enabled",
    "remediation": "Configure compute with security best practices for automatic_updates_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.security_updates_configuration.update_testing_conducted",
    "assertion_id": "platform_surfaces_versions.security_updates.update_testing_conducted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.security_updates_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for update_testing_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.security_updates_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute update_testing_conducted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for update_testing_conducted",
    "remediation": "Configure compute with security best practices for update_testing_conducted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.security_updates_configuration.automatic_updates_enabled",
    "assertion_id": "platform_surfaces_versions.security_updates.automatic_updates_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.security_updates_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for automatic_updates_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.security_updates_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container automatic_updates_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for automatic_updates_enabled",
    "remediation": "Configure container with security best practices for automatic_updates_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.security_updates_configuration.update_testing_conducted",
    "assertion_id": "platform_surfaces_versions.security_updates.update_testing_conducted",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.security_updates_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for update_testing_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.security_updates_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container update_testing_conducted implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for update_testing_conducted",
    "remediation": "Configure container with security best practices for update_testing_conducted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.security_updates_configuration.automatic_updates_enabled",
    "assertion_id": "platform_surfaces_versions.security_updates.automatic_updates_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.security_updates_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for automatic_updates_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.security_updates_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless automatic_updates_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for automatic_updates_enabled",
    "remediation": "Configure serverless with security best practices for automatic_updates_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.security_updates_configuration.update_testing_conducted",
    "assertion_id": "platform_surfaces_versions.security_updates.update_testing_conducted",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.security_updates_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for update_testing_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.security_updates_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless update_testing_conducted implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for update_testing_conducted",
    "remediation": "Configure serverless with security best practices for update_testing_conducted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.passwordless_authn_configuration.fido2_required_for_admins",
    "assertion_id": "identity_access.passwordless_authn.fido2_required_for_admins",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for fido2_required_for_admins to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.passwordless_authn_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam fido2_required_for_admins implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for fido2_required_for_admins",
    "remediation": "Configure iam with security best practices for fido2_required_for_admins",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.passwordless_authn_configuration.workload_identity_enabled",
    "assertion_id": "identity_access.passwordless_authn.workload_identity_enabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for workload_identity_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.passwordless_authn_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam workload_identity_enabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for workload_identity_enabled",
    "remediation": "Configure iam with security best practices for workload_identity_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.passwordless_authn_configuration.cae_enforced",
    "assertion_id": "identity_access.passwordless_authn.cae_enforced",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "evaluation_interval_minutes": 5
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for cae_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.passwordless_authn_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam cae_enforced implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for cae_enforced",
    "remediation": "Configure iam with security best practices for cae_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.passwordless_authn_configuration.hardware_tokens_required",
    "assertion_id": "identity_access.passwordless_authn.hardware_tokens_required",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "min_hardware_factors": 1
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for hardware_tokens_required to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.passwordless_authn_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam hardware_tokens_required implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for hardware_tokens_required",
    "remediation": "Configure iam with security best practices for hardware_tokens_required",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.passwordless_authn_configuration.biometric_verification",
    "assertion_id": "identity_access.passwordless_authn.biometric_verification",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for biometric_verification to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.passwordless_authn_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam biometric_verification implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for biometric_verification",
    "remediation": "Configure iam with security best practices for biometric_verification",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.passwordless_authn_configuration.zero_trust_verification",
    "assertion_id": "identity_access.passwordless_authn.zero_trust_verification",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for zero_trust_verification to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.passwordless_authn_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam zero_trust_verification implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for zero_trust_verification",
    "remediation": "Configure iam with security best practices for zero_trust_verification",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.passwordless_authn_configuration.fido2_required_for_admins",
    "assertion_id": "identity_access.passwordless_authn.fido2_required_for_admins",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for fido2_required_for_admins to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.passwordless_authn_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity fido2_required_for_admins implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for fido2_required_for_admins",
    "remediation": "Configure cloudidentity with security best practices for fido2_required_for_admins",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.passwordless_authn_configuration.workload_identity_enabled",
    "assertion_id": "identity_access.passwordless_authn.workload_identity_enabled",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for workload_identity_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.passwordless_authn_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity workload_identity_enabled implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for workload_identity_enabled",
    "remediation": "Configure cloudidentity with security best practices for workload_identity_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.passwordless_authn_configuration.cae_enforced",
    "assertion_id": "identity_access.passwordless_authn.cae_enforced",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "evaluation_interval_minutes": 5
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for cae_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.passwordless_authn_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity cae_enforced implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for cae_enforced",
    "remediation": "Configure cloudidentity with security best practices for cae_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.passwordless_authn_configuration.hardware_tokens_required",
    "assertion_id": "identity_access.passwordless_authn.hardware_tokens_required",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "min_hardware_factors": 1
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for hardware_tokens_required to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.passwordless_authn_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity hardware_tokens_required implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for hardware_tokens_required",
    "remediation": "Configure cloudidentity with security best practices for hardware_tokens_required",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.passwordless_authn_configuration.biometric_verification",
    "assertion_id": "identity_access.passwordless_authn.biometric_verification",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for biometric_verification to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.passwordless_authn_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity biometric_verification implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for biometric_verification",
    "remediation": "Configure cloudidentity with security best practices for biometric_verification",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.passwordless_authn_configuration.zero_trust_verification",
    "assertion_id": "identity_access.passwordless_authn.zero_trust_verification",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for zero_trust_verification to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.passwordless_authn_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity zero_trust_verification implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for zero_trust_verification",
    "remediation": "Configure cloudidentity with security best practices for zero_trust_verification",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.passwordless_authn_configuration.fido2_required_for_admins",
    "assertion_id": "identity_access.passwordless_authn.fido2_required_for_admins",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for fido2_required_for_admins to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.passwordless_authn_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager fido2_required_for_admins implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for fido2_required_for_admins",
    "remediation": "Configure accesscontextmanager with security best practices for fido2_required_for_admins",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.passwordless_authn_configuration.workload_identity_enabled",
    "assertion_id": "identity_access.passwordless_authn.workload_identity_enabled",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for workload_identity_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.passwordless_authn_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager workload_identity_enabled implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for workload_identity_enabled",
    "remediation": "Configure accesscontextmanager with security best practices for workload_identity_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.passwordless_authn_configuration.cae_enforced",
    "assertion_id": "identity_access.passwordless_authn.cae_enforced",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "evaluation_interval_minutes": 5
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for cae_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.passwordless_authn_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager cae_enforced implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for cae_enforced",
    "remediation": "Configure accesscontextmanager with security best practices for cae_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.passwordless_authn_configuration.hardware_tokens_required",
    "assertion_id": "identity_access.passwordless_authn.hardware_tokens_required",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "min_hardware_factors": 1
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for hardware_tokens_required to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.passwordless_authn_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager hardware_tokens_required implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for hardware_tokens_required",
    "remediation": "Configure accesscontextmanager with security best practices for hardware_tokens_required",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.passwordless_authn_configuration.biometric_verification",
    "assertion_id": "identity_access.passwordless_authn.biometric_verification",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for biometric_verification to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.passwordless_authn_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager biometric_verification implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for biometric_verification",
    "remediation": "Configure accesscontextmanager with security best practices for biometric_verification",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.passwordless_authn_configuration.zero_trust_verification",
    "assertion_id": "identity_access.passwordless_authn.zero_trust_verification",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for zero_trust_verification to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.passwordless_authn_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager zero_trust_verification implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for zero_trust_verification",
    "remediation": "Configure accesscontextmanager with security best practices for zero_trust_verification",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.break_glass_configuration.emergency_accounts_restricted",
    "assertion_id": "identity_access.break_glass.emergency_accounts_restricted",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.break_glass_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_emergency_accounts": 3
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for emergency_accounts_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.break_glass_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam emergency_accounts_restricted implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for emergency_accounts_restricted",
    "remediation": "Configure iam with security best practices for emergency_accounts_restricted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.break_glass_configuration.paw_workstations_isolated",
    "assertion_id": "identity_access.break_glass.paw_workstations_isolated",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.break_glass_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for paw_workstations_isolated to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.break_glass_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam paw_workstations_isolated implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for paw_workstations_isolated",
    "remediation": "Configure iam with security best practices for paw_workstations_isolated",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.break_glass_configuration.break_glass_monitoring",
    "assertion_id": "identity_access.break_glass.break_glass_monitoring",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.break_glass_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for break_glass_monitoring to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.break_glass_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam break_glass_monitoring implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for break_glass_monitoring",
    "remediation": "Configure iam with security best practices for break_glass_monitoring",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.break_glass_configuration.emergency_access_review",
    "assertion_id": "identity_access.break_glass.emergency_access_review",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.break_glass_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "review_hours": 24
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for emergency_access_review to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.break_glass_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam emergency_access_review implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for emergency_access_review",
    "remediation": "Configure iam with security best practices for emergency_access_review",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.break_glass_configuration.just_in_time_access",
    "assertion_id": "identity_access.break_glass.just_in_time_access",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.break_glass_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_duration_hours": 4
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for just_in_time_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.break_glass_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam just_in_time_access implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for just_in_time_access",
    "remediation": "Configure iam with security best practices for just_in_time_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.break_glass_configuration.emergency_accounts_restricted",
    "assertion_id": "identity_access.break_glass.emergency_accounts_restricted",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.break_glass_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_emergency_accounts": 3
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for emergency_accounts_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.break_glass_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity emergency_accounts_restricted implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for emergency_accounts_restricted",
    "remediation": "Configure cloudidentity with security best practices for emergency_accounts_restricted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.break_glass_configuration.paw_workstations_isolated",
    "assertion_id": "identity_access.break_glass.paw_workstations_isolated",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.break_glass_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for paw_workstations_isolated to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.break_glass_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity paw_workstations_isolated implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for paw_workstations_isolated",
    "remediation": "Configure cloudidentity with security best practices for paw_workstations_isolated",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.break_glass_configuration.break_glass_monitoring",
    "assertion_id": "identity_access.break_glass.break_glass_monitoring",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.break_glass_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for break_glass_monitoring to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.break_glass_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity break_glass_monitoring implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for break_glass_monitoring",
    "remediation": "Configure cloudidentity with security best practices for break_glass_monitoring",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.break_glass_configuration.emergency_access_review",
    "assertion_id": "identity_access.break_glass.emergency_access_review",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.break_glass_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "review_hours": 24
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for emergency_access_review to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.break_glass_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity emergency_access_review implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for emergency_access_review",
    "remediation": "Configure cloudidentity with security best practices for emergency_access_review",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.break_glass_configuration.just_in_time_access",
    "assertion_id": "identity_access.break_glass.just_in_time_access",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.break_glass_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_duration_hours": 4
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for just_in_time_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.break_glass_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity just_in_time_access implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for just_in_time_access",
    "remediation": "Configure cloudidentity with security best practices for just_in_time_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.break_glass_configuration.emergency_accounts_restricted",
    "assertion_id": "identity_access.break_glass.emergency_accounts_restricted",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.break_glass_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_emergency_accounts": 3
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for emergency_accounts_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.break_glass_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager emergency_accounts_restricted implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for emergency_accounts_restricted",
    "remediation": "Configure accesscontextmanager with security best practices for emergency_accounts_restricted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.break_glass_configuration.paw_workstations_isolated",
    "assertion_id": "identity_access.break_glass.paw_workstations_isolated",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.break_glass_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for paw_workstations_isolated to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.break_glass_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager paw_workstations_isolated implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for paw_workstations_isolated",
    "remediation": "Configure accesscontextmanager with security best practices for paw_workstations_isolated",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.break_glass_configuration.break_glass_monitoring",
    "assertion_id": "identity_access.break_glass.break_glass_monitoring",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.break_glass_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for break_glass_monitoring to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.break_glass_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager break_glass_monitoring implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for break_glass_monitoring",
    "remediation": "Configure accesscontextmanager with security best practices for break_glass_monitoring",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.break_glass_configuration.emergency_access_review",
    "assertion_id": "identity_access.break_glass.emergency_access_review",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.break_glass_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "review_hours": 24
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for emergency_access_review to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.break_glass_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager emergency_access_review implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for emergency_access_review",
    "remediation": "Configure accesscontextmanager with security best practices for emergency_access_review",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.break_glass_configuration.just_in_time_access",
    "assertion_id": "identity_access.break_glass.just_in_time_access",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.break_glass_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_duration_hours": 4
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for just_in_time_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.break_glass_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager just_in_time_access implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for just_in_time_access",
    "remediation": "Configure accesscontextmanager with security best practices for just_in_time_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.sod_toxic_configuration.detect_conflicting_roles",
    "assertion_id": "rbac_entitlements.sod_toxic.detect_conflicting_roles",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for detect_conflicting_roles to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.sod_toxic_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam detect_conflicting_roles implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for detect_conflicting_roles",
    "remediation": "Configure iam with security best practices for detect_conflicting_roles",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.sod_toxic_configuration.segregate_approval_execution",
    "assertion_id": "rbac_entitlements.sod_toxic.segregate_approval_execution",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for segregate_approval_execution to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.sod_toxic_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam segregate_approval_execution implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for segregate_approval_execution",
    "remediation": "Configure iam with security best practices for segregate_approval_execution",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.sod_toxic_configuration.financial_controls_segregated",
    "assertion_id": "rbac_entitlements.sod_toxic.financial_controls_segregated",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for financial_controls_segregated to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.sod_toxic_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam financial_controls_segregated implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for financial_controls_segregated",
    "remediation": "Configure iam with security best practices for financial_controls_segregated",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.sod_toxic_configuration.admin_audit_separation",
    "assertion_id": "rbac_entitlements.sod_toxic.admin_audit_separation",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for admin_audit_separation to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.sod_toxic_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam admin_audit_separation implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for admin_audit_separation",
    "remediation": "Configure iam with security best practices for admin_audit_separation",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.sod_toxic_configuration.periodic_sod_review",
    "assertion_id": "rbac_entitlements.sod_toxic.periodic_sod_review",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "review_frequency_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for periodic_sod_review to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.sod_toxic_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam periodic_sod_review implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for periodic_sod_review",
    "remediation": "Configure iam with security best practices for periodic_sod_review",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.sod_toxic_configuration.detect_conflicting_roles",
    "assertion_id": "rbac_entitlements.sod_toxic.detect_conflicting_roles",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for detect_conflicting_roles to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.sod_toxic_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager detect_conflicting_roles implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for detect_conflicting_roles",
    "remediation": "Configure resourcemanager with security best practices for detect_conflicting_roles",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.sod_toxic_configuration.segregate_approval_execution",
    "assertion_id": "rbac_entitlements.sod_toxic.segregate_approval_execution",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for segregate_approval_execution to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.sod_toxic_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager segregate_approval_execution implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for segregate_approval_execution",
    "remediation": "Configure resourcemanager with security best practices for segregate_approval_execution",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.sod_toxic_configuration.financial_controls_segregated",
    "assertion_id": "rbac_entitlements.sod_toxic.financial_controls_segregated",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for financial_controls_segregated to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.sod_toxic_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager financial_controls_segregated implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for financial_controls_segregated",
    "remediation": "Configure resourcemanager with security best practices for financial_controls_segregated",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.sod_toxic_configuration.admin_audit_separation",
    "assertion_id": "rbac_entitlements.sod_toxic.admin_audit_separation",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for admin_audit_separation to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.sod_toxic_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager admin_audit_separation implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for admin_audit_separation",
    "remediation": "Configure resourcemanager with security best practices for admin_audit_separation",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.sod_toxic_configuration.periodic_sod_review",
    "assertion_id": "rbac_entitlements.sod_toxic.periodic_sod_review",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "review_frequency_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for periodic_sod_review to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.sod_toxic_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager periodic_sod_review implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for periodic_sod_review",
    "remediation": "Configure resourcemanager with security best practices for periodic_sod_review",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.sod_toxic_configuration.detect_conflicting_roles",
    "assertion_id": "rbac_entitlements.sod_toxic.detect_conflicting_roles",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for detect_conflicting_roles to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.sod_toxic_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager detect_conflicting_roles implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for detect_conflicting_roles",
    "remediation": "Configure resourcemanager with security best practices for detect_conflicting_roles",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.sod_toxic_configuration.segregate_approval_execution",
    "assertion_id": "rbac_entitlements.sod_toxic.segregate_approval_execution",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for segregate_approval_execution to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.sod_toxic_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager segregate_approval_execution implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for segregate_approval_execution",
    "remediation": "Configure resourcemanager with security best practices for segregate_approval_execution",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.sod_toxic_configuration.financial_controls_segregated",
    "assertion_id": "rbac_entitlements.sod_toxic.financial_controls_segregated",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for financial_controls_segregated to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.sod_toxic_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager financial_controls_segregated implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for financial_controls_segregated",
    "remediation": "Configure resourcemanager with security best practices for financial_controls_segregated",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.sod_toxic_configuration.admin_audit_separation",
    "assertion_id": "rbac_entitlements.sod_toxic.admin_audit_separation",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for admin_audit_separation to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.sod_toxic_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager admin_audit_separation implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for admin_audit_separation",
    "remediation": "Configure resourcemanager with security best practices for admin_audit_separation",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.sod_toxic_configuration.periodic_sod_review",
    "assertion_id": "rbac_entitlements.sod_toxic.periodic_sod_review",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "review_frequency_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for periodic_sod_review to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.sod_toxic_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager periodic_sod_review implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for periodic_sod_review",
    "remediation": "Configure resourcemanager with security best practices for periodic_sod_review",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_sprawl_configuration.detect_unused_secrets",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.detect_unused_secrets",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "stale_threshold_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for detect_unused_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_sprawl_configuration",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager detect_unused_secrets implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for detect_unused_secrets",
    "remediation": "Configure secretmanager with security best practices for detect_unused_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_sprawl_configuration.rotate_stale_secrets",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.rotate_stale_secrets",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for rotate_stale_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_sprawl_configuration",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager rotate_stale_secrets implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for rotate_stale_secrets",
    "remediation": "Configure secretmanager with security best practices for rotate_stale_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_sprawl_configuration.audit_secret_permissions",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.audit_secret_permissions",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for audit_secret_permissions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_sprawl_configuration",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager audit_secret_permissions implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for audit_secret_permissions",
    "remediation": "Configure secretmanager with security best practices for audit_secret_permissions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_sprawl_configuration.centralize_secret_management",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.centralize_secret_management",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for centralize_secret_management to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_sprawl_configuration",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager centralize_secret_management implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for centralize_secret_management",
    "remediation": "Configure secretmanager with security best practices for centralize_secret_management",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_sprawl_configuration.monitor_secret_usage",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.monitor_secret_usage",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for monitor_secret_usage to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_sprawl_configuration",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager monitor_secret_usage implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for monitor_secret_usage",
    "remediation": "Configure secretmanager with security best practices for monitor_secret_usage",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.secret_sprawl_configuration.detect_unused_secrets",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.detect_unused_secrets",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "stale_threshold_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for detect_unused_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.secret_sprawl_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms detect_unused_secrets implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for detect_unused_secrets",
    "remediation": "Configure kms with security best practices for detect_unused_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.secret_sprawl_configuration.rotate_stale_secrets",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.rotate_stale_secrets",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for rotate_stale_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.secret_sprawl_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms rotate_stale_secrets implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for rotate_stale_secrets",
    "remediation": "Configure kms with security best practices for rotate_stale_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.secret_sprawl_configuration.audit_secret_permissions",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.audit_secret_permissions",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for audit_secret_permissions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.secret_sprawl_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms audit_secret_permissions implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for audit_secret_permissions",
    "remediation": "Configure kms with security best practices for audit_secret_permissions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.secret_sprawl_configuration.centralize_secret_management",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.centralize_secret_management",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for centralize_secret_management to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.secret_sprawl_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms centralize_secret_management implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for centralize_secret_management",
    "remediation": "Configure kms with security best practices for centralize_secret_management",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.secret_sprawl_configuration.monitor_secret_usage",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.monitor_secret_usage",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for monitor_secret_usage to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.secret_sprawl_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms monitor_secret_usage implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for monitor_secret_usage",
    "remediation": "Configure kms with security best practices for monitor_secret_usage",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.immutability_configuration.enable_worm_storage",
    "assertion_id": "crypto_data_protection.immutability.enable_worm_storage",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.immutability_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_years": 7
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for enable_worm_storage to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.immutability_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms enable_worm_storage implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for enable_worm_storage",
    "remediation": "Configure kms with security best practices for enable_worm_storage",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.immutability_configuration.legal_hold_protection",
    "assertion_id": "crypto_data_protection.immutability.legal_hold_protection",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.immutability_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for legal_hold_protection to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.immutability_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms legal_hold_protection implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for legal_hold_protection",
    "remediation": "Configure kms with security best practices for legal_hold_protection",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.immutability_configuration.immutable_audit_logs",
    "assertion_id": "crypto_data_protection.immutability.immutable_audit_logs",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.immutability_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for immutable_audit_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.immutability_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms immutable_audit_logs implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for immutable_audit_logs",
    "remediation": "Configure kms with security best practices for immutable_audit_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.immutability_configuration.retention_lock_enforcement",
    "assertion_id": "crypto_data_protection.immutability.retention_lock_enforcement",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.immutability_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for retention_lock_enforcement to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.immutability_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms retention_lock_enforcement implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for retention_lock_enforcement",
    "remediation": "Configure kms with security best practices for retention_lock_enforcement",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.immutability_configuration.compliance_immutability",
    "assertion_id": "crypto_data_protection.immutability.compliance_immutability",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.immutability_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for compliance_immutability to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.immutability_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms compliance_immutability implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for compliance_immutability",
    "remediation": "Configure kms with security best practices for compliance_immutability",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.immutability_configuration.enable_worm_storage",
    "assertion_id": "crypto_data_protection.immutability.enable_worm_storage",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.immutability_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_years": 7
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for enable_worm_storage to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.immutability_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage enable_worm_storage implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for enable_worm_storage",
    "remediation": "Configure storage with security best practices for enable_worm_storage",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.immutability_configuration.legal_hold_protection",
    "assertion_id": "crypto_data_protection.immutability.legal_hold_protection",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.immutability_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for legal_hold_protection to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.immutability_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage legal_hold_protection implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for legal_hold_protection",
    "remediation": "Configure storage with security best practices for legal_hold_protection",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.immutability_configuration.immutable_audit_logs",
    "assertion_id": "crypto_data_protection.immutability.immutable_audit_logs",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.immutability_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for immutable_audit_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.immutability_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage immutable_audit_logs implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for immutable_audit_logs",
    "remediation": "Configure storage with security best practices for immutable_audit_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.immutability_configuration.retention_lock_enforcement",
    "assertion_id": "crypto_data_protection.immutability.retention_lock_enforcement",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.immutability_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for retention_lock_enforcement to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.immutability_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage retention_lock_enforcement implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for retention_lock_enforcement",
    "remediation": "Configure storage with security best practices for retention_lock_enforcement",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.immutability_configuration.compliance_immutability",
    "assertion_id": "crypto_data_protection.immutability.compliance_immutability",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.immutability_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for compliance_immutability to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.immutability_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage compliance_immutability implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for compliance_immutability",
    "remediation": "Configure storage with security best practices for compliance_immutability",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.immutability_configuration.enable_worm_storage",
    "assertion_id": "crypto_data_protection.immutability.enable_worm_storage",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_years": 7
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for enable_worm_storage to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.immutability_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute enable_worm_storage implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for enable_worm_storage",
    "remediation": "Configure compute with security best practices for enable_worm_storage",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.immutability_configuration.legal_hold_protection",
    "assertion_id": "crypto_data_protection.immutability.legal_hold_protection",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for legal_hold_protection to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.immutability_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute legal_hold_protection implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for legal_hold_protection",
    "remediation": "Configure compute with security best practices for legal_hold_protection",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.immutability_configuration.immutable_audit_logs",
    "assertion_id": "crypto_data_protection.immutability.immutable_audit_logs",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for immutable_audit_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.immutability_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute immutable_audit_logs implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for immutable_audit_logs",
    "remediation": "Configure compute with security best practices for immutable_audit_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.immutability_configuration.retention_lock_enforcement",
    "assertion_id": "crypto_data_protection.immutability.retention_lock_enforcement",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for retention_lock_enforcement to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.immutability_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute retention_lock_enforcement implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for retention_lock_enforcement",
    "remediation": "Configure compute with security best practices for retention_lock_enforcement",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.immutability_configuration.compliance_immutability",
    "assertion_id": "crypto_data_protection.immutability.compliance_immutability",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for compliance_immutability to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.immutability_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute compliance_immutability implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for compliance_immutability",
    "remediation": "Configure compute with security best practices for compliance_immutability",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.immutability_configuration.enable_worm_storage",
    "assertion_id": "crypto_data_protection.immutability.enable_worm_storage",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.immutability_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_years": 7
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for enable_worm_storage to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.immutability_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database enable_worm_storage implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for enable_worm_storage",
    "remediation": "Configure database with security best practices for enable_worm_storage",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.immutability_configuration.legal_hold_protection",
    "assertion_id": "crypto_data_protection.immutability.legal_hold_protection",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.immutability_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for legal_hold_protection to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.immutability_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database legal_hold_protection implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for legal_hold_protection",
    "remediation": "Configure database with security best practices for legal_hold_protection",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.immutability_configuration.immutable_audit_logs",
    "assertion_id": "crypto_data_protection.immutability.immutable_audit_logs",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.immutability_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for immutable_audit_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.immutability_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database immutable_audit_logs implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for immutable_audit_logs",
    "remediation": "Configure database with security best practices for immutable_audit_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.immutability_configuration.retention_lock_enforcement",
    "assertion_id": "crypto_data_protection.immutability.retention_lock_enforcement",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.immutability_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for retention_lock_enforcement to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.immutability_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database retention_lock_enforcement implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for retention_lock_enforcement",
    "remediation": "Configure database with security best practices for retention_lock_enforcement",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.immutability_configuration.compliance_immutability",
    "assertion_id": "crypto_data_protection.immutability.compliance_immutability",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.immutability_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for compliance_immutability to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.immutability_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database compliance_immutability implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for compliance_immutability",
    "remediation": "Configure database with security best practices for compliance_immutability",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.immutability_configuration.enable_worm_storage",
    "assertion_id": "crypto_data_protection.immutability.enable_worm_storage",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_years": 7
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for enable_worm_storage to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.immutability_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute enable_worm_storage implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for enable_worm_storage",
    "remediation": "Configure compute with security best practices for enable_worm_storage",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.immutability_configuration.legal_hold_protection",
    "assertion_id": "crypto_data_protection.immutability.legal_hold_protection",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for legal_hold_protection to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.immutability_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute legal_hold_protection implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for legal_hold_protection",
    "remediation": "Configure compute with security best practices for legal_hold_protection",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.immutability_configuration.immutable_audit_logs",
    "assertion_id": "crypto_data_protection.immutability.immutable_audit_logs",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for immutable_audit_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.immutability_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute immutable_audit_logs implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for immutable_audit_logs",
    "remediation": "Configure compute with security best practices for immutable_audit_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.immutability_configuration.retention_lock_enforcement",
    "assertion_id": "crypto_data_protection.immutability.retention_lock_enforcement",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for retention_lock_enforcement to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.immutability_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute retention_lock_enforcement implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for retention_lock_enforcement",
    "remediation": "Configure compute with security best practices for retention_lock_enforcement",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.immutability_configuration.compliance_immutability",
    "assertion_id": "crypto_data_protection.immutability.compliance_immutability",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for compliance_immutability to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.immutability_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute compliance_immutability implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for compliance_immutability",
    "remediation": "Configure compute with security best practices for compliance_immutability",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.public_exposure_configuration.detect_public_buckets",
    "assertion_id": "data_protection_storage.public_exposure.detect_public_buckets",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.public_exposure_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for detect_public_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.public_exposure_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage detect_public_buckets implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for detect_public_buckets",
    "remediation": "Configure storage with security best practices for detect_public_buckets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.public_exposure_configuration.block_public_access",
    "assertion_id": "data_protection_storage.public_exposure.block_public_access",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.public_exposure_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for block_public_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.public_exposure_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage block_public_access implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for block_public_access",
    "remediation": "Configure storage with security best practices for block_public_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.public_exposure_configuration.audit_public_permissions",
    "assertion_id": "data_protection_storage.public_exposure.audit_public_permissions",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.public_exposure_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for audit_public_permissions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.public_exposure_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage audit_public_permissions implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for audit_public_permissions",
    "remediation": "Configure storage with security best practices for audit_public_permissions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.public_exposure_configuration.encrypt_public_data",
    "assertion_id": "data_protection_storage.public_exposure.encrypt_public_data",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.public_exposure_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for encrypt_public_data to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.public_exposure_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage encrypt_public_data implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for encrypt_public_data",
    "remediation": "Configure storage with security best practices for encrypt_public_data",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.public_exposure_configuration.monitor_public_access",
    "assertion_id": "data_protection_storage.public_exposure.monitor_public_access",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.public_exposure_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for monitor_public_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.public_exposure_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage monitor_public_access implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for monitor_public_access",
    "remediation": "Configure storage with security best practices for monitor_public_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.public_exposure_configuration.detect_public_buckets",
    "assertion_id": "data_protection_storage.public_exposure.detect_public_buckets",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for detect_public_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute detect_public_buckets implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for detect_public_buckets",
    "remediation": "Configure compute with security best practices for detect_public_buckets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.public_exposure_configuration.block_public_access",
    "assertion_id": "data_protection_storage.public_exposure.block_public_access",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for block_public_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute block_public_access implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for block_public_access",
    "remediation": "Configure compute with security best practices for block_public_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.public_exposure_configuration.audit_public_permissions",
    "assertion_id": "data_protection_storage.public_exposure.audit_public_permissions",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for audit_public_permissions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute audit_public_permissions implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for audit_public_permissions",
    "remediation": "Configure compute with security best practices for audit_public_permissions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.public_exposure_configuration.encrypt_public_data",
    "assertion_id": "data_protection_storage.public_exposure.encrypt_public_data",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for encrypt_public_data to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute encrypt_public_data implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for encrypt_public_data",
    "remediation": "Configure compute with security best practices for encrypt_public_data",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.public_exposure_configuration.monitor_public_access",
    "assertion_id": "data_protection_storage.public_exposure.monitor_public_access",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for monitor_public_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute monitor_public_access implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for monitor_public_access",
    "remediation": "Configure compute with security best practices for monitor_public_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.public_exposure_configuration.detect_public_buckets",
    "assertion_id": "data_protection_storage.public_exposure.detect_public_buckets",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for detect_public_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute detect_public_buckets implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for detect_public_buckets",
    "remediation": "Configure compute with security best practices for detect_public_buckets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.public_exposure_configuration.block_public_access",
    "assertion_id": "data_protection_storage.public_exposure.block_public_access",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for block_public_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute block_public_access implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for block_public_access",
    "remediation": "Configure compute with security best practices for block_public_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.public_exposure_configuration.audit_public_permissions",
    "assertion_id": "data_protection_storage.public_exposure.audit_public_permissions",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for audit_public_permissions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute audit_public_permissions implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for audit_public_permissions",
    "remediation": "Configure compute with security best practices for audit_public_permissions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.public_exposure_configuration.encrypt_public_data",
    "assertion_id": "data_protection_storage.public_exposure.encrypt_public_data",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for encrypt_public_data to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute encrypt_public_data implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for encrypt_public_data",
    "remediation": "Configure compute with security best practices for encrypt_public_data",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.public_exposure_configuration.monitor_public_access",
    "assertion_id": "data_protection_storage.public_exposure.monitor_public_access",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for monitor_public_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute monitor_public_access implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for monitor_public_access",
    "remediation": "Configure compute with security best practices for monitor_public_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.public_exposure_configuration.detect_public_buckets",
    "assertion_id": "data_protection_storage.public_exposure.detect_public_buckets",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for detect_public_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute detect_public_buckets implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for detect_public_buckets",
    "remediation": "Configure compute with security best practices for detect_public_buckets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.public_exposure_configuration.block_public_access",
    "assertion_id": "data_protection_storage.public_exposure.block_public_access",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for block_public_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute block_public_access implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for block_public_access",
    "remediation": "Configure compute with security best practices for block_public_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.public_exposure_configuration.audit_public_permissions",
    "assertion_id": "data_protection_storage.public_exposure.audit_public_permissions",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for audit_public_permissions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute audit_public_permissions implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for audit_public_permissions",
    "remediation": "Configure compute with security best practices for audit_public_permissions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.public_exposure_configuration.encrypt_public_data",
    "assertion_id": "data_protection_storage.public_exposure.encrypt_public_data",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for encrypt_public_data to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute encrypt_public_data implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for encrypt_public_data",
    "remediation": "Configure compute with security best practices for encrypt_public_data",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.public_exposure_configuration.monitor_public_access",
    "assertion_id": "data_protection_storage.public_exposure.monitor_public_access",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for monitor_public_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute monitor_public_access implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for monitor_public_access",
    "remediation": "Configure compute with security best practices for monitor_public_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.private_endpoints_configuration.prefer_private_connectivity",
    "assertion_id": "network_perimeter.private_endpoints.prefer_private_connectivity",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for prefer_private_connectivity to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute prefer_private_connectivity implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for prefer_private_connectivity",
    "remediation": "Configure compute with security best practices for prefer_private_connectivity",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.private_endpoints_configuration.disable_public_ingress",
    "assertion_id": "network_perimeter.private_endpoints.disable_public_ingress",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for disable_public_ingress to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute disable_public_ingress implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for disable_public_ingress",
    "remediation": "Configure compute with security best practices for disable_public_ingress",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.private_endpoints_configuration.vpc_endpoints_configured",
    "assertion_id": "network_perimeter.private_endpoints.vpc_endpoints_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for vpc_endpoints_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpc_endpoints_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpc_endpoints_configured",
    "remediation": "Configure compute with security best practices for vpc_endpoints_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.private_endpoints_configuration.private_dns_enabled",
    "assertion_id": "network_perimeter.private_endpoints.private_dns_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for private_dns_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_dns_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_dns_enabled",
    "remediation": "Configure compute with security best practices for private_dns_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.private_endpoints_configuration.network_isolation_enforced",
    "assertion_id": "network_perimeter.private_endpoints.network_isolation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for network_isolation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute network_isolation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for network_isolation_enforced",
    "remediation": "Configure compute with security best practices for network_isolation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.private_endpoints_configuration.prefer_private_connectivity",
    "assertion_id": "network_perimeter.private_endpoints.prefer_private_connectivity",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for prefer_private_connectivity to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute prefer_private_connectivity implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for prefer_private_connectivity",
    "remediation": "Configure compute with security best practices for prefer_private_connectivity",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.private_endpoints_configuration.disable_public_ingress",
    "assertion_id": "network_perimeter.private_endpoints.disable_public_ingress",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for disable_public_ingress to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute disable_public_ingress implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for disable_public_ingress",
    "remediation": "Configure compute with security best practices for disable_public_ingress",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.private_endpoints_configuration.vpc_endpoints_configured",
    "assertion_id": "network_perimeter.private_endpoints.vpc_endpoints_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for vpc_endpoints_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpc_endpoints_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpc_endpoints_configured",
    "remediation": "Configure compute with security best practices for vpc_endpoints_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.private_endpoints_configuration.private_dns_enabled",
    "assertion_id": "network_perimeter.private_endpoints.private_dns_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for private_dns_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_dns_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_dns_enabled",
    "remediation": "Configure compute with security best practices for private_dns_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.private_endpoints_configuration.network_isolation_enforced",
    "assertion_id": "network_perimeter.private_endpoints.network_isolation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for network_isolation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute network_isolation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for network_isolation_enforced",
    "remediation": "Configure compute with security best practices for network_isolation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.private_endpoints_configuration.prefer_private_connectivity",
    "assertion_id": "network_perimeter.private_endpoints.prefer_private_connectivity",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for prefer_private_connectivity to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute prefer_private_connectivity implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for prefer_private_connectivity",
    "remediation": "Configure compute with security best practices for prefer_private_connectivity",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.private_endpoints_configuration.disable_public_ingress",
    "assertion_id": "network_perimeter.private_endpoints.disable_public_ingress",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for disable_public_ingress to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute disable_public_ingress implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for disable_public_ingress",
    "remediation": "Configure compute with security best practices for disable_public_ingress",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.private_endpoints_configuration.vpc_endpoints_configured",
    "assertion_id": "network_perimeter.private_endpoints.vpc_endpoints_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for vpc_endpoints_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpc_endpoints_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpc_endpoints_configured",
    "remediation": "Configure compute with security best practices for vpc_endpoints_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.private_endpoints_configuration.private_dns_enabled",
    "assertion_id": "network_perimeter.private_endpoints.private_dns_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for private_dns_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_dns_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_dns_enabled",
    "remediation": "Configure compute with security best practices for private_dns_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.private_endpoints_configuration.network_isolation_enforced",
    "assertion_id": "network_perimeter.private_endpoints.network_isolation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for network_isolation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute network_isolation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for network_isolation_enforced",
    "remediation": "Configure compute with security best practices for network_isolation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.private_endpoints_configuration.prefer_private_connectivity",
    "assertion_id": "network_perimeter.private_endpoints.prefer_private_connectivity",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for prefer_private_connectivity to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute prefer_private_connectivity implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for prefer_private_connectivity",
    "remediation": "Configure compute with security best practices for prefer_private_connectivity",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.private_endpoints_configuration.disable_public_ingress",
    "assertion_id": "network_perimeter.private_endpoints.disable_public_ingress",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for disable_public_ingress to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute disable_public_ingress implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for disable_public_ingress",
    "remediation": "Configure compute with security best practices for disable_public_ingress",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.private_endpoints_configuration.vpc_endpoints_configured",
    "assertion_id": "network_perimeter.private_endpoints.vpc_endpoints_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for vpc_endpoints_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpc_endpoints_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpc_endpoints_configured",
    "remediation": "Configure compute with security best practices for vpc_endpoints_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.private_endpoints_configuration.private_dns_enabled",
    "assertion_id": "network_perimeter.private_endpoints.private_dns_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for private_dns_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_dns_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_dns_enabled",
    "remediation": "Configure compute with security best practices for private_dns_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.private_endpoints_configuration.network_isolation_enforced",
    "assertion_id": "network_perimeter.private_endpoints.network_isolation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for network_isolation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute network_isolation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for network_isolation_enforced",
    "remediation": "Configure compute with security best practices for network_isolation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.agent_coverage_configuration.edr_agents_installed",
    "assertion_id": "compute_host_security.agent_coverage.edr_agents_installed",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for edr_agents_installed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.agent_coverage_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute edr_agents_installed implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for edr_agents_installed",
    "remediation": "Configure compute with security best practices for edr_agents_installed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.agent_coverage_configuration.patch_agents_healthy",
    "assertion_id": "compute_host_security.agent_coverage.patch_agents_healthy",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for patch_agents_healthy to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.agent_coverage_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute patch_agents_healthy implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for patch_agents_healthy",
    "remediation": "Configure compute with security best practices for patch_agents_healthy",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.agent_coverage_configuration.config_agents_deployed",
    "assertion_id": "compute_host_security.agent_coverage.config_agents_deployed",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for config_agents_deployed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.agent_coverage_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute config_agents_deployed implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for config_agents_deployed",
    "remediation": "Configure compute with security best practices for config_agents_deployed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.agent_coverage_configuration.agent_versions_current",
    "assertion_id": "compute_host_security.agent_coverage.agent_versions_current",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for agent_versions_current to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.agent_coverage_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute agent_versions_current implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for agent_versions_current",
    "remediation": "Configure compute with security best practices for agent_versions_current",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.agent_coverage_configuration.agent_connectivity_monitored",
    "assertion_id": "compute_host_security.agent_coverage.agent_connectivity_monitored",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for agent_connectivity_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.agent_coverage_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute agent_connectivity_monitored implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for agent_connectivity_monitored",
    "remediation": "Configure compute with security best practices for agent_connectivity_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.agent_coverage_configuration.edr_agents_installed",
    "assertion_id": "compute_host_security.agent_coverage.edr_agents_installed",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for edr_agents_installed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.agent_coverage_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute edr_agents_installed implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for edr_agents_installed",
    "remediation": "Configure compute with security best practices for edr_agents_installed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.agent_coverage_configuration.patch_agents_healthy",
    "assertion_id": "compute_host_security.agent_coverage.patch_agents_healthy",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for patch_agents_healthy to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.agent_coverage_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute patch_agents_healthy implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for patch_agents_healthy",
    "remediation": "Configure compute with security best practices for patch_agents_healthy",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.agent_coverage_configuration.config_agents_deployed",
    "assertion_id": "compute_host_security.agent_coverage.config_agents_deployed",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for config_agents_deployed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.agent_coverage_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute config_agents_deployed implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for config_agents_deployed",
    "remediation": "Configure compute with security best practices for config_agents_deployed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.agent_coverage_configuration.agent_versions_current",
    "assertion_id": "compute_host_security.agent_coverage.agent_versions_current",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for agent_versions_current to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.agent_coverage_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute agent_versions_current implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for agent_versions_current",
    "remediation": "Configure compute with security best practices for agent_versions_current",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.agent_coverage_configuration.agent_connectivity_monitored",
    "assertion_id": "compute_host_security.agent_coverage.agent_connectivity_monitored",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for agent_connectivity_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.agent_coverage_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute agent_connectivity_monitored implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for agent_connectivity_monitored",
    "remediation": "Configure compute with security best practices for agent_connectivity_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.agent_coverage_configuration.edr_agents_installed",
    "assertion_id": "compute_host_security.agent_coverage.edr_agents_installed",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for edr_agents_installed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.agent_coverage_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter edr_agents_installed implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for edr_agents_installed",
    "remediation": "Configure securitycenter with security best practices for edr_agents_installed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.agent_coverage_configuration.patch_agents_healthy",
    "assertion_id": "compute_host_security.agent_coverage.patch_agents_healthy",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for patch_agents_healthy to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.agent_coverage_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter patch_agents_healthy implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for patch_agents_healthy",
    "remediation": "Configure securitycenter with security best practices for patch_agents_healthy",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.agent_coverage_configuration.config_agents_deployed",
    "assertion_id": "compute_host_security.agent_coverage.config_agents_deployed",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for config_agents_deployed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.agent_coverage_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter config_agents_deployed implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for config_agents_deployed",
    "remediation": "Configure securitycenter with security best practices for config_agents_deployed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.agent_coverage_configuration.agent_versions_current",
    "assertion_id": "compute_host_security.agent_coverage.agent_versions_current",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for agent_versions_current to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.agent_coverage_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter agent_versions_current implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for agent_versions_current",
    "remediation": "Configure securitycenter with security best practices for agent_versions_current",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.agent_coverage_configuration.agent_connectivity_monitored",
    "assertion_id": "compute_host_security.agent_coverage.agent_connectivity_monitored",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for agent_connectivity_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.agent_coverage_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter agent_connectivity_monitored implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for agent_connectivity_monitored",
    "remediation": "Configure securitycenter with security best practices for agent_connectivity_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.psa_enforcement_configuration.pod_security_standards_enforced",
    "assertion_id": "containers_kubernetes.psa_enforcement.pod_security_standards_enforced",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "enforcement_mode": "enforce"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for pod_security_standards_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.psa_enforcement_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container pod_security_standards_enforced implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for pod_security_standards_enforced",
    "remediation": "Configure container with security best practices for pod_security_standards_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.psa_enforcement_configuration.privileged_containers_blocked",
    "assertion_id": "containers_kubernetes.psa_enforcement.privileged_containers_blocked",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for privileged_containers_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.psa_enforcement_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container privileged_containers_blocked implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for privileged_containers_blocked",
    "remediation": "Configure container with security best practices for privileged_containers_blocked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.psa_enforcement_configuration.host_network_isolation",
    "assertion_id": "containers_kubernetes.psa_enforcement.host_network_isolation",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for host_network_isolation to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.psa_enforcement_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container host_network_isolation implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for host_network_isolation",
    "remediation": "Configure container with security best practices for host_network_isolation",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.psa_enforcement_configuration.host_path_restrictions",
    "assertion_id": "containers_kubernetes.psa_enforcement.host_path_restrictions",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for host_path_restrictions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.psa_enforcement_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container host_path_restrictions implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for host_path_restrictions",
    "remediation": "Configure container with security best practices for host_path_restrictions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.psa_enforcement_configuration.psa_namespace_policies",
    "assertion_id": "containers_kubernetes.psa_enforcement.psa_namespace_policies",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for psa_namespace_policies to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.psa_enforcement_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container psa_namespace_policies implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for psa_namespace_policies",
    "remediation": "Configure container with security best practices for psa_namespace_policies",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.psa_enforcement_configuration.pod_security_standards_enforced",
    "assertion_id": "containers_kubernetes.psa_enforcement.pod_security_standards_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "enforcement_mode": "enforce"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for pod_security_standards_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.psa_enforcement_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute pod_security_standards_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for pod_security_standards_enforced",
    "remediation": "Configure compute with security best practices for pod_security_standards_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.psa_enforcement_configuration.privileged_containers_blocked",
    "assertion_id": "containers_kubernetes.psa_enforcement.privileged_containers_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for privileged_containers_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.psa_enforcement_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute privileged_containers_blocked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for privileged_containers_blocked",
    "remediation": "Configure compute with security best practices for privileged_containers_blocked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.psa_enforcement_configuration.host_network_isolation",
    "assertion_id": "containers_kubernetes.psa_enforcement.host_network_isolation",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for host_network_isolation to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.psa_enforcement_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute host_network_isolation implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for host_network_isolation",
    "remediation": "Configure compute with security best practices for host_network_isolation",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.psa_enforcement_configuration.host_path_restrictions",
    "assertion_id": "containers_kubernetes.psa_enforcement.host_path_restrictions",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for host_path_restrictions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.psa_enforcement_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute host_path_restrictions implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for host_path_restrictions",
    "remediation": "Configure compute with security best practices for host_path_restrictions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.psa_enforcement_configuration.psa_namespace_policies",
    "assertion_id": "containers_kubernetes.psa_enforcement.psa_namespace_policies",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for psa_namespace_policies to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.psa_enforcement_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute psa_namespace_policies implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for psa_namespace_policies",
    "remediation": "Configure compute with security best practices for psa_namespace_policies",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.psa_enforcement_configuration.pod_security_standards_enforced",
    "assertion_id": "containers_kubernetes.psa_enforcement.pod_security_standards_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "enforcement_mode": "enforce"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for pod_security_standards_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.psa_enforcement_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute pod_security_standards_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for pod_security_standards_enforced",
    "remediation": "Configure compute with security best practices for pod_security_standards_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.psa_enforcement_configuration.privileged_containers_blocked",
    "assertion_id": "containers_kubernetes.psa_enforcement.privileged_containers_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for privileged_containers_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.psa_enforcement_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute privileged_containers_blocked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for privileged_containers_blocked",
    "remediation": "Configure compute with security best practices for privileged_containers_blocked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.psa_enforcement_configuration.host_network_isolation",
    "assertion_id": "containers_kubernetes.psa_enforcement.host_network_isolation",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for host_network_isolation to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.psa_enforcement_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute host_network_isolation implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for host_network_isolation",
    "remediation": "Configure compute with security best practices for host_network_isolation",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.psa_enforcement_configuration.host_path_restrictions",
    "assertion_id": "containers_kubernetes.psa_enforcement.host_path_restrictions",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for host_path_restrictions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.psa_enforcement_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute host_path_restrictions implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for host_path_restrictions",
    "remediation": "Configure compute with security best practices for host_path_restrictions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.psa_enforcement_configuration.psa_namespace_policies",
    "assertion_id": "containers_kubernetes.psa_enforcement.psa_namespace_policies",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for psa_namespace_policies to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.psa_enforcement_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute psa_namespace_policies implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for psa_namespace_policies",
    "remediation": "Configure compute with security best practices for psa_namespace_policies",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.secret_hygiene_configuration.no_plaintext_secrets",
    "assertion_id": "serverless_paas.secret_hygiene.no_plaintext_secrets",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for no_plaintext_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.secret_hygiene_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless no_plaintext_secrets implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for no_plaintext_secrets",
    "remediation": "Configure serverless with security best practices for no_plaintext_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.secret_hygiene_configuration.use_managed_secret_references",
    "assertion_id": "serverless_paas.secret_hygiene.use_managed_secret_references",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for use_managed_secret_references to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.secret_hygiene_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless use_managed_secret_references implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for use_managed_secret_references",
    "remediation": "Configure serverless with security best practices for use_managed_secret_references",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.secret_hygiene_configuration.rotate_function_secrets",
    "assertion_id": "serverless_paas.secret_hygiene.rotate_function_secrets",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "rotation_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for rotate_function_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.secret_hygiene_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless rotate_function_secrets implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for rotate_function_secrets",
    "remediation": "Configure serverless with security best practices for rotate_function_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.secret_hygiene_configuration.audit_secret_access",
    "assertion_id": "serverless_paas.secret_hygiene.audit_secret_access",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for audit_secret_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.secret_hygiene_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless audit_secret_access implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for audit_secret_access",
    "remediation": "Configure serverless with security best practices for audit_secret_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.secret_hygiene_configuration.least_privilege_secret_access",
    "assertion_id": "serverless_paas.secret_hygiene.least_privilege_secret_access",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for least_privilege_secret_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.secret_hygiene_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless least_privilege_secret_access implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for least_privilege_secret_access",
    "remediation": "Configure serverless with security best practices for least_privilege_secret_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.secret_hygiene_configuration.no_plaintext_secrets",
    "assertion_id": "serverless_paas.secret_hygiene.no_plaintext_secrets",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for no_plaintext_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.secret_hygiene_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless no_plaintext_secrets implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for no_plaintext_secrets",
    "remediation": "Configure serverless with security best practices for no_plaintext_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.secret_hygiene_configuration.use_managed_secret_references",
    "assertion_id": "serverless_paas.secret_hygiene.use_managed_secret_references",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for use_managed_secret_references to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.secret_hygiene_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless use_managed_secret_references implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for use_managed_secret_references",
    "remediation": "Configure serverless with security best practices for use_managed_secret_references",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.secret_hygiene_configuration.rotate_function_secrets",
    "assertion_id": "serverless_paas.secret_hygiene.rotate_function_secrets",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "rotation_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for rotate_function_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.secret_hygiene_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless rotate_function_secrets implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for rotate_function_secrets",
    "remediation": "Configure serverless with security best practices for rotate_function_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.secret_hygiene_configuration.audit_secret_access",
    "assertion_id": "serverless_paas.secret_hygiene.audit_secret_access",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for audit_secret_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.secret_hygiene_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless audit_secret_access implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for audit_secret_access",
    "remediation": "Configure serverless with security best practices for audit_secret_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.secret_hygiene_configuration.least_privilege_secret_access",
    "assertion_id": "serverless_paas.secret_hygiene.least_privilege_secret_access",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for least_privilege_secret_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.secret_hygiene_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless least_privilege_secret_access implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for least_privilege_secret_access",
    "remediation": "Configure serverless with security best practices for least_privilege_secret_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.secret_hygiene_configuration.no_plaintext_secrets",
    "assertion_id": "serverless_paas.secret_hygiene.no_plaintext_secrets",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for no_plaintext_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.secret_hygiene_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless no_plaintext_secrets implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for no_plaintext_secrets",
    "remediation": "Configure serverless with security best practices for no_plaintext_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.secret_hygiene_configuration.use_managed_secret_references",
    "assertion_id": "serverless_paas.secret_hygiene.use_managed_secret_references",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for use_managed_secret_references to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.secret_hygiene_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless use_managed_secret_references implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for use_managed_secret_references",
    "remediation": "Configure serverless with security best practices for use_managed_secret_references",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.secret_hygiene_configuration.rotate_function_secrets",
    "assertion_id": "serverless_paas.secret_hygiene.rotate_function_secrets",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "rotation_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for rotate_function_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.secret_hygiene_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless rotate_function_secrets implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for rotate_function_secrets",
    "remediation": "Configure serverless with security best practices for rotate_function_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.secret_hygiene_configuration.audit_secret_access",
    "assertion_id": "serverless_paas.secret_hygiene.audit_secret_access",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for audit_secret_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.secret_hygiene_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless audit_secret_access implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for audit_secret_access",
    "remediation": "Configure serverless with security best practices for audit_secret_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.secret_hygiene_configuration.least_privilege_secret_access",
    "assertion_id": "serverless_paas.secret_hygiene.least_privilege_secret_access",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for least_privilege_secret_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.secret_hygiene_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless least_privilege_secret_access implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for least_privilege_secret_access",
    "remediation": "Configure serverless with security best practices for least_privilege_secret_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.sbom_provenance_configuration.generate_sbom",
    "assertion_id": "supply_chain_registries.sbom_provenance.generate_sbom",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for generate_sbom to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.sbom_provenance_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute generate_sbom implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for generate_sbom",
    "remediation": "Configure compute with security best practices for generate_sbom",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.sbom_provenance_configuration.sign_sbom",
    "assertion_id": "supply_chain_registries.sbom_provenance.sign_sbom",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for sign_sbom to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.sbom_provenance_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute sign_sbom implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for sign_sbom",
    "remediation": "Configure compute with security best practices for sign_sbom",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.sbom_provenance_configuration.verify_provenance",
    "assertion_id": "supply_chain_registries.sbom_provenance.verify_provenance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for verify_provenance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.sbom_provenance_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute verify_provenance implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for verify_provenance",
    "remediation": "Configure compute with security best practices for verify_provenance",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.sbom_provenance_configuration.attest_build_environment",
    "assertion_id": "supply_chain_registries.sbom_provenance.attest_build_environment",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for attest_build_environment to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.sbom_provenance_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute attest_build_environment implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for attest_build_environment",
    "remediation": "Configure compute with security best practices for attest_build_environment",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.sbom_provenance_configuration.enforce_sbom_policy",
    "assertion_id": "supply_chain_registries.sbom_provenance.enforce_sbom_policy",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for enforce_sbom_policy to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.sbom_provenance_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute enforce_sbom_policy implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for enforce_sbom_policy",
    "remediation": "Configure compute with security best practices for enforce_sbom_policy",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.sbom_provenance_configuration.generate_sbom",
    "assertion_id": "supply_chain_registries.sbom_provenance.generate_sbom",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for generate_sbom to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.sbom_provenance_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute generate_sbom implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for generate_sbom",
    "remediation": "Configure compute with security best practices for generate_sbom",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.sbom_provenance_configuration.sign_sbom",
    "assertion_id": "supply_chain_registries.sbom_provenance.sign_sbom",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for sign_sbom to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.sbom_provenance_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute sign_sbom implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for sign_sbom",
    "remediation": "Configure compute with security best practices for sign_sbom",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.sbom_provenance_configuration.verify_provenance",
    "assertion_id": "supply_chain_registries.sbom_provenance.verify_provenance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for verify_provenance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.sbom_provenance_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute verify_provenance implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for verify_provenance",
    "remediation": "Configure compute with security best practices for verify_provenance",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.sbom_provenance_configuration.attest_build_environment",
    "assertion_id": "supply_chain_registries.sbom_provenance.attest_build_environment",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for attest_build_environment to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.sbom_provenance_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute attest_build_environment implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for attest_build_environment",
    "remediation": "Configure compute with security best practices for attest_build_environment",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.sbom_provenance_configuration.enforce_sbom_policy",
    "assertion_id": "supply_chain_registries.sbom_provenance.enforce_sbom_policy",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for enforce_sbom_policy to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.sbom_provenance_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute enforce_sbom_policy implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for enforce_sbom_policy",
    "remediation": "Configure compute with security best practices for enforce_sbom_policy",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_immutability_configuration.append_only_logging",
    "assertion_id": "logging_monitoring.log_immutability.append_only_logging",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_immutability_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for append_only_logging to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_immutability_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring append_only_logging implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for append_only_logging",
    "remediation": "Configure monitoring with security best practices for append_only_logging",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_immutability_configuration.retention_lock_enabled",
    "assertion_id": "logging_monitoring.log_immutability.retention_lock_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_immutability_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for retention_lock_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_immutability_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring retention_lock_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for retention_lock_enabled",
    "remediation": "Configure monitoring with security best practices for retention_lock_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_immutability_configuration.legal_hold_logs",
    "assertion_id": "logging_monitoring.log_immutability.legal_hold_logs",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_immutability_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for legal_hold_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_immutability_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring legal_hold_logs implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for legal_hold_logs",
    "remediation": "Configure monitoring with security best practices for legal_hold_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_immutability_configuration.tamper_evident_logs",
    "assertion_id": "logging_monitoring.log_immutability.tamper_evident_logs",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_immutability_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for tamper_evident_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_immutability_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring tamper_evident_logs implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for tamper_evident_logs",
    "remediation": "Configure monitoring with security best practices for tamper_evident_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_immutability_configuration.immutable_audit_trail",
    "assertion_id": "logging_monitoring.log_immutability.immutable_audit_trail",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_immutability_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for immutable_audit_trail to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_immutability_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring immutable_audit_trail implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for immutable_audit_trail",
    "remediation": "Configure monitoring with security best practices for immutable_audit_trail",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_immutability_configuration.append_only_logging",
    "assertion_id": "logging_monitoring.log_immutability.append_only_logging",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_immutability_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for append_only_logging to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_immutability_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring append_only_logging implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for append_only_logging",
    "remediation": "Configure monitoring with security best practices for append_only_logging",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_immutability_configuration.retention_lock_enabled",
    "assertion_id": "logging_monitoring.log_immutability.retention_lock_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_immutability_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for retention_lock_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_immutability_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring retention_lock_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for retention_lock_enabled",
    "remediation": "Configure monitoring with security best practices for retention_lock_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_immutability_configuration.legal_hold_logs",
    "assertion_id": "logging_monitoring.log_immutability.legal_hold_logs",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_immutability_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for legal_hold_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_immutability_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring legal_hold_logs implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for legal_hold_logs",
    "remediation": "Configure monitoring with security best practices for legal_hold_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_immutability_configuration.tamper_evident_logs",
    "assertion_id": "logging_monitoring.log_immutability.tamper_evident_logs",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_immutability_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for tamper_evident_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_immutability_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring tamper_evident_logs implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for tamper_evident_logs",
    "remediation": "Configure monitoring with security best practices for tamper_evident_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_immutability_configuration.immutable_audit_trail",
    "assertion_id": "logging_monitoring.log_immutability.immutable_audit_trail",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_immutability_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for immutable_audit_trail to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_immutability_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring immutable_audit_trail implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for immutable_audit_trail",
    "remediation": "Configure monitoring with security best practices for immutable_audit_trail",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_immutability_configuration.append_only_logging",
    "assertion_id": "logging_monitoring.log_immutability.append_only_logging",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_immutability_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for append_only_logging to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_immutability_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter append_only_logging implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for append_only_logging",
    "remediation": "Configure securitycenter with security best practices for append_only_logging",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_immutability_configuration.retention_lock_enabled",
    "assertion_id": "logging_monitoring.log_immutability.retention_lock_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_immutability_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for retention_lock_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_immutability_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter retention_lock_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for retention_lock_enabled",
    "remediation": "Configure securitycenter with security best practices for retention_lock_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_immutability_configuration.legal_hold_logs",
    "assertion_id": "logging_monitoring.log_immutability.legal_hold_logs",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_immutability_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for legal_hold_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_immutability_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter legal_hold_logs implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for legal_hold_logs",
    "remediation": "Configure securitycenter with security best practices for legal_hold_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_immutability_configuration.tamper_evident_logs",
    "assertion_id": "logging_monitoring.log_immutability.tamper_evident_logs",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_immutability_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for tamper_evident_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_immutability_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter tamper_evident_logs implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for tamper_evident_logs",
    "remediation": "Configure securitycenter with security best practices for tamper_evident_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_immutability_configuration.immutable_audit_trail",
    "assertion_id": "logging_monitoring.log_immutability.immutable_audit_trail",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_immutability_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for immutable_audit_trail to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_immutability_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter immutable_audit_trail implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for immutable_audit_trail",
    "remediation": "Configure securitycenter with security best practices for immutable_audit_trail",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.ransomware_protection_configuration.immutable_backups",
    "assertion_id": "resilience_recovery.ransomware_protection.immutable_backups",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for immutable_backups to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.ransomware_protection_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute immutable_backups implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for immutable_backups",
    "remediation": "Configure compute with security best practices for immutable_backups",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.ransomware_protection_configuration.isolated_recovery_environment",
    "assertion_id": "resilience_recovery.ransomware_protection.isolated_recovery_environment",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for isolated_recovery_environment to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.ransomware_protection_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute isolated_recovery_environment implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for isolated_recovery_environment",
    "remediation": "Configure compute with security best practices for isolated_recovery_environment",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.ransomware_protection_configuration.malware_scan_backups",
    "assertion_id": "resilience_recovery.ransomware_protection.malware_scan_backups",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for malware_scan_backups to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.ransomware_protection_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute malware_scan_backups implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for malware_scan_backups",
    "remediation": "Configure compute with security best practices for malware_scan_backups",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.ransomware_protection_configuration.pitr_capability",
    "assertion_id": "resilience_recovery.ransomware_protection.pitr_capability",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "recovery_point_minutes": 15
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for pitr_capability to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.ransomware_protection_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute pitr_capability implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for pitr_capability",
    "remediation": "Configure compute with security best practices for pitr_capability",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.ransomware_protection_configuration.air_gapped_backups",
    "assertion_id": "resilience_recovery.ransomware_protection.air_gapped_backups",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for air_gapped_backups to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.ransomware_protection_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute air_gapped_backups implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for air_gapped_backups",
    "remediation": "Configure compute with security best practices for air_gapped_backups",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.ransomware_protection_configuration.immutable_backups",
    "assertion_id": "resilience_recovery.ransomware_protection.immutable_backups",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for immutable_backups to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.ransomware_protection_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage immutable_backups implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for immutable_backups",
    "remediation": "Configure storage with security best practices for immutable_backups",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.ransomware_protection_configuration.isolated_recovery_environment",
    "assertion_id": "resilience_recovery.ransomware_protection.isolated_recovery_environment",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for isolated_recovery_environment to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.ransomware_protection_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage isolated_recovery_environment implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for isolated_recovery_environment",
    "remediation": "Configure storage with security best practices for isolated_recovery_environment",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.ransomware_protection_configuration.malware_scan_backups",
    "assertion_id": "resilience_recovery.ransomware_protection.malware_scan_backups",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for malware_scan_backups to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.ransomware_protection_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage malware_scan_backups implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for malware_scan_backups",
    "remediation": "Configure storage with security best practices for malware_scan_backups",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.ransomware_protection_configuration.pitr_capability",
    "assertion_id": "resilience_recovery.ransomware_protection.pitr_capability",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "recovery_point_minutes": 15
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for pitr_capability to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.ransomware_protection_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage pitr_capability implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for pitr_capability",
    "remediation": "Configure storage with security best practices for pitr_capability",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.ransomware_protection_configuration.air_gapped_backups",
    "assertion_id": "resilience_recovery.ransomware_protection.air_gapped_backups",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for air_gapped_backups to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.ransomware_protection_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage air_gapped_backups implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for air_gapped_backups",
    "remediation": "Configure storage with security best practices for air_gapped_backups",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.exceptions_registry_configuration.track_exceptions",
    "assertion_id": "governance_compliance.exceptions_registry.track_exceptions",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for track_exceptions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.exceptions_registry_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager track_exceptions implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for track_exceptions",
    "remediation": "Configure resourcemanager with security best practices for track_exceptions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.exceptions_registry_configuration.exception_approval",
    "assertion_id": "governance_compliance.exceptions_registry.exception_approval",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for exception_approval to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.exceptions_registry_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager exception_approval implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for exception_approval",
    "remediation": "Configure resourcemanager with security best practices for exception_approval",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.exceptions_registry_configuration.exception_expiry",
    "assertion_id": "governance_compliance.exceptions_registry.exception_expiry",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_duration_days": 365
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for exception_expiry to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.exceptions_registry_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager exception_expiry implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for exception_expiry",
    "remediation": "Configure resourcemanager with security best practices for exception_expiry",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.exceptions_registry_configuration.exception_controls",
    "assertion_id": "governance_compliance.exceptions_registry.exception_controls",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for exception_controls to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.exceptions_registry_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager exception_controls implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for exception_controls",
    "remediation": "Configure resourcemanager with security best practices for exception_controls",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.exceptions_registry_configuration.exception_monitoring",
    "assertion_id": "governance_compliance.exceptions_registry.exception_monitoring",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for exception_monitoring to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.exceptions_registry_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager exception_monitoring implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for exception_monitoring",
    "remediation": "Configure resourcemanager with security best practices for exception_monitoring",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.exceptions_registry_configuration.track_exceptions",
    "assertion_id": "governance_compliance.exceptions_registry.track_exceptions",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for track_exceptions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.exceptions_registry_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter track_exceptions implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for track_exceptions",
    "remediation": "Configure securitycenter with security best practices for track_exceptions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.exceptions_registry_configuration.exception_approval",
    "assertion_id": "governance_compliance.exceptions_registry.exception_approval",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for exception_approval to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.exceptions_registry_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter exception_approval implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for exception_approval",
    "remediation": "Configure securitycenter with security best practices for exception_approval",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.exceptions_registry_configuration.exception_expiry",
    "assertion_id": "governance_compliance.exceptions_registry.exception_expiry",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_duration_days": 365
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for exception_expiry to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.exceptions_registry_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter exception_expiry implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for exception_expiry",
    "remediation": "Configure securitycenter with security best practices for exception_expiry",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.exceptions_registry_configuration.exception_controls",
    "assertion_id": "governance_compliance.exceptions_registry.exception_controls",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for exception_controls to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.exceptions_registry_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter exception_controls implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for exception_controls",
    "remediation": "Configure securitycenter with security best practices for exception_controls",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.exceptions_registry_configuration.exception_monitoring",
    "assertion_id": "governance_compliance.exceptions_registry.exception_monitoring",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for exception_monitoring to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.exceptions_registry_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter exception_monitoring implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for exception_monitoring",
    "remediation": "Configure securitycenter with security best practices for exception_monitoring",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.exceptions_registry_configuration.track_exceptions",
    "assertion_id": "governance_compliance.exceptions_registry.track_exceptions",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for track_exceptions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.exceptions_registry_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute track_exceptions implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for track_exceptions",
    "remediation": "Configure compute with security best practices for track_exceptions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.exceptions_registry_configuration.exception_approval",
    "assertion_id": "governance_compliance.exceptions_registry.exception_approval",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for exception_approval to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.exceptions_registry_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute exception_approval implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for exception_approval",
    "remediation": "Configure compute with security best practices for exception_approval",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.exceptions_registry_configuration.exception_expiry",
    "assertion_id": "governance_compliance.exceptions_registry.exception_expiry",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_duration_days": 365
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for exception_expiry to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.exceptions_registry_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute exception_expiry implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for exception_expiry",
    "remediation": "Configure compute with security best practices for exception_expiry",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.exceptions_registry_configuration.exception_controls",
    "assertion_id": "governance_compliance.exceptions_registry.exception_controls",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for exception_controls to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.exceptions_registry_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute exception_controls implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for exception_controls",
    "remediation": "Configure compute with security best practices for exception_controls",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.exceptions_registry_configuration.exception_monitoring",
    "assertion_id": "governance_compliance.exceptions_registry.exception_monitoring",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for exception_monitoring to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.exceptions_registry_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute exception_monitoring implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for exception_monitoring",
    "remediation": "Configure compute with security best practices for exception_monitoring",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.deprecation_tracking_configuration.track_deprecated_apis",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.track_deprecated_apis",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for track_deprecated_apis to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.deprecation_tracking_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute track_deprecated_apis implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for track_deprecated_apis",
    "remediation": "Configure compute with security best practices for track_deprecated_apis",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.deprecation_tracking_configuration.enforce_migration_plans",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.enforce_migration_plans",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for enforce_migration_plans to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.deprecation_tracking_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute enforce_migration_plans implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for enforce_migration_plans",
    "remediation": "Configure compute with security best practices for enforce_migration_plans",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.deprecation_tracking_configuration.deprecation_notifications",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.deprecation_notifications",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "notification_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for deprecation_notifications to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.deprecation_tracking_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute deprecation_notifications implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for deprecation_notifications",
    "remediation": "Configure compute with security best practices for deprecation_notifications",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.deprecation_tracking_configuration.version_compliance",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.version_compliance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for version_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.deprecation_tracking_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute version_compliance implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for version_compliance",
    "remediation": "Configure compute with security best practices for version_compliance",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.deprecation_tracking_configuration.eol_monitoring",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.eol_monitoring",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for eol_monitoring to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.deprecation_tracking_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute eol_monitoring implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for eol_monitoring",
    "remediation": "Configure compute with security best practices for eol_monitoring",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.deprecation_tracking_configuration.track_deprecated_apis",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.track_deprecated_apis",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for track_deprecated_apis to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.deprecation_tracking_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container track_deprecated_apis implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for track_deprecated_apis",
    "remediation": "Configure container with security best practices for track_deprecated_apis",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.deprecation_tracking_configuration.enforce_migration_plans",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.enforce_migration_plans",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for enforce_migration_plans to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.deprecation_tracking_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container enforce_migration_plans implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for enforce_migration_plans",
    "remediation": "Configure container with security best practices for enforce_migration_plans",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.deprecation_tracking_configuration.deprecation_notifications",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.deprecation_notifications",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "notification_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for deprecation_notifications to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.deprecation_tracking_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container deprecation_notifications implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for deprecation_notifications",
    "remediation": "Configure container with security best practices for deprecation_notifications",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.deprecation_tracking_configuration.version_compliance",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.version_compliance",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for version_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.deprecation_tracking_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container version_compliance implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for version_compliance",
    "remediation": "Configure container with security best practices for version_compliance",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.deprecation_tracking_configuration.eol_monitoring",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.eol_monitoring",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for eol_monitoring to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.deprecation_tracking_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container eol_monitoring implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for eol_monitoring",
    "remediation": "Configure container with security best practices for eol_monitoring",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.deprecation_tracking_configuration.track_deprecated_apis",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.track_deprecated_apis",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for track_deprecated_apis to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.deprecation_tracking_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless track_deprecated_apis implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for track_deprecated_apis",
    "remediation": "Configure serverless with security best practices for track_deprecated_apis",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.deprecation_tracking_configuration.enforce_migration_plans",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.enforce_migration_plans",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for enforce_migration_plans to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.deprecation_tracking_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless enforce_migration_plans implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for enforce_migration_plans",
    "remediation": "Configure serverless with security best practices for enforce_migration_plans",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.deprecation_tracking_configuration.deprecation_notifications",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.deprecation_notifications",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "notification_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for deprecation_notifications to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.deprecation_tracking_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless deprecation_notifications implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for deprecation_notifications",
    "remediation": "Configure serverless with security best practices for deprecation_notifications",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.deprecation_tracking_configuration.version_compliance",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.version_compliance",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for version_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.deprecation_tracking_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless version_compliance implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for version_compliance",
    "remediation": "Configure serverless with security best practices for version_compliance",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.deprecation_tracking_configuration.eol_monitoring",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.eol_monitoring",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for eol_monitoring to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.deprecation_tracking_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless eol_monitoring implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for eol_monitoring",
    "remediation": "Configure serverless with security best practices for eol_monitoring",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.group.group_mfa_enforced",
    "assertion_id": "identity_access.authentication.group_mfa_enforced",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.group_mfa_enforcement",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Group-based MFA ensures all privileged users have strong authentication.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.group_mfa_enforcement",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity group_mfa_enforcement implementation",
    "title": "Cloud Identity Group MFA Check",
    "description": "Ensure cloudidentity implements security best practices for group_mfa_enforced",
    "remediation": "Configure cloudidentity with security best practices for group_mfa_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.group.group_roles_least_privilege",
    "assertion_id": "rbac_entitlements.role_definition.group_roles_least_privilege",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.group_roles",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Group roles should be scoped to minimum required permissions.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.group_roles",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity group_roles implementation",
    "title": "Cloud Identity Group Roles Check",
    "description": "Ensure cloudidentity implements security best practices for group_roles_least_privilege",
    "remediation": "Configure cloudidentity with security best practices for group_roles_least_privilege",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.filestore.instance.fileshare_encryption_enabled",
    "assertion_id": "storage_datastores.storage_security.fileshare_encryption_enabled",
    "provider": "gcp",
    "service": "filestore",
    "resource_type": "gcp.filestore.instance",
    "adapter": "gcp.filestore.encryption_at_rest",
    "adapter_evidence_type": "gcp.filestore.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Encryption protects file share data from unauthorized access.",
    "adapter_spec": {
      "function": "gcp.filestore.encryption_at_rest",
      "evidence_path": "gcp.filestore.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate filestore encryption_at_rest implementation",
    "title": "Filestore Encryption Check",
    "description": "Ensure filestore implements security best practices for fileshare_encryption_enabled",
    "remediation": "Configure filestore with security best practices for fileshare_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.pubsub.topic.queue_encryption_enabled",
    "assertion_id": "storage_datastores.storage_security.queue_encryption_enabled",
    "provider": "gcp",
    "service": "pubsub",
    "resource_type": "gcp.pubsub.topic",
    "adapter": "gcp.pubsub.topic_encryption",
    "adapter_evidence_type": "gcp.pubsub.topic[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "Queue encryption prevents data exposure from message interception.",
    "adapter_spec": {
      "function": "gcp.pubsub.topic_encryption",
      "evidence_path": "gcp.pubsub.topic[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate pubsub topic_encryption implementation",
    "title": "Pub/Sub Topic Encryption Check",
    "description": "Ensure pubsub implements security best practices for queue_encryption_enabled",
    "remediation": "Configure pubsub with security best practices for queue_encryption_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firestore.database.table_encryption_enabled",
    "assertion_id": "storage_datastores.storage_security.table_encryption_enabled",
    "provider": "gcp",
    "service": "firestore",
    "resource_type": "gcp.firestore.database",
    "adapter": "gcp.firestore.database_encryption",
    "adapter_evidence_type": "gcp.firestore.database[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Table encryption protects structured data at rest.",
    "adapter_spec": {
      "function": "gcp.firestore.database_encryption",
      "evidence_path": "gcp.firestore.database[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate firestore database_encryption implementation",
    "title": "Firestore Database Encryption Check",
    "description": "Ensure firestore implements security best practices for table_encryption_enabled",
    "remediation": "Configure firestore with security best practices for table_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.snapshot.snapshot_encryption_enabled",
    "assertion_id": "storage_datastores.snapshot_management.snapshot_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.snapshot",
    "adapter": "gcp.compute.snapshot_encryption",
    "adapter_evidence_type": "gcp.compute.snapshot[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Snapshot encryption prevents data exposure from backup access.",
    "adapter_spec": {
      "function": "gcp.compute.snapshot_encryption",
      "evidence_path": "gcp.compute.snapshot[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute snapshot_encryption implementation",
    "title": "Compute Snapshot Encryption Check",
    "description": "Ensure compute implements security best practices for snapshot_encryption_enabled",
    "remediation": "Configure compute with security best practices for snapshot_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk.volume_encryption_enabled",
    "assertion_id": "storage_datastores.storage_security.volume_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.disk",
    "adapter": "gcp.compute.disk_encryption",
    "adapter_evidence_type": "gcp.compute.disk[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Volume encryption protects persistent data from unauthorized access.",
    "adapter_spec": {
      "function": "gcp.compute.disk_encryption",
      "evidence_path": "gcp.compute.disk[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute disk_encryption implementation",
    "title": "Compute Disk Encryption Check",
    "description": "Ensure compute implements security best practices for volume_encryption_enabled",
    "remediation": "Configure compute with security best practices for volume_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.image.golden_images_used",
    "assertion_id": "compute_host_security.image_security.golden_images_used",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.image",
    "adapter": "gcp.compute.image_approval",
    "adapter_evidence_type": "gcp.compute.image[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "Golden images reduce attack surface and ensure consistent hardening.",
    "adapter_spec": {
      "function": "gcp.compute.image_approval",
      "evidence_path": "gcp.compute.image[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute image_approval implementation",
    "title": "Compute Image Approval Check",
    "description": "Ensure compute implements security best practices for golden_images_used",
    "remediation": "Configure compute with security best practices for golden_images_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.image.image_vulnerability_scanning",
    "assertion_id": "compute_host_security.image_security.image_vulnerability_scanning",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.image",
    "adapter": "gcp.compute.image_vulnerability_scan",
    "adapter_evidence_type": "gcp.compute.image[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Pre-deployment scanning prevents vulnerable images from being deployed.",
    "adapter_spec": {
      "function": "gcp.compute.image_vulnerability_scan",
      "evidence_path": "gcp.compute.image[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute image_vulnerability_scan implementation",
    "title": "Compute Image Vulnerability Scan Check",
    "description": "Ensure compute implements security best practices for image_vulnerability_scanning",
    "remediation": "Configure compute with security best practices for image_vulnerability_scanning",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instanceGroup.instance_group_secure_config",
    "assertion_id": "cluster_management_plane.capacity_management.instance_group_secure_config",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instanceGroup",
    "adapter": "gcp.compute.instance_group_configuration",
    "adapter_evidence_type": "gcp.compute.instanceGroup[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Secure instance group configuration prevents security misconfigurations.",
    "adapter_spec": {
      "function": "gcp.compute.instance_group_configuration",
      "evidence_path": "gcp.compute.instanceGroup[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute instance_group_configuration implementation",
    "title": "Compute Instance Group Configuration Check",
    "description": "Ensure compute implements security best practices for instance_group_secure_config",
    "remediation": "Configure compute with security best practices for instance_group_secure_config",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.firewall.security_group_least_privilege",
    "assertion_id": "network_segmentation.microsegmentation.security_group_least_privilege",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.firewall",
    "adapter": "gcp.compute.firewall_rules",
    "adapter_evidence_type": "gcp.compute.firewall[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Least privilege security group rules minimize attack surface.",
    "adapter_spec": {
      "function": "gcp.compute.firewall_rules",
      "evidence_path": "gcp.compute.firewall[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute firewall_rules implementation",
    "title": "Compute Firewall Rules Check",
    "description": "Ensure compute implements security best practices for security_group_least_privilege",
    "remediation": "Configure compute with security best practices for security_group_least_privilege",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.route.route_tables_secure_routing",
    "assertion_id": "network_segmentation.network_segmentation.route_tables_secure_routing",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.route",
    "adapter": "gcp.compute.route_rules",
    "adapter_evidence_type": "gcp.compute.route[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "Secure routing prevents traffic from bypassing security controls.",
    "adapter_spec": {
      "function": "gcp.compute.route_rules",
      "evidence_path": "gcp.compute.route[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute route_rules implementation",
    "title": "Compute Route Rules Check",
    "description": "Ensure compute implements security best practices for route_tables_secure_routing",
    "remediation": "Configure compute with security best practices for route_tables_secure_routing",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.container.cluster.cluster_encryption_enabled",
    "assertion_id": "containers_kubernetes.cluster_hardening.cluster_encryption_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.container.cluster_encryption",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Cluster encryption protects etcd and API server data.",
    "adapter_spec": {
      "function": "gcp.container.cluster_encryption",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container cluster_encryption implementation",
    "title": "Container Cluster Encryption Check",
    "description": "Ensure container implements security best practices for cluster_encryption_enabled",
    "remediation": "Configure container with security best practices for cluster_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.container.nodePool.node_pool_security_configured",
    "assertion_id": "containers_kubernetes.cluster_hardening.node_pool_security_configured",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.nodePool",
    "adapter": "gcp.container.node_pool_security",
    "adapter_evidence_type": "gcp.container.nodePool[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Node pool security ensures consistent hardening across worker nodes.",
    "adapter_spec": {
      "function": "gcp.container.node_pool_security",
      "evidence_path": "gcp.container.nodePool[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container node_pool_security implementation",
    "title": "Container Node Pool Security Check",
    "description": "Ensure container implements security best practices for node_pool_security_configured",
    "remediation": "Configure container with security best practices for node_pool_security_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.repository.access_controls_configured",
    "assertion_id": "supply_chain_registries.registry_policy.access_controls_configured",
    "provider": "gcp",
    "service": "artifactregistry",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.repository_policy",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Registry policies control access to container images and artifacts.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.repository_policy",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate artifactregistry repository_policy implementation",
    "title": "Artifact Registry Repository Policy Check",
    "description": "Ensure artifactregistry implements security best practices for access_controls_configured",
    "remediation": "Configure artifactregistry with security best practices for access_controls_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.repository.vulnerability_scanning_enforced",
    "assertion_id": "supply_chain_registries.registry_policy.vulnerability_scanning_enforced",
    "provider": "gcp",
    "service": "artifactregistry",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.vulnerability_scanning",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Automated scanning prevents vulnerable images from entering the registry.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.vulnerability_scanning",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate artifactregistry vulnerability_scanning implementation",
    "title": "Artifact Registry Vulnerability Scanning Check",
    "description": "Ensure artifactregistry implements security best practices for vulnerability_scanning_enforced",
    "remediation": "Configure artifactregistry with security best practices for vulnerability_scanning_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.organization.account_type.corporate_credentials_only",
    "assertion_id": "iam.organization.account_type.corporate_credentials_only",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.organization",
    "adapter": "gcp.iam.organization",
    "adapter_evidence_type": "gcp.iam.organization[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam organization must implement account_type controls for corporate_credentials_only to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.organization",
      "params": {
        "check_type": "account_type",
        "what_to_check": "corporate_credentials_only"
      },
      "function_name": "gcp_iam_service_account_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "1.1",
      "title": "Ensure that Corporate Login Credentials are Used",
      "function_names": [
        "gcp_iam_service_account_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.459952",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "1.1"
  },
  {
    "rule_id": "gcp.security.general.security_key.security_key_enforcement_enabled",
    "assertion_id": "security.general.security_key.security_key_enforcement_enabled",
    "provider": "gcp",
    "service": "security",
    "resource_type": "gcp.security.general",
    "adapter": "gcp.security.general",
    "adapter_evidence_type": "gcp.security.general[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP security general must implement security_key controls for security_key_enforcement_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.security.general",
      "params": {
        "check_type": "security_key",
        "what_to_check": "security_key_enforcement_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "1.3",
      "title": "Ensure that Security Key Enforcement is Enabled for All Admin Accounts",
      "function_names": [
        "gcp_iam_user_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.459981",
    "is_primary": true
  },
  {
    "rule_id": "gcp.iam.service_account.key_management.project_level_roles_restricted",
    "assertion_id": "iam.service_account.key_management.project_level_roles_restricted",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.service_account",
    "adapter": "gcp.iam.service_account",
    "adapter_evidence_type": "gcp.iam.service_account[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam service_account must implement key_management controls for project_level_roles_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account",
      "params": {
        "check_type": "key_management",
        "what_to_check": "project_level_roles_restricted"
      },
      "function_name": "gcp_iam_service_account_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "1.4",
      "title": "Ensure That There Are Only GCP-Managed Service Account Keys for Each Service Account",
      "function_names": [
        "gcp_iam_service_account_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.459989",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "1.4"
  },
  {
    "rule_id": "gcp.iam.service_account.privilege.admin_privileges_restricted",
    "assertion_id": "iam.service_account.privilege.admin_privileges_restricted",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.service_account",
    "adapter": "gcp.iam.service_account",
    "adapter_evidence_type": "gcp.iam.service_account[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam service_account must implement privilege controls for admin_privileges_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account",
      "params": {
        "check_type": "privilege",
        "what_to_check": "admin_privileges_restricted"
      },
      "function_name": "gcp_iam_service_account_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "1.5",
      "title": "Ensure That Service Account Has No Admin Privileges",
      "function_names": [
        "gcp_iam_service_account_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.459995",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "1.5"
  },
  {
    "rule_id": "gcp.iam.service_account.security.project_level_roles_restricted",
    "assertion_id": "iam.service_account.security.project_level_roles_restricted",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.service_account",
    "adapter": "gcp.iam.service_account",
    "adapter_evidence_type": "gcp.iam.service_account[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam service_account must implement security controls for project_level_roles_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account",
      "params": {
        "check_type": "security",
        "what_to_check": "project_level_roles_restricted"
      },
      "function_name": "gcp_iam_service_account_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "1.6",
      "title": "Ensure That IAM Users Are Not Assigned the Service Account User or Service Account Token Creator Roles at Project Level",
      "function_names": [
        "gcp_iam_service_account_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460003",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "1.6"
  },
  {
    "rule_id": "gcp.iam.service_account.key_management.security_policies_enforced",
    "assertion_id": "iam.service_account.key_management.security_policies_enforced",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.service_account",
    "adapter": "gcp.iam.service_account",
    "adapter_evidence_type": "gcp.iam.service_account[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam service_account must implement key_management controls for security_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account",
      "params": {
        "check_type": "key_management",
        "what_to_check": "security_policies_enforced"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "1.7",
      "title": "Ensure User-Managed/External Keys for Service Accounts Are Rotated Every 90 Days or Fewer",
      "function_names": [
        "gcp_iam_service_account_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460009",
    "is_primary": true
  },
  {
    "rule_id": "gcp.iam.service_account.separation.project_level_roles_restricted",
    "assertion_id": "iam.service_account.separation.project_level_roles_restricted",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.service_account",
    "adapter": "gcp.iam.service_account",
    "adapter_evidence_type": "gcp.iam.service_account[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam service_account must implement separation controls for project_level_roles_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account",
      "params": {
        "check_type": "separation",
        "what_to_check": "project_level_roles_restricted"
      },
      "function_name": "gcp_iam_service_account_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "1.8",
      "title": "Ensure That Separation of Duties Is Enforced While Assigning Service Account Related Roles to Users",
      "function_names": [
        "gcp_iam_service_account_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460014",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "1.8"
  },
  {
    "rule_id": "gcp.kms.key.access_control.public_access_blocked",
    "assertion_id": "kms.key.access_control.public_access_blocked",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.key",
    "adapter": "gcp.kms.key",
    "adapter_evidence_type": "gcp.kms.key[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP kms key must implement access_control controls for public_access_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key",
      "params": {
        "check_type": "access_control",
        "what_to_check": "public_access_blocked"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "1.9",
      "title": "Ensure That Cloud KMS Cryptokeys Are Not Anonymously or Publicly Accessible",
      "function_names": [
        "gcp_iam_user_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460022",
    "is_primary": true
  },
  {
    "rule_id": "gcp.kms.key.key_management.key_rotation_enabled",
    "assertion_id": "kms.key.key_management.key_rotation_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.key",
    "adapter": "gcp.kms.key",
    "adapter_evidence_type": "gcp.kms.key[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP kms key must implement key_management controls for key_rotation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key",
      "params": {
        "check_type": "key_management",
        "what_to_check": "key_rotation_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "1.10",
      "title": "Ensure KMS Encryption Keys Are Rotated Within a Period of 90 Days",
      "function_names": [
        "gcp_kms_encryption_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460027",
    "is_primary": true
  },
  {
    "rule_id": "gcp.kms.key.separation.separation_of_duties_enforced",
    "assertion_id": "kms.key.separation.separation_of_duties_enforced",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.key",
    "adapter": "gcp.kms.key",
    "adapter_evidence_type": "gcp.kms.key[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP kms key must implement separation controls for separation_of_duties_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key",
      "params": {
        "check_type": "separation",
        "what_to_check": "separation_of_duties_enforced"
      },
      "function_name": "gcp_iam_user_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "1.11",
      "title": "Ensure That Separation of Duties Is Enforced While Assigning KMS Related Roles to Users",
      "function_names": [
        "gcp_iam_user_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460032",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "1.11"
  },
  {
    "rule_id": "gcp.iam.role.access_control.public_access_restricted",
    "assertion_id": "iam.role.access_control.public_access_restricted",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.role",
    "adapter": "gcp.iam.role",
    "adapter_evidence_type": "gcp.iam.role[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam role must implement access_control controls for public_access_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.role",
      "params": {
        "check_type": "access_control",
        "what_to_check": "public_access_restricted"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "1.12",
      "title": "Ensure API Keys Only Exist for Active Services",
      "function_names": [
        "gcp_iam_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460038",
    "is_primary": true
  },
  {
    "rule_id": "gcp.iam.api_key.access_control.access_restricted",
    "assertion_id": "iam.api_key.access_control.access_restricted",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.api_key",
    "adapter": "gcp.iam.api_key",
    "adapter_evidence_type": "gcp.iam.api_key[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam api_key must implement access_control controls for access_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.api_key",
      "params": {
        "check_type": "access_control",
        "what_to_check": "access_restricted"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "1.13",
      "title": "Ensure API Keys Are Restricted To Use by Only Specified Hosts and Apps",
      "function_names": [
        "gcp_iam_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460044",
    "is_primary": true
  },
  {
    "rule_id": "gcp.iam.api_key.access_control.access_restricted",
    "assertion_id": "iam.api_key.access_control.access_restricted",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.api_key",
    "adapter": "gcp.iam.api_key",
    "adapter_evidence_type": "gcp.iam.api_key[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam api_key must implement access_control controls for access_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.api_key",
      "params": {
        "check_type": "access_control",
        "what_to_check": "access_restricted"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "1.14",
      "title": "Ensure API Keys Are Restricted to Only APIs That Application Needs Access",
      "function_names": [
        "gcp_iam_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460052",
    "is_primary": true
  },
  {
    "rule_id": "gcp.iam.api_key.security.security_compliance",
    "assertion_id": "iam.api_key.security.security_compliance",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.api_key",
    "adapter": "gcp.iam.api_key",
    "adapter_evidence_type": "gcp.iam.api_key[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam api_key must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.api_key",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "1.15",
      "title": "Ensure API Keys Are Rotated Every 90 Days",
      "function_names": [
        "gcp_iam_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460061",
    "is_primary": true
  },
  {
    "rule_id": "gcp.iam.organization.security.security_compliance",
    "assertion_id": "iam.organization.security.security_compliance",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.organization",
    "adapter": "gcp.iam.organization",
    "adapter_evidence_type": "gcp.iam.organization[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam organization must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.organization",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "1.16",
      "title": "Ensure Essential Contacts is Configured for Organization",
      "function_names": [
        "gcp_iam_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460066",
    "is_primary": true
  },
  {
    "rule_id": "gcp.iam.policy.security.security_compliance",
    "assertion_id": "iam.policy.security.security_compliance",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.policy",
    "adapter": "gcp.iam.policy",
    "adapter_evidence_type": "gcp.iam.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam policy must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.policy",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "1.17",
      "title": "Ensure Secrets are Not Stored in Cloud Functions Environment Variables by Using Secret Manager",
      "function_names": [
        "gcp_iam_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460074",
    "is_primary": true
  },
  {
    "rule_id": "gcp.logging.logging.logging.audit_logging_configured",
    "assertion_id": "logging.logging.logging.audit_logging_configured",
    "provider": "gcp",
    "service": "logging",
    "resource_type": "gcp.logging.logging",
    "adapter": "gcp.logging.logging",
    "adapter_evidence_type": "gcp.logging.logging[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP logging logging must implement logging controls for audit_logging_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.logging",
      "params": {
        "check_type": "logging",
        "what_to_check": "audit_logging_configured"
      },
      "function_name": "gcp_iam_user_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "2.1",
      "title": "Ensure That Cloud Audit Logging Is Configured Properly",
      "function_names": [
        "gcp_iam_user_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460080",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "2.5"
  },
  {
    "rule_id": "gcp.logging.logging.security.sinks_configured",
    "assertion_id": "logging.logging.security.sinks_configured",
    "provider": "gcp",
    "service": "logging",
    "resource_type": "gcp.logging.logging",
    "adapter": "gcp.logging.logging",
    "adapter_evidence_type": "gcp.logging.logging[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP logging logging must implement security controls for sinks_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.logging",
      "params": {
        "check_type": "security",
        "what_to_check": "sinks_configured"
      },
      "function_name": "gcp_logging_enabled_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "2.2",
      "title": "Ensure That Sinks Are Configured for All Log Entries",
      "function_names": [
        "gcp_logging_enabled_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460086",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "2.2"
  },
  {
    "rule_id": "gcp.storage.bucket.backup.retention_policies_configured",
    "assertion_id": "storage.bucket.backup.retention_policies_configured",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP storage bucket must implement backup controls for retention_policies_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket",
      "params": {
        "check_type": "backup",
        "what_to_check": "retention_policies_configured"
      },
      "function_name": "gcp_storage_bucket_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "2.3",
      "title": "Ensure That Retention Policies on Cloud Storage Buckets Used for Exporting Logs Are Configured Using Bucket Lock",
      "function_names": [
        "gcp_storage_bucket_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460091",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "2.3"
  },
  {
    "rule_id": "gcp.logging.logging.privilege.metric_filters_configured",
    "assertion_id": "logging.logging.privilege.metric_filters_configured",
    "provider": "gcp",
    "service": "logging",
    "resource_type": "gcp.logging.logging",
    "adapter": "gcp.logging.logging",
    "adapter_evidence_type": "gcp.logging.logging[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP logging logging must implement privilege controls for metric_filters_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.logging",
      "params": {
        "check_type": "privilege",
        "what_to_check": "metric_filters_configured"
      },
      "function_name": "gcp_logging_enabled_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "2.4",
      "title": "Ensure Log Metric Filter and Alerts Exist for Project Ownership Assignments/Changes",
      "function_names": [
        "gcp_logging_enabled_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460099",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "2.4"
  },
  {
    "rule_id": "gcp.logging.logging.logging.audit_logging_configured",
    "assertion_id": "logging.logging.logging.audit_logging_configured",
    "provider": "gcp",
    "service": "logging",
    "resource_type": "gcp.logging.logging",
    "adapter": "gcp.logging.logging",
    "adapter_evidence_type": "gcp.logging.logging[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP logging logging must implement logging controls for audit_logging_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.logging",
      "params": {
        "check_type": "logging",
        "what_to_check": "audit_logging_configured"
      },
      "function_name": "gcp_iam_user_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "2.5",
      "title": "Ensure That the Log Metric Filter and Alerts Exist for Audit Configuration Changes",
      "function_names": [
        "gcp_iam_user_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460107",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "2.5"
  },
  {
    "rule_id": "gcp.logging.logging.logging.metric_filters_configured",
    "assertion_id": "logging.logging.logging.metric_filters_configured",
    "provider": "gcp",
    "service": "logging",
    "resource_type": "gcp.logging.logging",
    "adapter": "gcp.logging.logging",
    "adapter_evidence_type": "gcp.logging.logging[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP logging logging must implement logging controls for metric_filters_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.logging",
      "params": {
        "check_type": "logging",
        "what_to_check": "metric_filters_configured"
      },
      "function_name": "gcp_compute_network_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "2.6",
      "title": "Ensure That the Log Metric Filter and Alerts Exist for Custom Role Changes",
      "function_names": [
        "gcp_iam_user_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460113",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "2.9"
  },
  {
    "rule_id": "gcp.logging.logging.logging.metric_filters_configured",
    "assertion_id": "logging.logging.logging.metric_filters_configured",
    "provider": "gcp",
    "service": "logging",
    "resource_type": "gcp.logging.logging",
    "adapter": "gcp.logging.logging",
    "adapter_evidence_type": "gcp.logging.logging[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP logging logging must implement logging controls for metric_filters_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.logging",
      "params": {
        "check_type": "logging",
        "what_to_check": "metric_filters_configured"
      },
      "function_name": "gcp_compute_network_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "2.7",
      "title": "Ensure That the Log Metric Filter and Alerts Exist for VPC Network Firewall Rule Changes",
      "function_names": [
        "gcp_compute_network_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460118",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "2.9"
  },
  {
    "rule_id": "gcp.logging.logging.logging.metric_filters_configured",
    "assertion_id": "logging.logging.logging.metric_filters_configured",
    "provider": "gcp",
    "service": "logging",
    "resource_type": "gcp.logging.logging",
    "adapter": "gcp.logging.logging",
    "adapter_evidence_type": "gcp.logging.logging[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP logging logging must implement logging controls for metric_filters_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.logging",
      "params": {
        "check_type": "logging",
        "what_to_check": "metric_filters_configured"
      },
      "function_name": "gcp_compute_network_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "2.8",
      "title": "Ensure That the Log Metric Filter and Alerts Exist for VPC Network Route Changes",
      "function_names": [
        "gcp_compute_network_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460123",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "2.9"
  },
  {
    "rule_id": "gcp.logging.logging.logging.metric_filters_configured",
    "assertion_id": "logging.logging.logging.metric_filters_configured",
    "provider": "gcp",
    "service": "logging",
    "resource_type": "gcp.logging.logging",
    "adapter": "gcp.logging.logging",
    "adapter_evidence_type": "gcp.logging.logging[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP logging logging must implement logging controls for metric_filters_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.logging",
      "params": {
        "check_type": "logging",
        "what_to_check": "metric_filters_configured"
      },
      "function_name": "gcp_compute_network_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "2.9",
      "title": "Ensure That the Log Metric Filter and Alerts Exist for VPC Network Changes",
      "function_names": [
        "gcp_compute_network_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460128",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "2.9"
  },
  {
    "rule_id": "gcp.storage.bucket.logging.logging_enabled",
    "assertion_id": "storage.bucket.logging.logging_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP storage bucket must implement logging controls for logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket",
      "params": {
        "check_type": "logging",
        "what_to_check": "logging_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "2.10",
      "title": "Ensure That the Log Metric Filter and Alerts Exist for Cloud Storage IAM Permission Changes",
      "function_names": [
        "gcp_iam_user_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460133",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.logging.logging_enabled",
    "assertion_id": "compute.instance.logging.logging_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement logging controls for logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "logging",
        "what_to_check": "logging_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "2.11",
      "title": "Ensure That the Log Metric Filter and Alerts Exist for SQL Instance Configuration Changes",
      "function_names": [
        "gcp_logging_enabled_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460142",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.logging.logging_enabled",
    "assertion_id": "compute.instance.logging.logging_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement logging controls for logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "logging",
        "what_to_check": "logging_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "2.12",
      "title": "Ensure That Cloud DNS Logging Is Enabled for All VPC Networks",
      "function_names": [
        "gcp_compute_network_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460147",
    "is_primary": true
  },
  {
    "rule_id": "gcp.sql.database.security.security_compliance",
    "assertion_id": "sql.database.security.security_compliance",
    "provider": "gcp",
    "service": "sql",
    "resource_type": "gcp.sql.database",
    "adapter": "gcp.sql.database",
    "adapter_evidence_type": "gcp.sql.database[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP sql database must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.database",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "2.13",
      "title": "Ensure Cloud Asset Inventory Is Enabled",
      "function_names": [
        "gcp_compute_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460156",
    "is_primary": true
  },
  {
    "rule_id": "gcp.logging.logging.logging.logging_enabled",
    "assertion_id": "logging.logging.logging.logging_enabled",
    "provider": "gcp",
    "service": "logging",
    "resource_type": "gcp.logging.logging",
    "adapter": "gcp.logging.logging",
    "adapter_evidence_type": "gcp.logging.logging[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP logging logging must implement logging controls for logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.logging",
      "params": {
        "check_type": "logging",
        "what_to_check": "logging_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "2.15",
      "title": "Ensure 'Access Approval' is 'Enabled'",
      "function_names": [
        "gcp_iam_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460161",
    "is_primary": true
  },
  {
    "rule_id": "gcp.logging.logging.logging.logging_enabled",
    "assertion_id": "logging.logging.logging.logging_enabled",
    "provider": "gcp",
    "service": "logging",
    "resource_type": "gcp.logging.logging",
    "adapter": "gcp.logging.logging",
    "adapter_evidence_type": "gcp.logging.logging[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP logging logging must implement logging controls for logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.logging",
      "params": {
        "check_type": "logging",
        "what_to_check": "logging_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "2.16",
      "title": "Ensure Logging is enabled for HTTP(S) Load Balancer",
      "function_names": [
        "gcp_compute_network_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460166",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.network.security.default_network_removed",
    "assertion_id": "compute.network.security.default_network_removed",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.network",
    "adapter": "gcp.compute.network",
    "adapter_evidence_type": "gcp.compute.network[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute network must implement security controls for default_network_removed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.network",
      "params": {
        "check_type": "security",
        "what_to_check": "default_network_removed"
      },
      "function_name": "gcp_compute_network_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "3.1",
      "title": "Ensure That the Default Network Does Not Exist in a Project",
      "function_names": [
        "gcp_compute_network_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460171",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "3.1"
  },
  {
    "rule_id": "gcp.compute.network.security.legacy_networks_removed",
    "assertion_id": "compute.network.security.legacy_networks_removed",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.network",
    "adapter": "gcp.compute.network",
    "adapter_evidence_type": "gcp.compute.network[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute network must implement security controls for legacy_networks_removed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.network",
      "params": {
        "check_type": "security",
        "what_to_check": "legacy_networks_removed"
      },
      "function_name": "gcp_compute_network_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "3.2",
      "title": "Ensure Legacy Networks Do Not Exist for Older Projects",
      "function_names": [
        "gcp_compute_network_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460179",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "3.2"
  },
  {
    "rule_id": "gcp.dns.dns.privilege.dnssec_enabled",
    "assertion_id": "dns.dns.privilege.dnssec_enabled",
    "provider": "gcp",
    "service": "dns",
    "resource_type": "gcp.dns.dns",
    "adapter": "gcp.dns.dns",
    "adapter_evidence_type": "gcp.dns.dns[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP dns dns must implement privilege controls for dnssec_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dns.dns",
      "params": {
        "check_type": "privilege",
        "what_to_check": "dnssec_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "3.3",
      "title": "Ensure That DNSSEC Is Enabled for Cloud DNS",
      "function_names": [
        "gcp_dns_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460185",
    "is_primary": true
  },
  {
    "rule_id": "gcp.dns.dns.dnssec.dnssec_enabled",
    "assertion_id": "dns.dns.dnssec.dnssec_enabled",
    "provider": "gcp",
    "service": "dns",
    "resource_type": "gcp.dns.dns",
    "adapter": "gcp.dns.dns",
    "adapter_evidence_type": "gcp.dns.dns[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP dns dns must implement dnssec controls for dnssec_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dns.dns",
      "params": {
        "check_type": "dnssec",
        "what_to_check": "dnssec_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "3.4",
      "title": "Ensure That RSASHA1 Is Not Used for the Key-Signing Key in Cloud DNS DNSSEC",
      "function_names": [
        "gcp_dns_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460190",
    "is_primary": true
  },
  {
    "rule_id": "gcp.dns.dns.dnssec.dnssec_enabled",
    "assertion_id": "dns.dns.dnssec.dnssec_enabled",
    "provider": "gcp",
    "service": "dns",
    "resource_type": "gcp.dns.dns",
    "adapter": "gcp.dns.dns",
    "adapter_evidence_type": "gcp.dns.dns[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP dns dns must implement dnssec controls for dnssec_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dns.dns",
      "params": {
        "check_type": "dnssec",
        "what_to_check": "dnssec_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "3.5",
      "title": "Ensure That RSASHA1 Is Not Used for the Zone-Signing Key in Cloud DNS DNSSEC",
      "function_names": [
        "gcp_dns_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460195",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.firewall.ssh_access_restricted",
    "assertion_id": "compute.instance.firewall.ssh_access_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement firewall controls for ssh_access_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "firewall",
        "what_to_check": "ssh_access_restricted"
      },
      "function_name": "gcp_compute_network_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "3.6",
      "title": "Ensure That SSH Access Is Restricted From the Internet",
      "function_names": [
        "gcp_compute_network_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460203",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "3.6"
  },
  {
    "rule_id": "gcp.compute.instance.firewall.rdp_access_restricted",
    "assertion_id": "compute.instance.firewall.rdp_access_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement firewall controls for rdp_access_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "firewall",
        "what_to_check": "rdp_access_restricted"
      },
      "function_name": "gcp_compute_network_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "3.7",
      "title": "Ensure That RDP Access Is Restricted From the Internet",
      "function_names": [
        "gcp_compute_network_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460208",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "3.7"
  },
  {
    "rule_id": "gcp.logging.logging.logging.logging_enabled",
    "assertion_id": "logging.logging.logging.logging_enabled",
    "provider": "gcp",
    "service": "logging",
    "resource_type": "gcp.logging.logging",
    "adapter": "gcp.logging.logging",
    "adapter_evidence_type": "gcp.logging.logging[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP logging logging must implement logging controls for logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.logging",
      "params": {
        "check_type": "logging",
        "what_to_check": "logging_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "3.8",
      "title": "Ensure that VPC Flow Logs is Enabled for Every Subnet in a VPC Network",
      "function_names": [
        "gcp_compute_network_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460216",
    "is_primary": true
  },
  {
    "rule_id": "gcp.security.general.access_control.ssl_enabled",
    "assertion_id": "security.general.access_control.ssl_enabled",
    "provider": "gcp",
    "service": "security",
    "resource_type": "gcp.security.general",
    "adapter": "gcp.security.general",
    "adapter_evidence_type": "gcp.security.general[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP security general must implement access_control controls for ssl_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.security.general",
      "params": {
        "check_type": "access_control",
        "what_to_check": "ssl_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "3.9",
      "title": "Ensure No HTTPS or SSL Proxy Load Balancers Permit SSL Policies With Weak Cipher Suites",
      "function_names": [
        "gcp_compute_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460223",
    "is_primary": true
  },
  {
    "rule_id": "gcp.iam.service_account.privilege.security_policies_enforced",
    "assertion_id": "iam.service_account.privilege.security_policies_enforced",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.service_account",
    "adapter": "gcp.iam.service_account",
    "adapter_evidence_type": "gcp.iam.service_account[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam service_account must implement privilege controls for security_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account",
      "params": {
        "check_type": "privilege",
        "what_to_check": "security_policies_enforced"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.1",
      "title": "Ensure That Instances Are Not Configured To Use the Default Service Account",
      "function_names": [
        "gcp_compute_instance_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460229",
    "is_primary": true
  },
  {
    "rule_id": "gcp.iam.service_account.security.security_policies_enforced",
    "assertion_id": "iam.service_account.security.security_policies_enforced",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.service_account",
    "adapter": "gcp.iam.service_account",
    "adapter_evidence_type": "gcp.iam.service_account[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam service_account must implement security controls for security_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account",
      "params": {
        "check_type": "security",
        "what_to_check": "security_policies_enforced"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.2",
      "title": "Ensure That Instances Are Not Configured To Use the Default Service Account With Full Access to All Cloud APIs",
      "function_names": [
        "gcp_compute_instance_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460234",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.firewall.project_wide_ssh_blocked",
    "assertion_id": "compute.instance.firewall.project_wide_ssh_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement firewall controls for project_wide_ssh_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "firewall",
        "what_to_check": "project_wide_ssh_blocked"
      },
      "function_name": "gcp_compute_instance_project_ssh_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "4.3",
      "title": "Ensure \u201cBlock Project-Wide SSH Keys\u201d Is Enabled for VM Instances",
      "function_names": [
        "gcp_compute_instance_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460243",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "4.3"
  },
  {
    "rule_id": "gcp.iam.user.firewall.firewall_rules",
    "assertion_id": "iam.user.firewall.firewall_rules",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.user",
    "adapter": "gcp.iam.user",
    "adapter_evidence_type": "gcp.iam.user[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam user must implement firewall controls for firewall_rules to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.user",
      "params": {
        "check_type": "firewall",
        "what_to_check": "firewall_rules"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.4",
      "title": "Ensure Oslogin Is Enabled for a Project",
      "function_names": [
        "gcp_compute_instance_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460249",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.security.serial_port_disabled",
    "assertion_id": "compute.instance.security.serial_port_disabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement security controls for serial_port_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "security",
        "what_to_check": "serial_port_disabled"
      },
      "function_name": "gcp_compute_instance_serial_port_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "4.5",
      "title": "Ensure \u2018Enable Connecting to Serial Ports\u2019 Is Not Enabled for VM Instance",
      "function_names": [
        "gcp_compute_instance_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460259",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "4.5"
  },
  {
    "rule_id": "gcp.compute.instance.security.ip_forwarding_disabled",
    "assertion_id": "compute.instance.security.ip_forwarding_disabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement security controls for ip_forwarding_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "security",
        "what_to_check": "ip_forwarding_disabled"
      },
      "function_name": "gcp_compute_instance_ip_forwarding_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "4.6",
      "title": "Ensure That IP Forwarding Is Not Enabled on Instances",
      "function_names": [
        "gcp_compute_instance_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460265",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "4.6"
  },
  {
    "rule_id": "gcp.compute.instance.encryption.customer_managed_encryption_enabled",
    "assertion_id": "compute.instance.encryption.customer_managed_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement encryption controls for customer_managed_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "encryption",
        "what_to_check": "customer_managed_encryption_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.7",
      "title": "Ensure VM Disks for Critical VMs Are Encrypted With Customer-Supplied Encryption Keys (CSEK)",
      "function_names": [
        "gcp_compute_disk_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460270",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.security.shielded_vm_enabled",
    "assertion_id": "compute.instance.security.shielded_vm_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement security controls for shielded_vm_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "security",
        "what_to_check": "shielded_vm_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.8",
      "title": "Ensure Compute Instances Are Launched With Shielded VM Enabled",
      "function_names": [
        "gcp_compute_instance_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460275",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.access_control.public_ip_restricted",
    "assertion_id": "compute.instance.access_control.public_ip_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement access_control controls for public_ip_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "access_control",
        "what_to_check": "public_ip_restricted"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.9",
      "title": "Ensure That Compute Instances Do Not Have Public IP Addresses",
      "function_names": [
        "gcp_compute_instance_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460280",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.encryption.customer_managed_encryption_enabled",
    "assertion_id": "compute.instance.encryption.customer_managed_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement encryption controls for customer_managed_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "encryption",
        "what_to_check": "customer_managed_encryption_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.11",
      "title": "Ensure That Compute Instances Have Confidential Computing Enabled",
      "function_names": [
        "gcp_compute_instance_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460288",
    "is_primary": true
  },
  {
    "rule_id": "gcp.security.general.security.security_compliance",
    "assertion_id": "security.general.security.security_compliance",
    "provider": "gcp",
    "service": "security",
    "resource_type": "gcp.security.general",
    "adapter": "gcp.security.general",
    "adapter_evidence_type": "gcp.security.general[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP security general must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.security.general",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.12",
      "title": "Ensure the Latest Operating System Updates Are Installed On Your Virtual Machines in All Projects",
      "function_names": [
        "gcp_compute_instance_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460297",
    "is_primary": true
  },
  {
    "rule_id": "gcp.storage.bucket.access_control.anonymous_access_blocked",
    "assertion_id": "storage.bucket.access_control.anonymous_access_blocked",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP storage bucket must implement access_control controls for anonymous_access_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket",
      "params": {
        "check_type": "access_control",
        "what_to_check": "anonymous_access_blocked"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.1",
      "title": "Ensure That Cloud Storage Bucket Is Not Anonymously or Publicly Accessible",
      "function_names": [
        "gcp_iam_user_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460305",
    "is_primary": true
  },
  {
    "rule_id": "gcp.storage.bucket.security.uniform_bucket_level_access_enabled",
    "assertion_id": "storage.bucket.security.uniform_bucket_level_access_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP storage bucket must implement security controls for uniform_bucket_level_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket",
      "params": {
        "check_type": "security",
        "what_to_check": "uniform_bucket_level_access_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.2",
      "title": "Ensure That Cloud Storage Buckets Have Uniform Bucket- Level Access Enabled",
      "function_names": [
        "gcp_storage_bucket_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460316",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.security.security_compliance",
    "assertion_id": "compute.instance.security.security_compliance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.1.1",
      "title": "Ensure That a MySQL Instance Does Not Allow Anyone To Connect With Administrative Privileges",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460322",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.security.security_compliance",
    "assertion_id": "compute.instance.security.security_compliance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.1.2",
      "title": "Ensure \u2018Skip_show_database\u2019 Database Flag for Cloud SQL MySQL Instance Is Set to \u2018On\u2019",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460327",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.security.security_compliance",
    "assertion_id": "compute.instance.security.security_compliance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.1.3",
      "title": "Ensure That the \u2018Local_infile\u2019 Database Flag for a Cloud SQL MySQL Instance Is Set to \u2018Off\u2019",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460333",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.logging.logging_enabled",
    "assertion_id": "compute.instance.logging.logging_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement logging controls for logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "logging",
        "what_to_check": "logging_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.2.1",
      "title": "Ensure \u2018Log_error_verbosity\u2019 Database Flag for Cloud SQL PostgreSQL Instance Is Set to \u2018DEFAULT\u2019 or Stricter",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460342",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.security.security_compliance",
    "assertion_id": "compute.instance.security.security_compliance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.2.2",
      "title": "Ensure That the \u2018Log_connections\u2019 Database Flag for Cloud SQL PostgreSQL Instance Is Set to \u2018On\u2019",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460348",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.security.security_compliance",
    "assertion_id": "compute.instance.security.security_compliance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.2.3",
      "title": "Ensure That the \u2018Log_disconnections\u2019 Database Flag for Cloud SQL PostgreSQL Instance Is Set to \u2018On\u2019",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460384",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.logging.logging_enabled",
    "assertion_id": "compute.instance.logging.logging_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement logging controls for logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "logging",
        "what_to_check": "logging_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.2.4",
      "title": "Ensure \u2018Log_statement\u2019 Database Flag for Cloud SQL PostgreSQL Instance Is Set Appropriately",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460403",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.logging.logging_enabled",
    "assertion_id": "compute.instance.logging.logging_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement logging controls for logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "logging",
        "what_to_check": "logging_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.2.5",
      "title": "Ensure that the \u2018Log_min_messages\u2019 Flag for a Cloud SQL PostgreSQL Instance is set at minimum to 'Warning'",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460423",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.security.security_compliance",
    "assertion_id": "compute.instance.security.security_compliance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.2.6",
      "title": "Ensure \u2018Log_min_error_statement\u2019 Database Flag for Cloud SQL PostgreSQL Instance Is Set to \u2018Error\u2019 or Stricter",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460433",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.security.security_compliance",
    "assertion_id": "compute.instance.security.security_compliance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.2.7",
      "title": "Ensure That the \u2018Log_min_duration_statement\u2019 Database Flag for Cloud SQL PostgreSQL Instance Is Set to '-1' (Disabled)",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460450",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.logging.logging_enabled",
    "assertion_id": "compute.instance.logging.logging_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement logging controls for logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "logging",
        "what_to_check": "logging_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.2.8",
      "title": "Ensure That 'cloudsql.enable_pgaudit' Database Flag for each Cloud Sql Postgresql Instance Is Set to 'on' For Centralized Logging",
      "function_names": [
        "gcp_iam_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460461",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.security.security_compliance",
    "assertion_id": "compute.instance.security.security_compliance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.3.1",
      "title": "Ensure 'external scripts enabled' Database Flag for Cloud SQL SQL Server Instance Is Set to 'off'",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460470",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.privilege.no_admin_privileges",
    "assertion_id": "compute.instance.privilege.no_admin_privileges",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement privilege controls for no_admin_privileges to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "privilege",
        "what_to_check": "no_admin_privileges"
      },
      "function_name": "gcp_cloud_sql_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "6.3.2",
      "title": "Ensure 'cross db ownership chaining' Database Flag for Cloud SQL SQL Server Instance Is Set to 'off'",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460482",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.3.2"
  },
  {
    "rule_id": "gcp.compute.instance.security.security_compliance",
    "assertion_id": "compute.instance.security.security_compliance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.3.3",
      "title": "Ensure 'user Connections' Database Flag for Cloud SQL SQL Server Instance Is Set to a Non-limiting Value",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460729",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.security.security_compliance",
    "assertion_id": "compute.instance.security.security_compliance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.3.4",
      "title": "Ensure 'user options' Database Flag for Cloud SQL SQL Server Instance Is Not Configured",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460752",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.security.security_compliance",
    "assertion_id": "compute.instance.security.security_compliance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.3.5",
      "title": "Ensure 'remote access' Database Flag for Cloud SQL SQL Server Instance Is Set to 'off'",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460773",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.security.security_compliance",
    "assertion_id": "compute.instance.security.security_compliance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.3.6",
      "title": "Ensure '3625 (trace flag)' Database Flag for all Cloud SQL SQL Server Instances Is Set to 'on'",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460784",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.security.security_compliance",
    "assertion_id": "compute.instance.security.security_compliance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.3.7",
      "title": "Ensure 'contained database authentication' Database Flag for Cloud SQL SQL Server Instance Is Set to 'off'",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460790",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.ssl.ssl_enabled",
    "assertion_id": "compute.instance.ssl.ssl_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement ssl controls for ssl_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "ssl",
        "what_to_check": "ssl_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.4",
      "title": "Ensure That the Cloud SQL Database Instance Requires All Incoming Connections To Use SSL",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460797",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.access_control.public_ip_restricted",
    "assertion_id": "compute.instance.access_control.public_ip_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement access_control controls for public_ip_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "access_control",
        "what_to_check": "public_ip_restricted"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.5",
      "title": "Ensure That Cloud SQL Database Instances Do Not Implicitly Whitelist All Public IP Addresses",
      "function_names": [
        "gcp_network_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460806",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.access_control.public_ip_restricted",
    "assertion_id": "compute.instance.access_control.public_ip_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement access_control controls for public_ip_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "access_control",
        "what_to_check": "public_ip_restricted"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.6",
      "title": "Ensure That Cloud SQL Database Instances Do Not Have Public IPs",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460816",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.backup.backup_enabled",
    "assertion_id": "compute.instance.backup.backup_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement backup controls for backup_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "backup",
        "what_to_check": "backup_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "6.7",
      "title": "Ensure That Cloud SQL Database Instances Are Configured With Automated Backups",
      "function_names": [
        "gcp_cloud_sql_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460823",
    "is_primary": true
  },
  {
    "rule_id": "gcp.bigquery.dataset.access_control.anonymous_access_blocked",
    "assertion_id": "bigquery.dataset.access_control.anonymous_access_blocked",
    "provider": "gcp",
    "service": "bigquery",
    "resource_type": "gcp.bigquery.dataset",
    "adapter": "gcp.bigquery.dataset",
    "adapter_evidence_type": "gcp.bigquery.dataset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP bigquery dataset must implement access_control controls for anonymous_access_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.dataset",
      "params": {
        "check_type": "access_control",
        "what_to_check": "anonymous_access_blocked"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "7.1",
      "title": "Ensure That BigQuery Datasets Are Not Anonymously or Publicly Accessible",
      "function_names": [
        "gcp_bigquery_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460830",
    "is_primary": true
  },
  {
    "rule_id": "gcp.kms.key.key_management.encryption_enabled",
    "assertion_id": "kms.key.key_management.encryption_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.key",
    "adapter": "gcp.kms.key",
    "adapter_evidence_type": "gcp.kms.key[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP kms key must implement key_management controls for encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key",
      "params": {
        "check_type": "key_management",
        "what_to_check": "encryption_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "7.2",
      "title": "Ensure That All BigQuery Tables Are Encrypted With Customer-Managed Encryption Key (CMEK)",
      "function_names": [
        "gcp_kms_encryption_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460838",
    "is_primary": true
  },
  {
    "rule_id": "gcp.kms.key.key_management.encryption_enabled",
    "assertion_id": "kms.key.key_management.encryption_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.key",
    "adapter": "gcp.kms.key",
    "adapter_evidence_type": "gcp.kms.key[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP kms key must implement key_management controls for encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key",
      "params": {
        "check_type": "key_management",
        "what_to_check": "encryption_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "7.3",
      "title": "Ensure That a Default Customer-Managed Encryption Key (CMEK) Is Specified for All BigQuery Data Sets",
      "function_names": [
        "gcp_kms_encryption_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460846",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.encryption.customer_managed_encryption_enabled",
    "assertion_id": "compute.instance.encryption.customer_managed_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement encryption controls for customer_managed_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "encryption",
        "what_to_check": "customer_managed_encryption_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "8.1",
      "title": "Ensure that Dataproc Cluster is encrypted using Customer- Managed Encryption Key",
      "function_names": [
        "gcp_kms_encryption_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460851",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.privilege.cluster_admin_restricted",
    "assertion_id": "gke.cluster.privilege.cluster_admin_restricted",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement privilege controls for cluster_admin_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "privilege",
        "what_to_check": "cluster_admin_restricted"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.1.1",
      "title": "Ensure that the cluster-admin role is only used where required",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460857",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.security.security_compliance",
    "assertion_id": "gke.cluster.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.1.3",
      "title": "Minimize wildcard use in Roles and ClusterRoles",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460866",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.access_control.public_access_restricted",
    "assertion_id": "gke.cluster.access_control.public_access_restricted",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement access_control controls for public_access_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "access_control",
        "what_to_check": "public_access_restricted"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.1.8",
      "title": "Avoid bindings to system:anonymous",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460872",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.access_control.public_access_restricted",
    "assertion_id": "gke.cluster.access_control.public_access_restricted",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement access_control controls for public_access_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "access_control",
        "what_to_check": "public_access_restricted"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.1.9",
      "title": "Avoid non-default bindings to system:unauthenticated",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460883",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.access_control.public_access_restricted",
    "assertion_id": "gke.cluster.access_control.public_access_restricted",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement access_control controls for public_access_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "access_control",
        "what_to_check": "public_access_restricted"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.1.10",
      "title": "Avoid non-default bindings to system:authenticated",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460889",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.security.pod_security_enforced",
    "assertion_id": "gke.cluster.security.pod_security_enforced",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement security controls for pod_security_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "security",
        "what_to_check": "pod_security_enforced"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.2.1",
      "title": "Ensure that the cluster enforces Pod Security Standard Baseline profile or stricter for all namespaces.",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460897",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.security.network_policies_enabled",
    "assertion_id": "gke.cluster.security.network_policies_enabled",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement security controls for network_policies_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "security",
        "what_to_check": "network_policies_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.3.1",
      "title": "Ensure that all Namespaces have Network Policies defined",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460903",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.security.security_compliance",
    "assertion_id": "gke.cluster.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.6.1",
      "title": "Create administrative boundaries between resources using namespaces",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460911",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.pod.security.seccomp_profile_enabled",
    "assertion_id": "gke.pod.security.seccomp_profile_enabled",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.pod",
    "adapter": "gcp.gke.pod",
    "adapter_evidence_type": "gcp.gke.pod[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke pod must implement security controls for seccomp_profile_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.pod",
      "params": {
        "check_type": "security",
        "what_to_check": "seccomp_profile_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.6.2",
      "title": "Ensure that the seccomp profile is set to RuntimeDefault in the pod definitions",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460917",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.security.security_compliance",
    "assertion_id": "gke.cluster.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.6.4",
      "title": "The default namespace should not be used",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460922",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.pod.vulnerability.vulnerability_scanning_enabled",
    "assertion_id": "gke.pod.vulnerability.vulnerability_scanning_enabled",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.pod",
    "adapter": "gcp.gke.pod",
    "adapter_evidence_type": "gcp.gke.pod[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke pod must implement vulnerability controls for vulnerability_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.pod",
      "params": {
        "check_type": "vulnerability",
        "what_to_check": "vulnerability_scanning_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.1.1",
      "title": "Ensure Image Vulnerability Scanning is enabled",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460928",
    "is_primary": true
  },
  {
    "rule_id": "gcp.iam.service_account.security.project_level_roles_restricted",
    "assertion_id": "iam.service_account.security.project_level_roles_restricted",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.service_account",
    "adapter": "gcp.iam.service_account",
    "adapter_evidence_type": "gcp.iam.service_account[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam service_account must implement security controls for project_level_roles_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account",
      "params": {
        "check_type": "security",
        "what_to_check": "project_level_roles_restricted"
      },
      "function_name": "gcp_iam_service_account_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "5.1.2",
      "title": "Minimize user access to Container Image repositories",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460933",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "1.6"
  },
  {
    "rule_id": "gcp.iam.service_account.security.security_policies_enforced",
    "assertion_id": "iam.service_account.security.security_policies_enforced",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.service_account",
    "adapter": "gcp.iam.service_account",
    "adapter_evidence_type": "gcp.iam.service_account[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam service_account must implement security controls for security_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account",
      "params": {
        "check_type": "security",
        "what_to_check": "security_policies_enforced"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.1.3",
      "title": "Minimize cluster access to read-only for Container Image repositories",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460938",
    "is_primary": true
  },
  {
    "rule_id": "gcp.security.general.vulnerability.vulnerability_scanning",
    "assertion_id": "security.general.vulnerability.vulnerability_scanning",
    "provider": "gcp",
    "service": "security",
    "resource_type": "gcp.security.general",
    "adapter": "gcp.security.general",
    "adapter_evidence_type": "gcp.security.general[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP security general must implement vulnerability controls for vulnerability_scanning to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.security.general",
      "params": {
        "check_type": "vulnerability",
        "what_to_check": "vulnerability_scanning"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.1.4",
      "title": "Ensure only trusted container images are used",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460954",
    "is_primary": true
  },
  {
    "rule_id": "gcp.iam.service_account.security.security_policies_enforced",
    "assertion_id": "iam.service_account.security.security_policies_enforced",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.service_account",
    "adapter": "gcp.iam.service_account",
    "adapter_evidence_type": "gcp.iam.service_account[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam service_account must implement security controls for security_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account",
      "params": {
        "check_type": "security",
        "what_to_check": "security_policies_enforced"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.2.1",
      "title": "Ensure GKE clusters are not running using the Compute Engine default service account",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460960",
    "is_primary": true
  },
  {
    "rule_id": "gcp.kms.key.encryption.encryption_enabled",
    "assertion_id": "kms.key.encryption.encryption_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.key",
    "adapter": "gcp.kms.key",
    "adapter_evidence_type": "gcp.kms.key[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP kms key must implement encryption controls for encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key",
      "params": {
        "check_type": "encryption",
        "what_to_check": "encryption_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.3.1",
      "title": "Ensure Kubernetes Secrets are encrypted using keys managed in Cloud KMS",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460966",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.node.security.security_compliance",
    "assertion_id": "gke.node.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.node",
    "adapter": "gcp.gke.node",
    "adapter_evidence_type": "gcp.gke.node[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke node must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.node",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.4.1",
      "title": "Enable VPC Flow Logs and Intranode Visibility",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460971",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.security.security_compliance",
    "assertion_id": "gke.cluster.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.4.2",
      "title": "Ensure Control Plane Authorized Networks is Enabled",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460977",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.access_control.private_endpoint_enabled",
    "assertion_id": "gke.cluster.access_control.private_endpoint_enabled",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement access_control controls for private_endpoint_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "access_control",
        "what_to_check": "private_endpoint_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.4.3",
      "title": "Ensure clusters are created with Private Endpoint Enabled and Public Access Disabled",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460982",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.access_control.private_nodes_enabled",
    "assertion_id": "gke.cluster.access_control.private_nodes_enabled",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement access_control controls for private_nodes_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "access_control",
        "what_to_check": "private_nodes_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.4.4",
      "title": "Ensure clusters are created with Private Nodes",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460991",
    "is_primary": true
  },
  {
    "rule_id": "gcp.security.general.ssl.ssl_enabled",
    "assertion_id": "security.general.ssl.ssl_enabled",
    "provider": "gcp",
    "service": "security",
    "resource_type": "gcp.security.general",
    "adapter": "gcp.security.general",
    "adapter_evidence_type": "gcp.security.general[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP security general must implement ssl controls for ssl_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.security.general",
      "params": {
        "check_type": "ssl",
        "what_to_check": "ssl_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.4.5",
      "title": "Ensure use of Google-managed SSL Certificates",
      "function_names": [
        "gke_autopilot_workload_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.460999",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.disk.key_management.only_gcp_managed_keys",
    "assertion_id": "compute.disk.key_management.only_gcp_managed_keys",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.disk",
    "adapter": "gcp.compute.disk",
    "adapter_evidence_type": "gcp.compute.disk[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute disk must implement key_management controls for only_gcp_managed_keys to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk",
      "params": {
        "check_type": "key_management",
        "what_to_check": "only_gcp_managed_keys"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.6.1",
      "title": "Enable Customer-Managed Encryption Keys (CMEK) for GKE Persistent Disks (PD)",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461009",
    "is_primary": true
  },
  {
    "rule_id": "gcp.security.general.security.security_compliance",
    "assertion_id": "security.general.security.security_compliance",
    "provider": "gcp",
    "service": "security",
    "resource_type": "gcp.security.general",
    "adapter": "gcp.security.general",
    "adapter_evidence_type": "gcp.security.general[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP security general must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.security.general",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.7.1",
      "title": "Enable Security Posture",
      "function_names": [
        "gke_autopilot_compliance_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461014",
    "is_primary": true
  },
  {
    "rule_id": "gcp.security.general.security.security_compliance",
    "assertion_id": "security.general.security.security_compliance",
    "provider": "gcp",
    "service": "security",
    "resource_type": "gcp.security.general",
    "adapter": "gcp.security.general",
    "adapter_evidence_type": "gcp.security.general[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP security general must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.security.general",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "3.1.1",
      "title": "Ensure that the proxy kubeconfig file permissions are set to 644 or more restrictive",
      "function_names": [
        "gke_kubeconfig_file_permissions_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461023",
    "is_primary": true
  },
  {
    "rule_id": "gcp.security.general.privilege.no_admin_privileges",
    "assertion_id": "security.general.privilege.no_admin_privileges",
    "provider": "gcp",
    "service": "security",
    "resource_type": "gcp.security.general",
    "adapter": "gcp.security.general",
    "adapter_evidence_type": "gcp.security.general[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP security general must implement privilege controls for no_admin_privileges to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.security.general",
      "params": {
        "check_type": "privilege",
        "what_to_check": "no_admin_privileges"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "3.1.2",
      "title": "Ensure that the proxy kubeconfig file ownership is set to root:root",
      "function_names": [
        "gke_kubeconfig_file_ownership_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461029",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.node.security.security_compliance",
    "assertion_id": "gke.node.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.node",
    "adapter": "gcp.gke.node",
    "adapter_evidence_type": "gcp.gke.node[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke node must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.node",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "3.1.3",
      "title": "Ensure that the kubelet configuration file has permissions set to 644",
      "function_names": [
        "gke_kubelet_config_file_permissions_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461039",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.node.privilege.no_admin_privileges",
    "assertion_id": "gke.node.privilege.no_admin_privileges",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.node",
    "adapter": "gcp.gke.node",
    "adapter_evidence_type": "gcp.gke.node[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke node must implement privilege controls for no_admin_privileges to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.node",
      "params": {
        "check_type": "privilege",
        "what_to_check": "no_admin_privileges"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "3.1.4",
      "title": "Ensure that the kubelet configuration file ownership is set to root:root",
      "function_names": [
        "gke_kubelet_config_file_ownership_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461048",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.node.access_control.public_access_restricted",
    "assertion_id": "gke.node.access_control.public_access_restricted",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.node",
    "adapter": "gcp.gke.node",
    "adapter_evidence_type": "gcp.gke.node[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke node must implement access_control controls for public_access_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.node",
      "params": {
        "check_type": "access_control",
        "what_to_check": "public_access_restricted"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "3.2.1",
      "title": "Ensure that the Anonymous Auth is Not Enabled Draft",
      "function_names": [
        "gke_kubelet_service_enabled_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461054",
    "is_primary": true
  },
  {
    "rule_id": "gcp.security.general.security.security_compliance",
    "assertion_id": "security.general.security.security_compliance",
    "provider": "gcp",
    "service": "security",
    "resource_type": "gcp.security.general",
    "adapter": "gcp.security.general",
    "adapter_evidence_type": "gcp.security.general[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP security general must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.security.general",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "3.2.2",
      "title": "Ensure that the --authorization-mode argument is not set to AlwaysAllow",
      "function_names": [
        "gke_kubelet_service_enabled_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461060",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.node.ssl.ssl_enabled",
    "assertion_id": "gke.node.ssl.ssl_enabled",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.node",
    "adapter": "gcp.gke.node",
    "adapter_evidence_type": "gcp.gke.node[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke node must implement ssl controls for ssl_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.node",
      "params": {
        "check_type": "ssl",
        "what_to_check": "ssl_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "3.2.3",
      "title": "Ensure that a Client CA File is Configured",
      "function_names": [
        "gke_kubelet_config_file_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461068",
    "is_primary": true
  },
  {
    "rule_id": "gcp.security.general.security.ssl_enabled",
    "assertion_id": "security.general.security.ssl_enabled",
    "provider": "gcp",
    "service": "security",
    "resource_type": "gcp.security.general",
    "adapter": "gcp.security.general",
    "adapter_evidence_type": "gcp.security.general[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP security general must implement security controls for ssl_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.security.general",
      "params": {
        "check_type": "security",
        "what_to_check": "ssl_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "3.2.5",
      "title": "Ensure that the --streaming-connection-idle-timeout argument is not set to 0",
      "function_names": [
        "gke_kubelet_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461076",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.node.security.security_compliance",
    "assertion_id": "gke.node.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.node",
    "adapter": "gcp.gke.node",
    "adapter_evidence_type": "gcp.gke.node[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke node must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.node",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "3.2.6",
      "title": "Ensure that the --make-iptables-util-chains argument is set to true",
      "function_names": [
        "gke_kubelet_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461093",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.node.ssl.ssl_enabled",
    "assertion_id": "gke.node.ssl.ssl_enabled",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.node",
    "adapter": "gcp.gke.node",
    "adapter_evidence_type": "gcp.gke.node[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke node must implement ssl controls for ssl_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.node",
      "params": {
        "check_type": "ssl",
        "what_to_check": "ssl_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "3.2.9",
      "title": "Ensure that the RotateKubeletServerCertificate argument is set to true",
      "function_names": [
        "gke_kubelet_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461099",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.privilege.cluster_admin_restricted",
    "assertion_id": "gke.cluster.privilege.cluster_admin_restricted",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement privilege controls for cluster_admin_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "privilege",
        "what_to_check": "cluster_admin_restricted"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.1.1",
      "title": "Ensure that the cluster-admin role is only used where required",
      "function_names": [
        "gke_cluster_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461107",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.security.security_compliance",
    "assertion_id": "gke.cluster.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.1.3",
      "title": "Minimize wildcard use in Roles and ClusterRoles",
      "function_names": [
        "gke_cluster_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461113",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.access_control.public_access_restricted",
    "assertion_id": "gke.cluster.access_control.public_access_restricted",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement access_control controls for public_access_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "access_control",
        "what_to_check": "public_access_restricted"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.1.8",
      "title": "Avoid bindings to system:anonymous",
      "function_names": [
        "gke_cluster_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461119",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.access_control.public_access_restricted",
    "assertion_id": "gke.cluster.access_control.public_access_restricted",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement access_control controls for public_access_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "access_control",
        "what_to_check": "public_access_restricted"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.1.9",
      "title": "Avoid non-default bindings to system:unauthenticated",
      "function_names": [
        "gke_cluster_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461124",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.access_control.public_access_restricted",
    "assertion_id": "gke.cluster.access_control.public_access_restricted",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement access_control controls for public_access_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "access_control",
        "what_to_check": "public_access_restricted"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.1.10",
      "title": "Avoid non-default bindings to system:authenticated",
      "function_names": [
        "gke_cluster_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461135",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.security.pod_security_enforced",
    "assertion_id": "gke.cluster.security.pod_security_enforced",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement security controls for pod_security_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "security",
        "what_to_check": "pod_security_enforced"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.2.1",
      "title": "Ensure that the cluster enforces Pod Security Standard Baseline profile or stricter for all namespaces.",
      "function_names": [
        "gke_pod_security_policy_enabled_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461140",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.security.network_policies_enabled",
    "assertion_id": "gke.cluster.security.network_policies_enabled",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement security controls for network_policies_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "security",
        "what_to_check": "network_policies_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.3.2",
      "title": "Ensure that all Namespaces have Network Policies defined",
      "function_names": [
        "gke_network_policy_enabled_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461146",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.secrets.security.security_compliance",
    "assertion_id": "gke.secrets.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.secrets",
    "adapter": "gcp.gke.secrets",
    "adapter_evidence_type": "gcp.gke.secrets[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke secrets must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.secrets",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.4.1",
      "title": "Prefer using secrets as files over secrets as environment variables",
      "function_names": [
        "gke_secrets_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461151",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.security.security_compliance",
    "assertion_id": "gke.cluster.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.6.1",
      "title": "Create administrative boundaries between resources using namespaces",
      "function_names": [
        "gke_cluster_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461157",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.pod.security.seccomp_profile_enabled",
    "assertion_id": "gke.pod.security.seccomp_profile_enabled",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.pod",
    "adapter": "gcp.gke.pod",
    "adapter_evidence_type": "gcp.gke.pod[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke pod must implement security controls for seccomp_profile_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.pod",
      "params": {
        "check_type": "security",
        "what_to_check": "seccomp_profile_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.6.2",
      "title": "Ensure that the seccomp profile is set to RuntimeDefault in the pod definitions",
      "function_names": [
        "gke_cluster_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461162",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.security.security_compliance",
    "assertion_id": "gke.cluster.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "4.6.4",
      "title": "The default namespace should not be used",
      "function_names": [
        "gke_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461172",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.pod.vulnerability.vulnerability_scanning_enabled",
    "assertion_id": "gke.pod.vulnerability.vulnerability_scanning_enabled",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.pod",
    "adapter": "gcp.gke.pod",
    "adapter_evidence_type": "gcp.gke.pod[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke pod must implement vulnerability controls for vulnerability_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.pod",
      "params": {
        "check_type": "vulnerability",
        "what_to_check": "vulnerability_scanning_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.1.1",
      "title": "Ensure Image Vulnerability Scanning is enabled",
      "function_names": [
        "gke_container_image_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461177",
    "is_primary": true
  },
  {
    "rule_id": "gcp.iam.service_account.security.project_level_roles_restricted",
    "assertion_id": "iam.service_account.security.project_level_roles_restricted",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.service_account",
    "adapter": "gcp.iam.service_account",
    "adapter_evidence_type": "gcp.iam.service_account[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam service_account must implement security controls for project_level_roles_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account",
      "params": {
        "check_type": "security",
        "what_to_check": "project_level_roles_restricted"
      },
      "function_name": "gcp_iam_service_account_security_check"
    },
    "source": "cis_compliance_work",
    "created_from": {
      "compliance_entry_id": "5.1.2",
      "title": "Minimize user access to Container Image repositories",
      "function_names": [
        "gke_service_account_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461185",
    "is_primary": true,
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "1.6"
  },
  {
    "rule_id": "gcp.iam.service_account.security.security_policies_enforced",
    "assertion_id": "iam.service_account.security.security_policies_enforced",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.service_account",
    "adapter": "gcp.iam.service_account",
    "adapter_evidence_type": "gcp.iam.service_account[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam service_account must implement security controls for security_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account",
      "params": {
        "check_type": "security",
        "what_to_check": "security_policies_enforced"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.1.3",
      "title": "Minimize cluster access to read-only for Container Image repositories",
      "function_names": [
        "gke_service_account_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461190",
    "is_primary": true
  },
  {
    "rule_id": "gcp.security.general.vulnerability.vulnerability_scanning",
    "assertion_id": "security.general.vulnerability.vulnerability_scanning",
    "provider": "gcp",
    "service": "security",
    "resource_type": "gcp.security.general",
    "adapter": "gcp.security.general",
    "adapter_evidence_type": "gcp.security.general[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP security general must implement vulnerability controls for vulnerability_scanning to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.security.general",
      "params": {
        "check_type": "vulnerability",
        "what_to_check": "vulnerability_scanning"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.1.4",
      "title": "Ensure only trusted container images are used",
      "function_names": [
        "gke_container_image_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461195",
    "is_primary": true
  },
  {
    "rule_id": "gcp.iam.service_account.security.security_policies_enforced",
    "assertion_id": "iam.service_account.security.security_policies_enforced",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.service_account",
    "adapter": "gcp.iam.service_account",
    "adapter_evidence_type": "gcp.iam.service_account[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam service_account must implement security controls for security_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account",
      "params": {
        "check_type": "security",
        "what_to_check": "security_policies_enforced"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.2.1",
      "title": "Ensure GKE clusters are not running using the Compute Engine default service account",
      "function_names": [
        "gke_logging_enabled_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461201",
    "is_primary": true
  },
  {
    "rule_id": "gcp.iam.service_account.security.security_policies_enforced",
    "assertion_id": "iam.service_account.security.security_policies_enforced",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.service_account",
    "adapter": "gcp.iam.service_account",
    "adapter_evidence_type": "gcp.iam.service_account[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP iam service_account must implement security controls for security_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account",
      "params": {
        "check_type": "security",
        "what_to_check": "security_policies_enforced"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.2.2",
      "title": "Prefer using dedicated GCP Service Accounts and Workload Identity",
      "function_names": [
        "gke_service_account_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461208",
    "is_primary": true
  },
  {
    "rule_id": "gcp.kms.key.encryption.encryption_enabled",
    "assertion_id": "kms.key.encryption.encryption_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.key",
    "adapter": "gcp.kms.key",
    "adapter_evidence_type": "gcp.kms.key[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP kms key must implement encryption controls for encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key",
      "params": {
        "check_type": "encryption",
        "what_to_check": "encryption_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.3.1",
      "title": "Ensure Kubernetes Secrets are encrypted using keys managed in Cloud KMS",
      "function_names": [
        "gke_secrets_encryption_enabled_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461219",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.security.security_compliance",
    "assertion_id": "compute.instance.security.security_compliance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.4.1",
      "title": "Ensure the GKE Metadata Server is Enabled",
      "function_names": [
        "gke_container_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461224",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.node.security.security_compliance",
    "assertion_id": "gke.node.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.node",
    "adapter": "gcp.gke.node",
    "adapter_evidence_type": "gcp.gke.node[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke node must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.node",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.5.1",
      "title": "Ensure Container-Optimized OS (cos_containerd) is used for GKE node images",
      "function_names": [
        "gke_container_image_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461233",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.node.security.security_compliance",
    "assertion_id": "gke.node.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.node",
    "adapter": "gcp.gke.node",
    "adapter_evidence_type": "gcp.gke.node[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke node must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.node",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.5.2",
      "title": "Ensure Node Auto-Repair is enabled for GKE nodes",
      "function_names": [
        "gke_container_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461243",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.node.security.security_compliance",
    "assertion_id": "gke.node.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.node",
    "adapter": "gcp.gke.node",
    "adapter_evidence_type": "gcp.gke.node[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke node must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.node",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.5.3",
      "title": "Ensure Node Auto-Upgrade is enabled for GKE nodes",
      "function_names": [
        "gke_container_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461248",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.security.security_compliance",
    "assertion_id": "gke.cluster.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.5.4",
      "title": "When creating New Clusters - Automate GKE version management using Release Channels",
      "function_names": [
        "gke_container_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461257",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.monitoring.shielded_vm_enabled",
    "assertion_id": "compute.instance.monitoring.shielded_vm_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement monitoring controls for shielded_vm_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "monitoring",
        "what_to_check": "shielded_vm_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.5.5",
      "title": "Ensure Shielded GKE Nodes are Enabled",
      "function_names": [
        "gke_container_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461263",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.monitoring.shielded_vm_enabled",
    "assertion_id": "compute.instance.monitoring.shielded_vm_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement monitoring controls for shielded_vm_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "monitoring",
        "what_to_check": "shielded_vm_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.5.6",
      "title": "Ensure Integrity Monitoring for Shielded GKE Nodes is Enabled",
      "function_names": [
        "gke_monitoring_enabled_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461271",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.instance.security.shielded_vm_enabled",
    "assertion_id": "compute.instance.security.shielded_vm_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute instance must implement security controls for shielded_vm_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance",
      "params": {
        "check_type": "security",
        "what_to_check": "shielded_vm_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.5.7",
      "title": "Ensure Secure Boot for Shielded GKE Nodes is Enabled",
      "function_names": [
        "gke_container_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461276",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.node.security.security_compliance",
    "assertion_id": "gke.node.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.node",
    "adapter": "gcp.gke.node",
    "adapter_evidence_type": "gcp.gke.node[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke node must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.node",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.6.1",
      "title": "Enable VPC Flow Logs and Intranode Visibility",
      "function_names": [
        "gke_network_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461284",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.firewall.firewall_rules",
    "assertion_id": "gke.cluster.firewall.firewall_rules",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement firewall controls for firewall_rules to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "firewall",
        "what_to_check": "firewall_rules"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.6.2",
      "title": "Ensure use of VPC-native clusters",
      "function_names": [
        "gke_network_policy_enabled_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461291",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.security.security_compliance",
    "assertion_id": "gke.cluster.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.6.3",
      "title": "Ensure Control Plane Authorized Networks is Enabled",
      "function_names": [
        "gke_network_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461299",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.access_control.private_endpoint_enabled",
    "assertion_id": "gke.cluster.access_control.private_endpoint_enabled",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement access_control controls for private_endpoint_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "access_control",
        "what_to_check": "private_endpoint_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.6.4",
      "title": "Ensure clusters are created with Private Endpoint Enabled and Public Access Disabled",
      "function_names": [
        "gke_container_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461305",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.access_control.private_nodes_enabled",
    "assertion_id": "gke.cluster.access_control.private_nodes_enabled",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement access_control controls for private_nodes_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "access_control",
        "what_to_check": "private_nodes_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.6.5",
      "title": "Ensure clusters are created with Private Nodes",
      "function_names": [
        "gke_container_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461312",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.node.firewall.firewall_rules",
    "assertion_id": "gke.node.firewall.firewall_rules",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.node",
    "adapter": "gcp.gke.node",
    "adapter_evidence_type": "gcp.gke.node[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke node must implement firewall controls for firewall_rules to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.node",
      "params": {
        "check_type": "firewall",
        "what_to_check": "firewall_rules"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.6.6",
      "title": "Consider firewalling GKE worker nodes",
      "function_names": [
        "gke_network_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461318",
    "is_primary": true
  },
  {
    "rule_id": "gcp.security.general.ssl.ssl_enabled",
    "assertion_id": "security.general.ssl.ssl_enabled",
    "provider": "gcp",
    "service": "security",
    "resource_type": "gcp.security.general",
    "adapter": "gcp.security.general",
    "adapter_evidence_type": "gcp.security.general[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP security general must implement ssl controls for ssl_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.security.general",
      "params": {
        "check_type": "ssl",
        "what_to_check": "ssl_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.6.7",
      "title": "Ensure use of Google-managed SSL Certificates",
      "function_names": [
        "gke_network_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461323",
    "is_primary": true
  },
  {
    "rule_id": "gcp.logging.logging.logging.logging_enabled",
    "assertion_id": "logging.logging.logging.logging_enabled",
    "provider": "gcp",
    "service": "logging",
    "resource_type": "gcp.logging.logging",
    "adapter": "gcp.logging.logging",
    "adapter_evidence_type": "gcp.logging.logging[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP logging logging must implement logging controls for logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.logging",
      "params": {
        "check_type": "logging",
        "what_to_check": "logging_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.7.1",
      "title": "Ensure Logging and Cloud Monitoring is Enabled",
      "function_names": [
        "gke_logging_enabled_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461329",
    "is_primary": true
  },
  {
    "rule_id": "gcp.logging.logging.logging.logging_enabled",
    "assertion_id": "logging.logging.logging.logging_enabled",
    "provider": "gcp",
    "service": "logging",
    "resource_type": "gcp.logging.logging",
    "adapter": "gcp.logging.logging",
    "adapter_evidence_type": "gcp.logging.logging[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP logging logging must implement logging controls for logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.logging",
      "params": {
        "check_type": "logging",
        "what_to_check": "logging_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.7.2",
      "title": "Enable Linux auditd logging",
      "function_names": [
        "gke_audit_logging_enabled_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461337",
    "is_primary": true
  },
  {
    "rule_id": "gcp.security.general.ssl.ssl_enabled",
    "assertion_id": "security.general.ssl.ssl_enabled",
    "provider": "gcp",
    "service": "security",
    "resource_type": "gcp.security.general",
    "adapter": "gcp.security.general",
    "adapter_evidence_type": "gcp.security.general[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP security general must implement ssl controls for ssl_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.security.general",
      "params": {
        "check_type": "ssl",
        "what_to_check": "ssl_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.8.1",
      "title": "Ensure authentication using Client Certificates is Disabled",
      "function_names": [
        "gke_container_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461345",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.security.security_compliance",
    "assertion_id": "gke.cluster.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.8.3",
      "title": "Ensure Legacy Authorization (ABAC) is Disabled",
      "function_names": [
        "gke_rbac_enabled_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461351",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.disk.key_management.only_gcp_managed_keys",
    "assertion_id": "compute.disk.key_management.only_gcp_managed_keys",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.disk",
    "adapter": "gcp.compute.disk",
    "adapter_evidence_type": "gcp.compute.disk[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute disk must implement key_management controls for only_gcp_managed_keys to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk",
      "params": {
        "check_type": "key_management",
        "what_to_check": "only_gcp_managed_keys"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.9.1",
      "title": "Enable Customer-Managed Encryption Keys (CMEK) for GKE Persistent Disks (PD)",
      "function_names": [
        "gke_cluster_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461357",
    "is_primary": true
  },
  {
    "rule_id": "gcp.compute.disk.key_management.only_gcp_managed_keys",
    "assertion_id": "compute.disk.key_management.only_gcp_managed_keys",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.disk",
    "adapter": "gcp.compute.disk",
    "adapter_evidence_type": "gcp.compute.disk[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP compute disk must implement key_management controls for only_gcp_managed_keys to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk",
      "params": {
        "check_type": "key_management",
        "what_to_check": "only_gcp_managed_keys"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.9.2",
      "title": "Enable Customer-Managed Encryption Keys (CMEK) for Boot Disks",
      "function_names": [
        "gke_container_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461362",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.vulnerability.vulnerability_scanning",
    "assertion_id": "gke.cluster.vulnerability.vulnerability_scanning",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement vulnerability controls for vulnerability_scanning to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "vulnerability",
        "what_to_check": "vulnerability_scanning"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.10.1",
      "title": "Ensure Kubernetes Web UI is Disabled",
      "function_names": [
        "gke_container_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461367",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.security.security_compliance",
    "assertion_id": "gke.cluster.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.10.2",
      "title": "Ensure that Alpha clusters are not used for production workloads",
      "function_names": [
        "gke_container_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461377",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.security.security_compliance",
    "assertion_id": "gke.cluster.security.security_compliance",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.10.3",
      "title": "Consider GKE Sandbox for running untrusted workloads",
      "function_names": [
        "gke_container_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461383",
    "is_primary": true
  },
  {
    "rule_id": "gcp.gke.cluster.vulnerability.binary_authorization_enabled",
    "assertion_id": "gke.cluster.vulnerability.binary_authorization_enabled",
    "provider": "gcp",
    "service": "gke",
    "resource_type": "gcp.gke.cluster",
    "adapter": "gcp.gke.cluster",
    "adapter_evidence_type": "gcp.gke.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP gke cluster must implement vulnerability controls for binary_authorization_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster",
      "params": {
        "check_type": "vulnerability",
        "what_to_check": "binary_authorization_enabled"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.10.4",
      "title": "Ensure use of Binary Authorization",
      "function_names": [
        "gke_rbac_enabled_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461388",
    "is_primary": true
  },
  {
    "rule_id": "gcp.security.general.security.security_compliance",
    "assertion_id": "security.general.security.security_compliance",
    "provider": "gcp",
    "service": "security",
    "resource_type": "gcp.security.general",
    "adapter": "gcp.security.general",
    "adapter_evidence_type": "gcp.security.general[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "GCP security general must implement security controls for security_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.security.general",
      "params": {
        "check_type": "security",
        "what_to_check": "security_compliance"
      }
    },
    "source": "cis_compliance_work_fixed",
    "created_from": {
      "compliance_entry_id": "5.10.5",
      "title": "Enable Security Posture",
      "function_names": [
        "gke_container_security_check"
      ]
    },
    "created_at": "2025-09-22T20:55:13.461397",
    "is_primary": true
  },
  {
    "rule_id": "gcp.storage.bucket.access.public_access_restricted",
    "assertion_id": "gcp.storage.bucket",
    "service": "storage",
    "resource_type": "bucket",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That Cloud Storage Bucket Is Not Anonymously or Publicly Accessible",
    "adapter_spec": {
      "function_name": "gcp_storage_bucket_public_access_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "5.1"
  },
  {
    "rule_id": "gcp.gke.kubelet.readonly_port_disabled",
    "assertion_id": "gcp.gke.kubelet",
    "service": "gke",
    "resource_type": "kubelet",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the --read-only-port is disabled",
    "adapter_spec": {
      "function_name": "gke_kubelet_readonly_port_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "3.2.4"
  },
  {
    "rule_id": "gcp.compute.instance.security.shielded_vm_integrity_monitoring_enabled",
    "assertion_id": "gcp.compute.instance",
    "service": "compute",
    "resource_type": "instance",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Compute Instances Are Launched With Shielded VM Enabled",
    "adapter_spec": {
      "function_name": "gcp_compute_instance_shielded_vm_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "4.8"
  },
  {
    "rule_id": "gcp.network.load_balancer.ssl.weak_ciphers_restricted",
    "assertion_id": "gcp.network.load_balancer",
    "service": "network",
    "resource_type": "load_balancer",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure No HTTPS or SSL Proxy Load Balancers Permit SSL Policies With Weak Cipher Suites",
    "adapter_spec": {
      "function_name": "gcp_load_balancer_ssl_security_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "3.9"
  },
  {
    "rule_id": "gcp.gke.kubelet.ssl_enabled",
    "assertion_id": "gcp.gke.kubelet",
    "service": "gke",
    "resource_type": "kubelet",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the RotateKubeletServerCertificate argument is set to true",
    "adapter_spec": {
      "function_name": "gke_kubelet_ssl_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "3.2.9"
  },
  {
    "rule_id": "gcp.network.vpc.flow_logs.traffic_monitoring_enabled",
    "assertion_id": "gcp.network.vpc",
    "service": "network",
    "resource_type": "vpc",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that VPC Flow Logs is Enabled for Every Subnet in a VPC Network",
    "adapter_spec": {
      "function_name": "gcp_vpc_flow_logs_enabled_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "3.8"
  },
  {
    "rule_id": "gcp.gke.load_balancer.google_managed_ssl_certificates_enabled",
    "assertion_id": "gcp.gke.load_balancer",
    "service": "gke",
    "resource_type": "load_balancer",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure use of Google-managed SSL Certificates",
    "adapter_spec": {
      "function_name": "gke_google_managed_ssl_certificates_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.6.7"
  },
  {
    "rule_id": "gcp.sql.database.mysql.local_infile_disabled",
    "assertion_id": "gcp.sql.database",
    "service": "sql",
    "resource_type": "database",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That the 'Local_infile' Database Flag for a Cloud SQL MySQL Instance Is Set to 'Off'",
    "adapter_spec": {
      "function_name": "gcp_sql_mysql_local_infile_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.1.3"
  },
  {
    "rule_id": "gcp.gke.cluster.secrets_access_restricted",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Minimize access to secrets",
    "adapter_spec": {
      "function_name": "gke_secrets_access_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.1.2"
  },
  {
    "rule_id": "gcp.gke.cluster.alpha_features_disabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that Alpha clusters are not used for production workloads",
    "adapter_spec": {
      "function_name": "gke_cluster_alpha_features_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.10.2"
  },
  {
    "rule_id": "gcp.sql.database.postgres.log_error_verbosity_strict",
    "assertion_id": "gcp.sql.database",
    "service": "sql",
    "resource_type": "database",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure 'Log_error_verbosity' Database Flag for Cloud SQL PostgreSQL Instance Is Set to 'DEFAULT' or Stricter",
    "adapter_spec": {
      "function_name": "gcp_sql_postgres_log_verbosity_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.2.1"
  },
  {
    "rule_id": "gcp.gke.cluster.metadata_server_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure the GKE Metadata Server is Enabled",
    "adapter_spec": {
      "function_name": "gke_metadata_server_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.4.1"
  },
  {
    "rule_id": "gcp.sql.database.postgres.log_disconnections_flag_enabled",
    "assertion_id": "gcp.sql.database",
    "service": "sql",
    "resource_type": "database",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That the 'Log_disconnections' Database Flag for Cloud SQL PostgreSQL Instance Is Set to 'On'",
    "adapter_spec": {
      "function_name": "gcp_sql_postgres_log_disconnections_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.2.3"
  },
  {
    "rule_id": "gcp.gke.node.linux_auditd_logging_enabled",
    "assertion_id": "gcp.gke.node",
    "service": "gke",
    "resource_type": "node",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Enable Linux auditd logging",
    "adapter_spec": {
      "function_name": "gke_linux_auditd_logging_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.7.2"
  },
  {
    "rule_id": "gcp.sql.database.mysql.skip_show_database_flag_enabled",
    "assertion_id": "gcp.sql.database",
    "service": "sql",
    "resource_type": "database",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure 'Skip_show_database' Database Flag for Cloud SQL MySQL Instance Is Set to 'On'",
    "adapter_spec": {
      "function_name": "gcp_sql_mysql_skip_show_database_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.1.2"
  },
  {
    "rule_id": "gcp.gke.cluster.pod_security.policies_enforced",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the cluster enforces Pod Security Standard Baseline profile or stricter for all namespaces.",
    "adapter_spec": {
      "function_name": "gke_pod_security_policies_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "4.2.1"
  },
  {
    "rule_id": "gcp.gke.cluster.logging_and_monitoring_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Logging and Cloud Monitoring is Enabled",
    "adapter_spec": {
      "function_name": "gke_logging_and_monitoring_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.7.1"
  },
  {
    "rule_id": "gcp.organization.access_approval.manual_approval_required",
    "assertion_id": "gcp.organization.access_approval",
    "service": "organization",
    "resource_type": "access_approval",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure 'Access Approval' is 'Enabled'",
    "adapter_spec": {
      "function_name": "gcp_access_approval_enabled_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "2.15"
  },
  {
    "rule_id": "gcp.gke.cluster.legacy_authorization_disabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Legacy Authorization (ABAC) is Disabled",
    "adapter_spec": {
      "function_name": "gke_cluster_legacy_authorization_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.8.3"
  },
  {
    "rule_id": "gcp.sql.database.postgres.log_min_duration_disabled",
    "assertion_id": "gcp.sql.database",
    "service": "sql",
    "resource_type": "database",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That the 'Log_min_duration_statement' Database Flag for Cloud SQL PostgreSQL Instance Is Set to '-1' (Disabled)",
    "adapter_spec": {
      "function_name": "gcp_sql_postgres_log_min_duration_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.2.7"
  },
  {
    "rule_id": "gcp.sql.database.sqlserver.trace_flag_3625_monitoring_enabled",
    "assertion_id": "gcp.sql.database",
    "service": "sql",
    "resource_type": "database",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure '3625 (trace flag)' Database Flag for all Cloud SQL SQL Server Instances Is Set to 'on'",
    "adapter_spec": {
      "function_name": "gcp_sql_sqlserver_trace_flag_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.3.6"
  },
  {
    "rule_id": "gcp.gke.cluster.namespaces.defined",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Create administrative boundaries between resources using namespaces",
    "adapter_spec": {
      "function_name": "gke_namespaces_created_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "4.6.1"
  },
  {
    "rule_id": "gcp.gke.kubelet.event_record_qps_configured",
    "assertion_id": "gcp.gke.kubelet",
    "service": "gke",
    "resource_type": "kubelet",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the --eventRecordQPS argument is set to 0 or a level which ensures appropriate event capture",
    "adapter_spec": {
      "function_name": "gke_kubelet_event_record_qps_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "3.2.7"
  },
  {
    "rule_id": "gcp.compute.disk.key_management.check_only_gcp_managed_keys",
    "assertion_id": "gcp.compute.disk",
    "service": "compute",
    "resource_type": "disk",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Enable Customer-Managed Encryption Keys (CMEK) for GKE Persistent Disks (PD)",
    "adapter_spec": {
      "function_name": "gke_pod_security_policies_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "5.6.1"
  },
  {
    "rule_id": "gcp.dns.dns.privilege.dnssec_signing_enabled",
    "assertion_id": "gcp.dns.dns",
    "service": "dns",
    "resource_type": "dns",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That DNSSEC Is Enabled for Cloud DNS",
    "adapter_spec": {
      "function_name": "gcp_dns_security_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "3.3"
  },
  {
    "rule_id": "gcp.gke.cluster.metadata_server.access_restricted",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Enable VPC Flow Logs and Intranode Visibility",
    "adapter_spec": {
      "function_name": "gke_metadata_server_access_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "5.4.1"
  },
  {
    "rule_id": "gcp.gke.kubelet.config_file_ownership.root_root",
    "assertion_id": "gcp.gke.kubelet",
    "service": "gke",
    "resource_type": "kubelet",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the kubelet configuration file ownership is set to root:root",
    "adapter_spec": {
      "function_name": "gke_kubelet_config_ownership_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "3.1.4"
  },
  {
    "rule_id": "gcp.dns.dns.dnssec.zone_signing_enabled",
    "assertion_id": "gcp.dns.dns",
    "service": "dns",
    "resource_type": "dns",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That RSASHA1 Is Not Used for the Zone-Signing Key in Cloud DNS DNSSEC",
    "adapter_spec": {
      "function_name": "gcp_dns_security_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "3.5"
  },
  {
    "rule_id": "gcp.gke.cluster.vpc_native_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure use of VPC-native clusters",
    "adapter_spec": {
      "function_name": "gke_cluster_vpc_native_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.6.2"
  },
  {
    "rule_id": "gcp.kms.key.key_management.customer_managed_encryption_enabled",
    "assertion_id": "gcp.kms.key",
    "service": "kms",
    "resource_type": "key",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That a Default Customer-Managed Encryption Key (CMEK) Is Specified for All BigQuery Data Sets",
    "adapter_spec": {
      "function_name": "gcp_kms_encryption_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "7.3"
  },
  {
    "rule_id": "gcp.gke.cluster.rbac.wildcards_restricted",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Minimize wildcard use in Roles and ClusterRoles",
    "adapter_spec": {
      "function_name": "gke_rbac_wildcards_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "4.1.3"
  },
  {
    "rule_id": "gcp.compute.instance.service_account.default_disabled",
    "assertion_id": "gcp.compute.instance",
    "service": "compute",
    "resource_type": "instance",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That Instances Are Not Configured To Use the Default Service Account With Full Access to All Cloud APIs",
    "adapter_spec": {
      "function_name": "gcp_compute_instance_default_service_account_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "4.2"
  },
  {
    "rule_id": "gcp.gke.cluster.pod_security.seccomp_runtime_default",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the seccomp profile is set to RuntimeDefault in the pod definitions",
    "adapter_spec": {
      "function_name": "gke_seccomp_runtime_default_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "4.6.2"
  },
  {
    "rule_id": "gcp.gke.node.vpc_flow_logs_enabled",
    "assertion_id": "gcp.gke.node",
    "service": "gke",
    "resource_type": "node",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Enable VPC Flow Logs and Intranode Visibility",
    "adapter_spec": {
      "function_name": "gke_node_vpc_flow_logs_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.6.1"
  },
  {
    "rule_id": "gcp.services.api_keys.rotation.rotated_90_days",
    "assertion_id": "gcp.services.api_keys",
    "service": "services",
    "resource_type": "api_keys",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure API Keys Are Rotated Every 90 Days",
    "adapter_spec": {
      "function_name": "gcp_services_api_keys_rotation_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "1.15"
  },
  {
    "rule_id": "gcp.gke.node.shielded_nodes_enabled",
    "assertion_id": "gcp.gke.node",
    "service": "gke",
    "resource_type": "node",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Shielded GKE Nodes are Enabled",
    "adapter_spec": {
      "function_name": "gke_shielded_nodes_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.5.5"
  },
  {
    "rule_id": "gcp.gke.secrets.secrets_mount.file_based_preferred",
    "assertion_id": "gcp.gke.secrets",
    "service": "gke",
    "resource_type": "secrets",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Prefer using secrets as files over secrets as environment variables",
    "adapter_spec": {
      "function_name": "gke_secrets_secrets_mount_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.4.1"
  },
  {
    "rule_id": "gcp.gke.general.sandbox_enabled",
    "assertion_id": "gcp.gke.general",
    "service": "gke",
    "resource_type": "general",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Consider GKE Sandbox for running untrusted workloads",
    "adapter_spec": {
      "function_name": "gke_general_sandbox_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.10.3"
  },
  {
    "rule_id": "gcp.sql.database.sqlserver.user_connections_unlimited",
    "assertion_id": "gcp.sql.database",
    "service": "sql",
    "resource_type": "database",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure 'user Connections' Database Flag for Cloud SQL SQL Server Instance Is Set to a Non-limiting Value",
    "adapter_spec": {
      "function_name": "gcp_sql_sqlserver_user_connections_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.3.3"
  },
  {
    "rule_id": "gcp.gke.kubeconfig.file_permissions_restricted",
    "assertion_id": "gcp.gke.kubeconfig",
    "service": "gke",
    "resource_type": "kubeconfig",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the proxy kubeconfig file permissions are set to 644 or more restrictive",
    "adapter_spec": {
      "function_name": "gke_kubeconfig_file_permissions_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "3.1.1"
  },
  {
    "rule_id": "gcp.gke.cluster.rbac_wildcard_usage_restricted",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Minimize wildcard use in Roles and ClusterRoles",
    "adapter_spec": {
      "function_name": "gke_rbac_wildcard_usage_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.1.3"
  },
  {
    "rule_id": "gcp.gke.cluster.dns_logging_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Create administrative boundaries between resources using namespaces",
    "adapter_spec": {
      "function_name": "gke_cluster_dns_logging_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.6.1"
  },
  {
    "rule_id": "gcp.iam.service_account.key_rotation.external_keys_rotated_90_days",
    "assertion_id": "gcp.iam.service_account",
    "service": "iam",
    "resource_type": "service_account",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure User-Managed/External Keys for Service Accounts Are Rotated Every 90 Days or Fewer",
    "adapter_spec": {
      "function_name": "gcp_iam_service_account_key_rotation_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "1.7"
  },
  {
    "rule_id": "gcp.gke.secrets.kms_encryption_enabled",
    "assertion_id": "gcp.gke.secrets",
    "service": "gke",
    "resource_type": "secrets",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Kubernetes Secrets are encrypted using keys managed in Cloud KMS",
    "adapter_spec": {
      "function_name": "gke_secrets_kms_encryption_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.3.1"
  },
  {
    "rule_id": "gcp.gke.namespace.default_namespace_restricted",
    "assertion_id": "gcp.gke.namespace",
    "service": "gke",
    "resource_type": "namespace",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: The default namespace should not be used",
    "adapter_spec": {
      "function_name": "gke_namespace_default_namespace_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.6.4"
  },
  {
    "rule_id": "gcp.logging.monitoring.storage_iam_changes_alerted",
    "assertion_id": "gcp.logging.monitoring",
    "service": "logging",
    "resource_type": "monitoring",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That the Log Metric Filter and Alerts Exist for Cloud Storage IAM Permission Changes",
    "adapter_spec": {
      "function_name": "gcp_logging_storage_iam_changes_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "2.10"
  },
  {
    "rule_id": "gcp.compute.instance.encryption.customer_managed_keys_enabled",
    "assertion_id": "gcp.compute.instance",
    "service": "compute",
    "resource_type": "instance",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that Dataproc Cluster is encrypted using Customer- Managed Encryption Key",
    "adapter_spec": {
      "function_name": "gcp_kms_encryption_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "8.1"
  },
  {
    "rule_id": "gcp.gke.cluster.system_unauthenticated_binding_restricted",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Avoid non-default bindings to system:unauthenticated",
    "adapter_spec": {
      "function_name": "gke_system_unauthenticated_binding_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.1.9"
  },
  {
    "rule_id": "gcp.gke.cluster.rbac.unauthenticated_access_restricted",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Avoid non-default bindings to system:unauthenticated",
    "adapter_spec": {
      "function_name": "gke_rbac_unauthenticated_access_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "4.1.9"
  },
  {
    "rule_id": "gcp.gke.cluster.release_channels_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: When creating New Clusters - Automate GKE version management using Release Channels",
    "adapter_spec": {
      "function_name": "gke_cluster_release_channels_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.5.4"
  },
  {
    "rule_id": "gcp.dns.logging.query_logging_enabled",
    "assertion_id": "gcp.dns.logging",
    "service": "dns",
    "resource_type": "logging",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That Cloud DNS Logging Is Enabled for All VPC Networks",
    "adapter_spec": {
      "function_name": "gcp_dns_logging_enabled_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "2.12"
  },
  {
    "rule_id": "gcp.gke.cluster.rbac.authenticated_access_restricted",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Avoid non-default bindings to system:authenticated",
    "adapter_spec": {
      "function_name": "gke_rbac_authenticated_access_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "4.1.10"
  },
  {
    "rule_id": "gcp.gke.kubeconfig.proxy_file_ownership.root_root",
    "assertion_id": "gcp.gke.kubeconfig",
    "service": "gke",
    "resource_type": "kubeconfig",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the proxy kubeconfig file ownership is set to root:root",
    "adapter_spec": {
      "function_name": "gke_proxy_kubeconfig_ownership_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "3.1.2"
  },
  {
    "rule_id": "gcp.sql.database.postgres.log_statement_configured",
    "assertion_id": "gcp.sql.database",
    "service": "sql",
    "resource_type": "database",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure 'Log_statement' Database Flag for Cloud SQL PostgreSQL Instance Is Set Appropriately",
    "adapter_spec": {
      "function_name": "gcp_sql_postgres_log_statement_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.2.4"
  },
  {
    "rule_id": "gcp.storage.bucket.security.uniform_bucket_level_access_iam_enabled",
    "assertion_id": "gcp.storage.bucket",
    "service": "storage",
    "resource_type": "bucket",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That Cloud Storage Buckets Have Uniform Bucket- Level Access Enabled",
    "adapter_spec": {
      "function_name": "gcp_storage_bucket_security_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "5.2"
  },
  {
    "rule_id": "gcp.gke.node.auto_upgrade_enabled",
    "assertion_id": "gcp.gke.node",
    "service": "gke",
    "resource_type": "node",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Node Auto-Upgrade is enabled for GKE nodes",
    "adapter_spec": {
      "function_name": "gke_node_auto_upgrade_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.5.3"
  },
  {
    "rule_id": "gcp.sql.database.postgres.log_min_error_statement_strict",
    "assertion_id": "gcp.sql.database",
    "service": "sql",
    "resource_type": "database",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure 'Log_min_error_statement' Database Flag for Cloud SQL PostgreSQL Instance Is Set to 'Error' or Stricter",
    "adapter_spec": {
      "function_name": "gcp_sql_postgres_log_min_error_statement_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.2.6"
  },
  {
    "rule_id": "gcp.gke.cluster.endpoint.public_access_restricted",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure clusters are created with Private Endpoint Enabled and Public Access Disabled",
    "adapter_spec": {
      "function_name": "gke_private_endpoint_public_access_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "5.4.3"
  },
  {
    "rule_id": "gcp.gke.cluster.network.namespace_policies_defined",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that all Namespaces have Network Policies defined",
    "adapter_spec": {
      "function_name": "gke_namespace_network_policies_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "4.3.1"
  },
  {
    "rule_id": "gcp.gke.kubelet.authorization_mode.webhook_enabled",
    "assertion_id": "gcp.gke.kubelet",
    "service": "gke",
    "resource_type": "kubelet",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the --authorization-mode argument is not set to AlwaysAllow",
    "adapter_spec": {
      "function_name": "gke_kubelet_authorization_mode_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "3.2.2"
  },
  {
    "rule_id": "gcp.gke.boot_disk.customer_managed_encryption_enabled",
    "assertion_id": "gcp.gke.boot_disk",
    "service": "gke",
    "resource_type": "boot_disk",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Enable Customer-Managed Encryption Keys (CMEK) for Boot Disks",
    "adapter_spec": {
      "function_name": "gke_boot_disk_customer_managed_encryption_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.9.2"
  },
  {
    "rule_id": "gcp.gke.general.web_ui_disabled",
    "assertion_id": "gcp.gke.general",
    "service": "gke",
    "resource_type": "general",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Kubernetes Web UI is Disabled",
    "adapter_spec": {
      "function_name": "gke_general_web_ui_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.10.1"
  },
  {
    "rule_id": "gcp.security.general.vulnerability.check_vulnerability_scanning",
    "assertion_id": "gcp.security.general",
    "service": "security",
    "resource_type": "general",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure only trusted container images are used",
    "adapter_spec": {
      "function_name": "gke_network_segmentation_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "5.1.4"
  },
  {
    "rule_id": "gcp.services.api_keys.restrictions.hosts_apps_only",
    "assertion_id": "gcp.services.api_keys",
    "service": "services",
    "resource_type": "api_keys",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure API Keys Are Restricted To Use by Only Specified Hosts and Apps",
    "adapter_spec": {
      "function_name": "gcp_services_api_keys_restrictions_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "1.13"
  },
  {
    "rule_id": "gcp.logging.monitoring.sql_config_changes_alerted",
    "assertion_id": "gcp.logging.monitoring",
    "service": "logging",
    "resource_type": "monitoring",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That the Log Metric Filter and Alerts Exist for SQL Instance Configuration Changes",
    "adapter_spec": {
      "function_name": "gcp_logging_sql_config_changes_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "2.11"
  },
  {
    "rule_id": "gcp.gke.node.firewall_rules_configured",
    "assertion_id": "gcp.gke.node",
    "service": "gke",
    "resource_type": "node",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Consider firewalling GKE worker nodes",
    "adapter_spec": {
      "function_name": "gke_worker_node_firewall_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.6.6"
  },
  {
    "rule_id": "gcp.gke.kubelet.streaming_connection_timeout_configured",
    "assertion_id": "gcp.gke.kubelet",
    "service": "gke",
    "resource_type": "kubelet",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the --streaming-connection-idle-timeout argument is not set to 0",
    "adapter_spec": {
      "function_name": "gke_kubelet_streaming_timeout_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "3.2.5"
  },
  {
    "rule_id": "gcp.sql.database.sqlserver.user_options_unconfigured",
    "assertion_id": "gcp.sql.database",
    "service": "sql",
    "resource_type": "database",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure 'user options' Database Flag for Cloud SQL SQL Server Instance Is Not Configured",
    "adapter_spec": {
      "function_name": "gcp_sql_sqlserver_user_options_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.3.4"
  },
  {
    "rule_id": "gcp.gke.cluster.control_plane_logging_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Configure Image Provenance using ImagePolicyWebhook admission controller",
    "adapter_spec": {
      "function_name": "gke_control_plane_logging_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.5.1"
  },
  {
    "rule_id": "gcp.kms.key.encryption.check_encryption_enabled",
    "assertion_id": "gcp.kms.key",
    "service": "kms",
    "resource_type": "key",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Kubernetes Secrets are encrypted using keys managed in Cloud KMS",
    "adapter_spec": {
      "function_name": "gke_rbac_secrets_access_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "5.3.1"
  },
  {
    "rule_id": "gcp.gke.cluster.privilege_escalation_permissions_restricted",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Limit use of the Bind, Impersonate and Escalate permissions in the Kubernetes cluster",
    "adapter_spec": {
      "function_name": "gke_privilege_escalation_permissions_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.1.7"
  },
  {
    "rule_id": "gcp.gke.general.user_access.minimized",
    "assertion_id": "gcp.gke.general",
    "service": "gke",
    "resource_type": "general",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Minimize user access to Container Image repositories",
    "adapter_spec": {
      "function_name": "gke_general_user_access_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.1.2"
  },
  {
    "rule_id": "gcp.gke.node.secure_boot_enabled",
    "assertion_id": "gcp.gke.node",
    "service": "gke",
    "resource_type": "node",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Secure Boot for Shielded GKE Nodes is Enabled",
    "adapter_spec": {
      "function_name": "gke_node_secure_boot_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.5.7"
  },
  {
    "rule_id": "gcp.gke.cluster.system_authenticated_binding_restricted",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Avoid non-default bindings to system:authenticated",
    "adapter_spec": {
      "function_name": "gke_system_authenticated_binding_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.1.10"
  },
  {
    "rule_id": "gcp.sql.database.postgres.log_min_messages_warning",
    "assertion_id": "gcp.sql.database",
    "service": "sql",
    "resource_type": "database",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the 'Log_min_messages' Flag for a Cloud SQL PostgreSQL Instance is set at minimum to 'Warning'",
    "adapter_spec": {
      "function_name": "gcp_sql_postgres_log_min_messages_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.2.5"
  },
  {
    "rule_id": "gcp.compute.instance.patch_management.automatic_os_updates_enabled",
    "assertion_id": "gcp.compute.instance",
    "service": "compute",
    "resource_type": "instance",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure the Latest Operating System Updates Are Installed On Your Virtual Machines in All Projects",
    "adapter_spec": {
      "function_name": "gcp_compute_instance_os_updates_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "4.12"
  },
  {
    "rule_id": "gcp.gke.cluster.pod_security_standards.baseline_enforced",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the cluster enforces Pod Security Standard Baseline profile or stricter for all namespaces.",
    "adapter_spec": {
      "function_name": "gke_pod_security_baseline_enforcement_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.2.1"
  },
  {
    "rule_id": "gcp.gke.cluster.namespaces.default_not_used",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: The default namespace should not be used",
    "adapter_spec": {
      "function_name": "gke_default_namespace_usage_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "4.6.4"
  },
  {
    "rule_id": "gcp.gke.cluster.client_certificate_authentication_disabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure authentication using Client Certificates is Disabled",
    "adapter_spec": {
      "function_name": "gke_client_certificate_authentication_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.8.1"
  },
  {
    "rule_id": "gcp.gke.cluster.private_endpoint_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure clusters are created with Private Endpoint Enabled and Public Access Disabled",
    "adapter_spec": {
      "function_name": "gke_cluster_private_endpoint_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.6.4"
  },
  {
    "rule_id": "gcp.sql.database.postgres.log_connections_flag_enabled",
    "assertion_id": "gcp.sql.database",
    "service": "sql",
    "resource_type": "database",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That the 'Log_connections' Database Flag for Cloud SQL PostgreSQL Instance Is Set to 'On'",
    "adapter_spec": {
      "function_name": "gcp_sql_postgres_log_connections_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.2.2"
  },
  {
    "rule_id": "gcp.gke.cluster.nodes.private_nodes_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure clusters are created with Private Nodes",
    "adapter_spec": {
      "function_name": "gke_private_nodes_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "5.4.4"
  },
  {
    "rule_id": "gcp.sql.database.ssl.ssl_only_connections_required",
    "assertion_id": "gcp.sql.database",
    "service": "sql",
    "resource_type": "database",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That the Cloud SQL Database Instance Requires All Incoming Connections To Use SSL",
    "adapter_spec": {
      "function_name": "gcp_sql_ssl_connections_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.4"
  },
  {
    "rule_id": "gcp.gke.node.integrity_monitoring_enabled",
    "assertion_id": "gcp.gke.node",
    "service": "gke",
    "resource_type": "node",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Integrity Monitoring for Shielded GKE Nodes is Enabled",
    "adapter_spec": {
      "function_name": "gke_node_integrity_monitoring_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.5.6"
  },
  {
    "rule_id": "gcp.gke.service_account.token_mounting_restricted",
    "assertion_id": "gcp.gke.service_account",
    "service": "gke",
    "resource_type": "service_account",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that Service Account Tokens are only mounted where necessary",
    "adapter_spec": {
      "function_name": "gke_service_account_token_mount_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.1.5"
  },
  {
    "rule_id": "gcp.gke.kubelet.authentication_enabled",
    "assertion_id": "gcp.gke.kubelet",
    "service": "gke",
    "resource_type": "kubelet",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the Anonymous Auth is Not Enabled Draft",
    "adapter_spec": {
      "function_name": "gke_kubelet_authentication_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "3.2.1"
  },
  {
    "rule_id": "gcp.sql.database.sqlserver.contained_auth_disabled",
    "assertion_id": "gcp.sql.database",
    "service": "sql",
    "resource_type": "database",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure 'contained database authentication' Database Flag for Cloud SQL SQL Server Instance Is Set to 'off'",
    "adapter_spec": {
      "function_name": "gcp_sql_sqlserver_contained_auth_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.3.7"
  },
  {
    "rule_id": "gcp.sql.database.sqlserver.remote_access_disabled",
    "assertion_id": "gcp.sql.database",
    "service": "sql",
    "resource_type": "database",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure 'remote access' Database Flag for Cloud SQL SQL Server Instance Is Set to 'off'",
    "adapter_spec": {
      "function_name": "gcp_sql_sqlserver_remote_access_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.3.5"
  },
  {
    "rule_id": "gcp.gke.cluster.external_secret_storage_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Consider external secret storage",
    "adapter_spec": {
      "function_name": "gke_external_secret_storage_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.4.2"
  },
  {
    "rule_id": "gcp.gke.cluster.webhook_admission_controller_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the seccomp profile is set to RuntimeDefault in the pod definitions",
    "adapter_spec": {
      "function_name": "gke_webhook_admission_controller_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.6.2"
  },
  {
    "rule_id": "gcp.gke.cluster.binary_authorization.trusted_registries_required",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure only trusted container images are used",
    "adapter_spec": {
      "function_name": "gke_trusted_container_images_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.1.4"
  },
  {
    "rule_id": "gcp.gke.cluster.system_masters_group_restricted",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Avoid use of system:masters group",
    "adapter_spec": {
      "function_name": "gke_system_masters_group_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.1.6"
  },
  {
    "rule_id": "gcp.compute.instance.backup.automatic_backup_enabled",
    "assertion_id": "gcp.compute.instance",
    "service": "compute",
    "resource_type": "instance",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That Cloud SQL Database Instances Are Configured With Automated Backups",
    "adapter_spec": {
      "function_name": "gcp_cloud_sql_security_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.7"
  },
  {
    "rule_id": "gcp.organization.notifications.essential_contacts_configured",
    "assertion_id": "gcp.organization.notifications",
    "service": "organization",
    "resource_type": "notifications",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Essential Contacts is Configured for Organization",
    "adapter_spec": {
      "function_name": "gcp_organization_essential_contacts_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "1.16"
  },
  {
    "rule_id": "gcp.functions.secrets.secret_manager_used",
    "assertion_id": "gcp.functions.secrets",
    "service": "functions",
    "resource_type": "secrets",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Secrets are Not Stored in Cloud Functions Environment Variables by Using Secret Manager",
    "adapter_spec": {
      "function_name": "gcp_functions_secret_manager_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "1.17"
  },
  {
    "rule_id": "gcp.gke.kubelet.file_permissions_restricted",
    "assertion_id": "gcp.gke.kubelet",
    "service": "gke",
    "resource_type": "kubelet",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the kubelet configuration file has permissions set to 644",
    "adapter_spec": {
      "function_name": "gke_kubelet_file_permissions_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "3.1.3"
  },
  {
    "rule_id": "gcp.gke.cluster.pod_security_standards_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that all Namespaces have Network Policies defined",
    "adapter_spec": {
      "function_name": "gke_pod_security_standards_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.3.2"
  },
  {
    "rule_id": "gcp.gke.cluster.private_nodes_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure clusters are created with Private Nodes",
    "adapter_spec": {
      "function_name": "gke_cluster_private_nodes_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.6.5"
  },
  {
    "rule_id": "gcp.bigquery.dataset.access.public_access_restricted",
    "assertion_id": "gcp.bigquery.dataset",
    "service": "bigquery",
    "resource_type": "dataset",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That BigQuery Datasets Are Not Anonymously or Publicly Accessible",
    "adapter_spec": {
      "function_name": "gcp_bigquery_dataset_public_access_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "7.1"
  },
  {
    "rule_id": "gcp.gke.cluster.container_image_vulnerability_scanning_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Image Vulnerability Scanning is enabled",
    "adapter_spec": {
      "function_name": "gke_container_image_vulnerability_scanning_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.1.1"
  },
  {
    "rule_id": "gcp.gke.cluster.network.policies_enforced",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Enable Security Posture",
    "adapter_spec": {
      "function_name": "gke_network_policies_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "5.7.1"
  },
  {
    "rule_id": "gcp.security.general.ssl.check_ssl_enabled",
    "assertion_id": "gcp.security.general",
    "service": "security",
    "resource_type": "general",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure use of Google-managed SSL Certificates",
    "adapter_spec": {
      "function_name": "gke_autopilot_workload_security_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "5.4.5"
  },
  {
    "rule_id": "gcp.gke.cluster.service_account.default_usage_restricted",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure GKE clusters are not running using the Compute Engine default service account",
    "adapter_spec": {
      "function_name": "gke_cluster_default_service_account_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.2.1"
  },
  {
    "rule_id": "gcp.sql.database.sqlserver.external_scripts_disabled",
    "assertion_id": "gcp.sql.database",
    "service": "sql",
    "resource_type": "database",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure 'external scripts enabled' Database Flag for Cloud SQL SQL Server Instance Is Set to 'off'",
    "adapter_spec": {
      "function_name": "gcp_sql_sqlserver_external_scripts_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.3.1"
  },
  {
    "rule_id": "gcp.gke.cluster.audit_logging_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Apply Security Context to Pods and Containers",
    "adapter_spec": {
      "function_name": "gke_audit_logging_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.6.3"
  },
  {
    "rule_id": "gcp.gke.cluster.control_plane_authorized_networks_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Control Plane Authorized Networks is Enabled",
    "adapter_spec": {
      "function_name": "gke_control_plane_authorized_networks_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.6.3"
  },
  {
    "rule_id": "gcp.network.load_balancer.logging.request_logging_enabled",
    "assertion_id": "gcp.network.load_balancer",
    "service": "network",
    "resource_type": "load_balancer",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Logging is enabled for HTTP(S) Load Balancer",
    "adapter_spec": {
      "function_name": "gcp_load_balancer_logging_enabled_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "2.16"
  },
  {
    "rule_id": "gcp.gke.cluster.pod_security_policies_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the CNI in use supports Network Policies",
    "adapter_spec": {
      "function_name": "gke_pod_security_policies_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.3.1"
  },
  {
    "rule_id": "gcp.kms.key.key_management.automatic_rotation_enabled",
    "assertion_id": "gcp.kms.key",
    "service": "kms",
    "resource_type": "key",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure KMS Encryption Keys Are Rotated Within a Period of 90 Days",
    "adapter_spec": {
      "function_name": "gcp_kms_encryption_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "1.10"
  },
  {
    "rule_id": "gcp.gke.cluster.rbac.anonymous_access_restricted",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Avoid bindings to system:anonymous",
    "adapter_spec": {
      "function_name": "gke_rbac_anonymous_access_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "4.1.8"
  },
  {
    "rule_id": "gcp.gke.cluster.cluster_admin_role.usage_restricted",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the cluster-admin role is only used where required",
    "adapter_spec": {
      "function_name": "gke_cluster_admin_role_usage_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.1.1"
  },
  {
    "rule_id": "gcp.compute.instance.encryption.confidential_computing_data_protection_enabled",
    "assertion_id": "gcp.compute.instance",
    "service": "compute",
    "resource_type": "instance",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That Compute Instances Have Confidential Computing Enabled",
    "adapter_spec": {
      "function_name": "gcp_compute_instance_confidential_computing_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "4.11"
  },
  {
    "rule_id": "gcp.gke.cluster.endpoint.authorized_networks_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Control Plane Authorized Networks is Enabled",
    "adapter_spec": {
      "function_name": "gke_control_plane_authorized_networks_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "5.4.2"
  },
  {
    "rule_id": "gcp.gke.node.auto_repair_enabled",
    "assertion_id": "gcp.gke.node",
    "service": "gke",
    "resource_type": "node",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Node Auto-Repair is enabled for GKE nodes",
    "adapter_spec": {
      "function_name": "gke_node_auto_repair_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.5.2"
  },
  {
    "rule_id": "gcp.security.general.security_key.u2f_enforcement_enabled",
    "assertion_id": "gcp.security.general",
    "service": "security",
    "resource_type": "general",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that Security Key Enforcement is Enabled for All Admin Accounts",
    "adapter_spec": {
      "function_name": "gcp_iam_user_security_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "1.3"
  },
  {
    "rule_id": "gcp.gke.cluster.workload_identity_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Prefer using dedicated GCP Service Accounts and Workload Identity",
    "adapter_spec": {
      "function_name": "gke_cluster_workload_identity_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.2.2"
  },
  {
    "rule_id": "gcp.sql.database.audit.pgaudit_extension_enabled",
    "assertion_id": "gcp.sql.database",
    "service": "sql",
    "resource_type": "database",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That 'cloudsql.enable_pgaudit' Database Flag for each Cloud Sql Postgresql Instance Is Set to 'on' For Centralized Logging",
    "adapter_spec": {
      "function_name": "gcp_sql_postgresql_audit_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.2.8"
  },
  {
    "rule_id": "gcp.gke.cluster.binary_authorization_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure use of Binary Authorization",
    "adapter_spec": {
      "function_name": "gke_cluster_binary_authorization_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.10.4"
  },
  {
    "rule_id": "gcp.services.api_keys.usage.active_services_only",
    "assertion_id": "gcp.services.api_keys",
    "service": "services",
    "resource_type": "api_keys",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure API Keys Only Exist for Active Services",
    "adapter_spec": {
      "function_name": "gcp_services_api_keys_active_services_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "1.12"
  },
  {
    "rule_id": "gcp.gke.kubelet.client_ca_file_configured",
    "assertion_id": "gcp.gke.kubelet",
    "service": "gke",
    "resource_type": "kubelet",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that a Client CA File is Configured",
    "adapter_spec": {
      "function_name": "gke_kubelet_client_ca_file_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "3.2.3"
  },
  {
    "rule_id": "gcp.gke.cluster.readonly_access_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Minimize cluster access to read-only for Container Image repositories",
    "adapter_spec": {
      "function_name": "gke_cluster_readonly_access_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.1.3"
  },
  {
    "rule_id": "gcp.kms.keys.access.public_access_restricted",
    "assertion_id": "gcp.kms.keys",
    "service": "kms",
    "resource_type": "keys",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That Cloud KMS Cryptokeys Are Not Anonymously or Publicly Accessible",
    "adapter_spec": {
      "function_name": "gcp_kms_public_access_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "1.9"
  },
  {
    "rule_id": "gcp.sql.database.mysql.admin_access_restricted",
    "assertion_id": "gcp.sql.database",
    "service": "sql",
    "resource_type": "database",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That a MySQL Instance Does Not Allow Anyone To Connect With Administrative Privileges",
    "adapter_spec": {
      "function_name": "gcp_sql_mysql_admin_access_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.1.1"
  },
  {
    "rule_id": "gcp.gke.cluster.rbac.cluster_admin_role_restricted",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the cluster-admin role is only used where required",
    "adapter_spec": {
      "function_name": "gke_cluster_admin_role_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "4.1.1"
  },
  {
    "rule_id": "gcp.gke.cluster.security_posture_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Enable Security Posture",
    "adapter_spec": {
      "function_name": "gke_security_posture_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.10.5"
  },
  {
    "rule_id": "gcp.gke.kubelet.iptables_util_chains_enabled",
    "assertion_id": "gcp.gke.kubelet",
    "service": "gke",
    "resource_type": "kubelet",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that the --make-iptables-util-chains argument is set to true",
    "adapter_spec": {
      "function_name": "gke_kubelet_iptables_chains_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "3.2.6"
  },
  {
    "rule_id": "gcp.gke.cluster.google_groups_rbac_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Manage Kubernetes RBAC users with Google Groups for GKE",
    "adapter_spec": {
      "function_name": "gke_google_groups_rbac_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.8.2"
  },
  {
    "rule_id": "gcp.compute.instance.access.os_login_authentication_enabled",
    "assertion_id": "gcp.compute.instance",
    "service": "compute",
    "resource_type": "instance",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Oslogin Is Enabled for a Project",
    "adapter_spec": {
      "function_name": "gcp_compute_instance_os_login_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "4.4"
  },
  {
    "rule_id": "gcp.gke.node.container_optimized_required",
    "assertion_id": "gcp.gke.node",
    "service": "gke",
    "resource_type": "node",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Container-Optimized OS (cos_containerd) is used for GKE node images",
    "adapter_spec": {
      "function_name": "gke_node_container_optimized_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "5.5.1"
  },
  {
    "rule_id": "gcp.gke.service_account.default_service_account_restricted",
    "assertion_id": "gcp.gke.service_account",
    "service": "gke",
    "resource_type": "service_account",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure that default service accounts are not actively used",
    "adapter_spec": {
      "function_name": "gke_service_account_default_service_account_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.1.4"
  },
  {
    "rule_id": "gcp.organization.asset_inventory.resource_discovery_enabled",
    "assertion_id": "gcp.organization.asset_inventory",
    "service": "organization",
    "resource_type": "asset_inventory",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Cloud Asset Inventory Is Enabled",
    "adapter_spec": {
      "function_name": "gcp_asset_inventory_enabled_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "2.13"
  },
  {
    "rule_id": "gcp.compute.instance.network.public_ip_restricted",
    "assertion_id": "gcp.compute.instance",
    "service": "compute",
    "resource_type": "instance",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure That Cloud SQL Database Instances Do Not Have Public IPs",
    "adapter_spec": {
      "function_name": "gcp_compute_instance_public_ip_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "6.6"
  },
  {
    "rule_id": "gcp.gke.cluster.container_registry.vulnerability_scanning_enabled",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure Image Vulnerability Scanning is enabled",
    "adapter_spec": {
      "function_name": "gke_image_vulnerability_scanning_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_AUTOPILOT_BENCHMARK_V1.0.0.json",
    "entry_id": "5.1.1"
  },
  {
    "rule_id": "gcp.services.api_keys.restrictions.specific_apis_only",
    "assertion_id": "gcp.services.api_keys",
    "service": "services",
    "resource_type": "api_keys",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Ensure API Keys Are Restricted to Only APIs That Application Needs Access",
    "adapter_spec": {
      "function_name": "gcp_services_api_keys_api_restrictions_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_CLOUD_PLATFORM_FOUNDATION_BENCHMARK_V4.0.0.json",
    "entry_id": "1.14"
  },
  {
    "rule_id": "gcp.gke.cluster.anonymous_binding_restricted",
    "assertion_id": "gcp.gke.cluster",
    "service": "gke",
    "resource_type": "cluster",
    "adapter": "gcp",
    "adapter_evidence_type": "api_response",
    "params": {},
    "pass_condition": "true",
    "severity": "medium",
    "coverage_tier": "standard",
    "rationale": "CIS compliance requirement: Avoid bindings to system:anonymous",
    "adapter_spec": {
      "function_name": "gke_anonymous_binding_check"
    },
    "is_primary": true,
    "source": "cis_compliance_work",
    "file_source": "CIS_GOOGLE_KUBERNETES_ENGINE_GKE_BENCHMARK_V1.7.0.json",
    "entry_id": "4.1.8"
  }
]