#!/usr/bin/env python3
"""
Demo script showing how the GPT analyzer would work with 10 compliance checks
This demonstrates the functionality without requiring an actual API key
"""

import json
import os
from pathlib import Path

def demo_gpt_analysis():
    """Demonstrate the GPT analyzer functionality with sample data"""
    
    print("üß™ Demo: GPT-4o Mini RedHat CIS Compliance Analyzer")
    print("=" * 60)
    print("This demo shows how the analyzer would work with 10 compliance checks")
    print("Note: This is a demonstration - actual API calls require OPENAI_API_KEY")
    print()
    
    # Find a compliance file to work with
    json_files = list(Path(".").glob("*.json"))
    if not json_files:
        print("No JSON files found for demonstration")
        return
    
    # Use the smaller RHEL 6 file for demo
    demo_file = None
    for file in json_files:
        if "RHEL_6" in file.name and "ARCHIVE" in file.name:
            demo_file = file
            break
    
    if not demo_file:
        demo_file = json_files[0]  # Use first available file
    
    print(f"üìÅ Using file: {demo_file.name}")
    
    # Read the file and take first 10 compliance checks
    with open(demo_file, 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    demo_data = data[:10]
    print(f"üìä Selected {len(demo_data)} compliance checks for demonstration")
    print()
    
    # Show the compliance checks that would be analyzed
    print("üîç COMPLIANCE CHECKS TO BE ANALYZED:")
    print("-" * 50)
    for i, item in enumerate(demo_data, 1):
        print(f"{i:2d}. {item.get('id', 'Unknown')}: {item.get('title', 'No title')[:60]}...")
    print()
    
    # Show what the GPT analysis would look like
    print("ü§ñ WHAT GPT-4o MINI WOULD ANALYZE:")
    print("-" * 50)
    print("For each compliance check, GPT would:")
    print("‚Ä¢ Understand the compliance requirement")
    print("‚Ä¢ Analyze the audit command")
    print("‚Ä¢ Review existing function names")
    print("‚Ä¢ Generate the optimal function name")
    print("‚Ä¢ Provide confidence level and reasoning")
    print()
    
    # Show sample GPT analysis output
    print("üìã SAMPLE GPT ANALYSIS OUTPUT:")
    print("-" * 50)
    
    sample_analysis = {
        "results": [
            {
                "compliance_id": "1.1.1.1",
                "function_name": "check_filesystem_cramfs_disabled",
                "confidence": 95,
                "reasoning": "Clear, specific name that indicates filesystem check for cramfs and expected disabled state",
                "compliance_type": "filesystem_security"
            },
            {
                "compliance_id": "1.1.1.2", 
                "function_name": "check_filesystem_freevxfs_disabled",
                "confidence": 95,
                "reasoning": "Consistent naming pattern with other filesystem checks",
                "compliance_type": "filesystem_security"
            },
            {
                "compliance_id": "1.1.1.3",
                "function_name": "check_filesystem_jffs2_disabled", 
                "confidence": 95,
                "reasoning": "Follows established naming convention for filesystem module checks",
                "compliance_type": "filesystem_security"
            }
        ]
    }
    
    print(json.dumps(sample_analysis, indent=2))
    print()
    
    # Show the batch processing approach
    print("‚ö° BATCH PROCESSING APPROACH:")
    print("-" * 50)
    print("‚Ä¢ Process 5 compliance checks per API call")
    print("‚Ä¢ Reduce API calls by ~80% compared to individual calls")
    print("‚Ä¢ Maintain high quality with temperature=0")
    print("‚Ä¢ Intelligent caching for duplicate checks")
    print()
    
    # Show what the final output would look like
    print("üì§ FINAL OUTPUT STRUCTURE:")
    print("-" * 50)
    print("Each compliance check would be updated with:")
    print("‚Ä¢ Optimized function_names array")
    print("‚Ä¢ gpt_analysis section with confidence and reasoning")
    print("‚Ä¢ compliance_type classification")
    print()
    
    # Create demo output file
    demo_output = []
    for i, item in enumerate(demo_data):
        output_item = item.copy()
        output_item['function_names'] = [f"check_compliance_{i+1}_demo"]
        output_item['gpt_analysis'] = {
            'confidence': 95,
            'reasoning': 'Demo analysis - would be generated by GPT-4o Mini',
            'compliance_type': 'demo_check'
        }
        demo_output.append(output_item)
    
    # Save demo output
    demo_output_file = "DEMO_10_CHECKS_ANALYZED.json"
    with open(demo_output_file, 'w', encoding='utf-8') as f:
        json.dump(demo_output, f, indent=2, ensure_ascii=False)
    
    print(f"üíæ Demo output saved to: {demo_output_file}")
    print()
    
    # Show cost estimation
    print("üí∞ COST ESTIMATION:")
    print("-" * 50)
    print("‚Ä¢ Individual API calls: 10 calls")
    print("‚Ä¢ Batch processing: 2 calls (5 checks per call)")
    print("‚Ä¢ Cost savings: ~80% reduction")
    print("‚Ä¢ Quality: Maintained with temperature=0")
    print()
    
    # Show next steps
    print("üöÄ NEXT STEPS TO RUN ACTUAL ANALYSIS:")
    print("-" * 50)
    print("1. Set your OpenAI API key:")
    print("   export OPENAI_API_KEY='your-api-key-here'")
    print()
    print("2. Run the test script:")
    print("   python3 test_optimized_analyzer.py")
    print()
    print("3. Run the full analysis:")
    print("   python3 gpt_compliance_analyzer.py")
    print()
    
    print("üéØ Demo complete! The analyzer is ready to use with your API key.")

if __name__ == "__main__":
    demo_gpt_analysis()
