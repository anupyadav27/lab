[
  {
    "id": "1.1.1.1",
    "title": "Ensure cramfs kernel module is not available",
    "assessment": "Automated",
    "description": "The cramfs filesystem type is a compressed read-only Linux filesystem embedded in small footprint systems. A cramfs image can be used without having to first decompress the image.",
    "rationale": "Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it.",
    "audit": "Run the following script to verify: - IF - the cramfs kernel module is available in ANY installed kernel, verify: • An entry including /bin/true or /bin/false exists in a file within the /etc/modprobe.d/ directory • The module is deny listed in a file within the /etc/modprobe.d/ directory • The module is not loaded in the running kernel - IF - the cramfs kernel module is not available on the system, or pre-compiled into the kernel, no additional configuration is necessary #!/usr/bin/env bash { l_output3=\"\" l_dl=\"\" # clear variables unset a_output; unset a_output2 # unset arrays l_mod_name=\"cramfs\" # set module name l_mod_type=\"fs\" # set module type l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_chk() { l_dl=\"y\" # Set to ignore duplicate checks a_showconfig=() # Create array with modprobe output while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b') if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loaded\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loaded\") fi if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loadable\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loadable\") fi if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is deny listed\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is not deny listed\") fi } for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" [ \"$l_dl\" != \"y\" ] && f_module_chk else a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\") fi done [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\" if [ \"${#a_output2[@]}\" -le 0 ]; then printf '%s\\n' \"\" \"- Audit Result:\" \"  ** PASS **\" \"${a_output[@]}\" else printf '%s\\n' \"\" \"- Audit Result:\" \"  ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\" [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\" fi }",
    "remediation": "Run the following script to unload and disable the cramfs module: - IF - the cramfs kernel module is available in ANY installed kernel: • Create a file ending in .conf with install cramfs /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist cramfs in the /etc/modprobe.d/ directory • Run modprobe -r cramfs 2>/dev/null; rmmod cramfs 2>/dev/null to remove cramfs from the kernel - IF - the cramfs kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary #!/usr/bin/env bash { unset a_output2; l_output3=\"\" l_dl=\"\" # unset arrays and clear variables l_mod_name=\"cramfs\" # set module name l_mod_type=\"fs\" # set module type l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() { l_dl=\"y\" # Set to ignore duplicate checks a_showconfig=() # Create array with modprobe output while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b') if  lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\") modprobe -r \"$l_mod_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '\\binstall\\h+'\"${l_mod_name//- /_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then a_output2+=(\" - setting kernel  module: \\\"$l_mod_name\\\" to \\\"/bin/false\\\"\") printf '%s\\n' \"install $l_mod_name /bin/false\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then a_output2+=(\" - denylisting kernel  module: \\\"$l_mod_name\\\"\") printf '%s\\n' \"blacklist $l_mod_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi } for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" [ \"$l_dl\" != \"y\" ] && f_module_fix else echo -e \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\" fi done [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\" [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\\n' \"${a_output2[@]}\" echo -e \"\\n - remediation of kernel module: \\\"$l_mod_name\\\" complete\\n\" }  References: 1. NIST SP 800-53 Rev. 5: CM-7 2. STIG Finding ID: V-230498",
    "profile_applicability": "•  Level 1 - Server •  Level 1 - Workstation",
    "references": "1. NIST SP 800-53 Rev. 5: CM-7 2. STIG Finding ID: V-230498",
    "function_names": [
      "check_compliance_1_demo"
    ],
    "gpt_analysis": {
      "confidence": 95,
      "reasoning": "Demo analysis - would be generated by GPT-4o Mini",
      "compliance_type": "demo_check"
    }
  },
  {
    "id": "1.1.1.2",
    "title": "Ensure freevxfs kernel module is not available",
    "assessment": "Automated",
    "description": "The freevxfs filesystem type is a free version of the Veritas type filesystem. This is the primary filesystem type for HP-UX operating systems.",
    "rationale": "Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it.",
    "audit": "Run the following script to verify: - IF - the freevxfs kernel module is available in ANY installed kernel, verify: • An entry including /bin/true or /bin/false exists in a file within the /etc/modprobe.d/ directory • The module is deny listed in a file within the /etc/modprobe.d/ directory • The module is not loaded in the running kernel - IF - the freevxfs kernel module is not available on the system, or pre-compiled into the kernel, no additional configuration is necessary #!/usr/bin/env bash { l_output3=\"\" l_dl=\"\" # clear variables unset a_output; unset a_output2 # unset arrays l_mod_name=\"freevxfs\" # set module name l_mod_type=\"fs\" # set module type l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_chk() { l_dl=\"y\" # Set to ignore duplicate checks a_showconfig=() # Create array with modprobe output while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b') if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loaded\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loaded\") fi if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loadable\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loadable\") fi if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is deny listed\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is not deny listed\") fi } for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" [ \"$l_dl\" != \"y\" ] && f_module_chk else a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\") fi done [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\" if [ \"${#a_output2[@]}\" -le 0 ]; then printf '%s\\n' \"\" \"- Audit Result:\" \"  ** PASS **\" \"${a_output[@]}\" else printf '%s\\n' \"\" \"- Audit Result:\" \"  ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\" [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\" fi }",
    "remediation": "Run the following script to unload and disable the freevxfs module: - IF - the freevxfs kernel module is available in ANY installed kernel: • Create a file ending in .conf with install freevxfs /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist freevxfs in the /etc/modprobe.d/ directory • Run modprobe -r freevxfs 2>/dev/null; rmmod freevxfs 2>/dev/null to remove freevxfs from the kernel - IF - the freevxfs kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary #!/usr/bin/env bash { unset a_output2; l_output3=\"\" l_dl=\"\" # unset arrays and clear variables l_mod_name=\"freevxfs\" # set module name l_mod_type=\"fs\" # set module type l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() { l_dl=\"y\" # Set to ignore duplicate checks a_showconfig=() # Create array with modprobe output while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b') if  lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\") modprobe -r \"$l_mod_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '\\binstall\\h+'\"${l_mod_name//- /_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then a_output2+=(\" - setting kernel  module: \\\"$l_mod_name\\\" to \\\"/bin/false\\\"\") printf '%s\\n' \"install $l_mod_name /bin/false\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then a_output2+=(\" - denylisting kernel  module: \\\"$l_mod_name\\\"\") printf '%s\\n' \"blacklist $l_mod_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi } for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" [ \"$l_dl\" != \"y\" ] && f_module_fix else echo -e \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\" fi done [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\" [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\\n' \"${a_output2[@]}\" echo -e \"\\n - remediation of kernel module: \\\"$l_mod_name\\\" complete\\n\" } References: 1. NIST SP 800-53 Rev. 5: CM-7",
    "profile_applicability": "•  Level 1 - Server •  Level 1 - Workstation",
    "references": "1. NIST SP 800-53 Rev. 5: CM-7",
    "function_names": [
      "check_compliance_2_demo"
    ],
    "gpt_analysis": {
      "confidence": 95,
      "reasoning": "Demo analysis - would be generated by GPT-4o Mini",
      "compliance_type": "demo_check"
    }
  },
  {
    "id": "1.1.1.3",
    "title": "Ensure hfs kernel module is not available",
    "assessment": "Automated",
    "description": "The hfs filesystem type is a hierarchical filesystem that allows you to mount Mac OS filesystems.",
    "rationale": "Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it.",
    "audit": "Run the following script to verify: - IF - the hfs kernel module is available in ANY installed kernel, verify: • An entry including /bin/true or /bin/false exists in a file within the /etc/modprobe.d/ directory • The module is deny listed in a file within the /etc/modprobe.d/ directory • The module is not loaded in the running kernel - IF - the hfs kernel module is not available on the system, or pre-compiled into the kernel, no additional configuration is necessary #!/usr/bin/env bash { l_output3=\"\" l_dl=\"\" # clear variables unset a_output; unset a_output2 # unset arrays l_mod_name=\"hfs\" # set module name l_mod_type=\"fs\" # set module type l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_chk() { l_dl=\"y\" # Set to ignore duplicate checks a_showconfig=() # Create array with modprobe output while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b') if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loaded\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loaded\") fi if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loadable\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loadable\") fi if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is deny listed\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is not deny listed\") fi } for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" [ \"$l_dl\" != \"y\" ] && f_module_chk else a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\") fi done [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\" if [ \"${#a_output2[@]}\" -le 0 ]; then printf '%s\\n' \"\" \"- Audit Result:\" \"  ** PASS **\" \"${a_output[@]}\" else printf '%s\\n' \"\" \"- Audit Result:\" \"  ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\" [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\" fi }",
    "remediation": "Run the following script to unload and disable the hfs module: - IF - the hfs kernel module is available in ANY installed kernel: • Create a file ending in .conf with install hfs /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist hfs in the /etc/modprobe.d/ directory • Run modprobe -r hfs 2>/dev/null; rmmod hfs 2>/dev/null to remove hfs from the kernel - IF - the hfs kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary #!/usr/bin/env bash { unset a_output2; l_output3=\"\" l_dl=\"\" # unset arrays and clear variables l_mod_name=\"hfs\" # set module name l_mod_type=\"fs\" # set module type l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() { l_dl=\"y\" # Set to ignore duplicate checks a_showconfig=() # Create array with modprobe output while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b') if  lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\") modprobe -r \"$l_mod_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '\\binstall\\h+'\"${l_mod_name//- /_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then a_output2+=(\" - setting kernel  module: \\\"$l_mod_name\\\" to \\\"/bin/false\\\"\") printf '%s\\n' \"install $l_mod_name /bin/false\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then a_output2+=(\" - denylisting kernel  module: \\\"$l_mod_name\\\"\") printf '%s\\n' \"blacklist $l_mod_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi } for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" [ \"$l_dl\" != \"y\" ] && f_module_fix else echo -e \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\" fi done [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\" [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\\n' \"${a_output2[@]}\" echo -e \"\\n - remediation of kernel module: \\\"$l_mod_name\\\" complete\\n\" } References: 1. NIST SP 800-53 Rev. 5: CM-7",
    "profile_applicability": "•  Level 1 - Server •  Level 1 - Workstation",
    "references": "1. NIST SP 800-53 Rev. 5: CM-7",
    "function_names": [
      "check_compliance_3_demo"
    ],
    "gpt_analysis": {
      "confidence": 95,
      "reasoning": "Demo analysis - would be generated by GPT-4o Mini",
      "compliance_type": "demo_check"
    }
  },
  {
    "id": "1.1.1.4",
    "title": "Ensure hfsplus kernel module is not available",
    "assessment": "Automated",
    "description": "The hfsplus filesystem type is a hierarchical filesystem designed to replace hfs that allows you to mount Mac OS filesystems.",
    "rationale": "Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it.",
    "audit": "Run the following script to verify: - IF - the hfsplus kernel module is available in ANY installed kernel, verify: • An entry including /bin/true or /bin/false exists in a file within the /etc/modprobe.d/ directory • The module is deny listed in a file within the /etc/modprobe.d/ directory • The module is not loaded in the running kernel - IF - the hfsplus kernel module is not available on the system, or pre-compiled into the kernel, no additional configuration is necessary #!/usr/bin/env bash { l_output3=\"\" l_dl=\"\" # clear variables unset a_output; unset a_output2 # unset arrays l_mod_name=\"hfsplus\" # set module name l_mod_type=\"fs\" # set module type l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_chk() { l_dl=\"y\" # Set to ignore duplicate checks a_showconfig=() # Create array with modprobe output while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b') if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loaded\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loaded\") fi if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loadable\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loadable\") fi if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is deny listed\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is not deny listed\") fi } for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" [ \"$l_dl\" != \"y\" ] && f_module_chk else a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\") fi done [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\" if [ \"${#a_output2[@]}\" -le 0 ]; then printf '%s\\n' \"\" \"- Audit Result:\" \"  ** PASS **\" \"${a_output[@]}\" else printf '%s\\n' \"\" \"- Audit Result:\" \"  ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\" [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\" fi }",
    "remediation": "Run the following script to unload and disable the hfsplus module: - IF - the hfsplus kernel module is available in ANY installed kernel: • Create a file ending in .conf with install hfsplus /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist hfsplus in the /etc/modprobe.d/ directory • Run modprobe -r hfsplus 2>/dev/null; rmmod hfsplus 2>/dev/null to remove hfsplus from the kernel - IF - the hfsplus kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary #!/usr/bin/env bash { unset a_output2; l_output3=\"\" l_dl=\"\" # unset arrays and clear variables l_mod_name=\"hfsplus\" # set module name l_mod_type=\"fs\" # set module type l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() { l_dl=\"y\" # Set to ignore duplicate checks a_showconfig=() # Create array with modprobe output while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b') if  lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\") modprobe -r \"$l_mod_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '\\binstall\\h+'\"${l_mod_name//- /_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then a_output2+=(\" - setting kernel  module: \\\"$l_mod_name\\\" to \\\"/bin/false\\\"\") printf '%s\\n' \"install $l_mod_name /bin/false\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then a_output2+=(\" - denylisting kernel  module: \\\"$l_mod_name\\\"\") printf '%s\\n' \"blacklist $l_mod_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi } for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" [ \"$l_dl\" != \"y\" ] && f_module_fix else echo -e \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\" fi done [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\" [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\\n' \"${a_output2[@]}\" echo -e \"\\n - remediation of kernel module: \\\"$l_mod_name\\\" complete\\n\" } References: 1. NIST SP 800-53 Rev. 5: CM-7",
    "profile_applicability": "•  Level 1 - Server •  Level 1 - Workstation",
    "references": "1. NIST SP 800-53 Rev. 5: CM-7",
    "function_names": [
      "check_compliance_4_demo"
    ],
    "gpt_analysis": {
      "confidence": 95,
      "reasoning": "Demo analysis - would be generated by GPT-4o Mini",
      "compliance_type": "demo_check"
    }
  },
  {
    "id": "1.1.1.5",
    "title": "Ensure jffs2 kernel module is not available",
    "assessment": "Automated",
    "description": "The jffs2 (journaling flash filesystem 2) filesystem type is a log-structured filesystem used in flash memory devices.",
    "rationale": "Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it.",
    "audit": "Run the following script to verify: - IF - the jffs2 kernel module is available in ANY installed kernel, verify: • An entry including /bin/true or /bin/false exists in a file within the /etc/modprobe.d/ directory • The module is deny listed in a file within the /etc/modprobe.d/ directory • The module is not loaded in the running kernel - IF - the jffs2 kernel module is not available on the system, or pre-compiled into the kernel, no additional configuration is necessary #!/usr/bin/env bash { l_output3=\"\" l_dl=\"\" # clear variables unset a_output; unset a_output2 # unset arrays l_mod_name=\"jffs2\" # set module name l_mod_type=\"fs\" # set module type l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_chk() { l_dl=\"y\" # Set to ignore duplicate checks a_showconfig=() # Create array with modprobe output while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b') if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loaded\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loaded\") fi if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loadable\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loadable\") fi if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is deny listed\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is not deny listed\") fi } for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" [ \"$l_dl\" != \"y\" ] && f_module_chk else a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\") fi done [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\" if [ \"${#a_output2[@]}\" -le 0 ]; then printf '%s\\n' \"\" \"- Audit Result:\" \"  ** PASS **\" \"${a_output[@]}\" else printf '%s\\n' \"\" \"- Audit Result:\" \"  ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\" [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\" fi }",
    "remediation": "Run the following script to unload and disable the jffs2 module: - IF - the jffs2 kernel module is available in ANY installed kernel: • Create a file ending in .conf with install jffs2 /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist jffs2 in the /etc/modprobe.d/ directory • Run modprobe -r jffs2 2>/dev/null; rmmod jffs2 2>/dev/null to remove jffs2 from the kernel - IF - the jffs2 kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary #!/usr/bin/env bash { unset a_output2; l_output3=\"\" l_dl=\"\" # unset arrays and clear variables l_mod_name=\"jffs2\" # set module name l_mod_type=\"fs\" # set module type l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() { l_dl=\"y\" # Set to ignore duplicate checks a_showconfig=() # Create array with modprobe output while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b') if  lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\") modprobe -r \"$l_mod_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '\\binstall\\h+'\"${l_mod_name//- /_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then a_output2+=(\" - setting kernel  module: \\\"$l_mod_name\\\" to \\\"/bin/false\\\"\") printf '%s\\n' \"install $l_mod_name /bin/false\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then a_output2+=(\" - denylisting kernel  module: \\\"$l_mod_name\\\"\") printf '%s\\n' \"blacklist $l_mod_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi } for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" [ \"$l_dl\" != \"y\" ] && f_module_fix else echo -e \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\" fi done [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\" [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\\n' \"${a_output2[@]}\" echo -e \"\\n - remediation of kernel module: \\\"$l_mod_name\\\" complete\\n\" } References: 1. NIST SP 800-53 Rev. 5: CM-7",
    "profile_applicability": "•  Level 1 - Server •  Level 1 - Workstation",
    "references": "1. NIST SP 800-53 Rev. 5: CM-7",
    "function_names": [
      "check_compliance_5_demo"
    ],
    "gpt_analysis": {
      "confidence": 95,
      "reasoning": "Demo analysis - would be generated by GPT-4o Mini",
      "compliance_type": "demo_check"
    }
  },
  {
    "id": "1.1.1.6",
    "title": "Ensure squashfs kernel module is not available",
    "assessment": "Automated",
    "description": "The squashfs filesystem type is a compressed read-only Linux filesystem embedded in small footprint systems. A squashfs image can be used without having to first decompress the image.",
    "rationale": "Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it. Impact: As Snap packages utilize squashfs as a compressed filesystem, disabling squashfs will cause Snap packages to fail. Snap application packages of software are self-contained and work across a range of Linux distributions. This is unlike traditional Linux package management approaches, like APT or RPM, which require specifically adapted packages per Linux distribution on an application update and delay therefore application deployment from developers to their software's end-user. Snaps themselves have no dependency on any external store (\"App store\"), can be obtained from any source and can be therefore used for upstream software deployment.",
    "audit": "Run the following script to verify: - IF - the squashfs kernel module is available in ANY installed kernel, verify: • An entry including /bin/true or /bin/false exists in a file within the /etc/modprobe.d/ directory • The module is deny listed in a file within the /etc/modprobe.d/ directory • The module is not loaded in the running kernel - IF - the squashfs kernel module is not available on the system, or pre-compiled into the kernel, no additional configuration is necessary #!/usr/bin/env bash { l_output3=\"\" l_dl=\"\" # clear variables unset a_output; unset a_output2 # unset arrays l_mod_name=\"squashfs\" # set module name l_mod_type=\"fs\" # set module type l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_chk() { l_dl=\"y\" # Set to ignore duplicate checks a_showconfig=() # Create array with modprobe output while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b') if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loaded\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loaded\") fi if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loadable\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loadable\") fi if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is deny listed\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is not deny listed\") fi } for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" [ \"$l_dl\" != \"y\" ] && f_module_chk else a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\") fi done [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\" if [ \"${#a_output2[@]}\" -le 0 ]; then printf '%s\\n' \"\" \"- Audit Result:\" \"  ** PASS **\" \"${a_output[@]}\" else printf '%s\\n' \"\" \"- Audit Result:\" \"  ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\" [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\" fi } Note: On operating systems where squashfs is pre-build into the kernel: • This is considered an acceptable \"passing\" state • The kernel should not be re-compiled to remove squashfs • This audit will return a passing state with \"module: \"squashfs\" doesn't exist in ...\"",
    "remediation": "Run the following script to unload and disable the udf module: - IF - the squashfs kernel module is available in ANY installed kernel: • Create a file ending in .conf with install squashfs /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist squashfs in the /etc/modprobe.d/ directory • Run modprobe -r squashfs 2>/dev/null; rmmod squashfs 2>/dev/null to remove squashfs from the kernel - IF - the squashfs kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary #!/usr/bin/env bash { unset a_output2; l_output3=\"\" l_dl=\"\" # unset arrays and clear variables l_mod_name=\"squashfs\" # set module name l_mod_type=\"fs\" # set module type l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() { l_dl=\"y\" # Set to ignore duplicate checks a_showconfig=() # Create array with modprobe output while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b') if  lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\") modprobe -r \"$l_mod_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '\\binstall\\h+'\"${l_mod_name//- /_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then a_output2+=(\" - setting kernel  module: \\\"$l_mod_name\\\" to \\\"/bin/false\\\"\") printf '%s\\n' \"install $l_mod_name /bin/false\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then a_output2+=(\" - denylisting kernel  module: \\\"$l_mod_name\\\"\") printf '%s\\n' \"blacklist $l_mod_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi } for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" [ \"$l_dl\" != \"y\" ] && f_module_fix else echo -e \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\" fi done [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\" [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\\n' \"${a_output2[@]}\" echo -e \"\\n - remediation of kernel module: \\\"$l_mod_name\\\" complete\\n\" } References: 1. NIST SP 800-53 Rev. 5: CM-7",
    "profile_applicability": "•  Level 2 - Server •  Level 2 - Workstation",
    "impact": "As Snap packages utilize squashfs as a compressed filesystem, disabling squashfs will cause Snap packages to fail. Snap application packages of software are self-contained and work across a range of Linux distributions. This is unlike traditional Linux package management approaches, like APT or RPM, which require specifically adapted packages per Linux distribution on an application update and delay therefore application deployment from developers to their software's end-user. Snaps themselves have no dependency on any external store (\"App store\"), can be obtained from any source and can be therefore used for upstream software deployment.",
    "references": "1. NIST SP 800-53 Rev. 5: CM-7",
    "function_names": [
      "check_compliance_6_demo"
    ],
    "gpt_analysis": {
      "confidence": 95,
      "reasoning": "Demo analysis - would be generated by GPT-4o Mini",
      "compliance_type": "demo_check"
    }
  },
  {
    "id": "1.1.1.7",
    "title": "Ensure udf kernel module is not available",
    "assessment": "Automated",
    "description": "The udf filesystem type is the universal disk format used to implement ISO/IEC 13346 and ECMA-167 specifications. This is an open vendor filesystem type for data storage on a broad range of media. This filesystem type is necessary to support writing DVDs and newer optical disc formats.",
    "rationale": "Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it. Impact: Microsoft Azure requires the usage of udf. udf should not be disabled on systems run on Microsoft Azure.",
    "audit": "Run the following script to verify: - IF - the udf kernel module is available in ANY installed kernel, verify: • An entry including /bin/true or /bin/false exists in a file within the /etc/modprobe.d/ directory • The module is deny listed in a file within the /etc/modprobe.d/ directory • The module is not loaded in the running kernel - IF - the udf kernel module is not available on the system, or pre-compiled into the kernel, no additional configuration is necessary #!/usr/bin/env bash { l_output3=\"\" l_dl=\"\" # clear variables unset a_output; unset a_output2 # unset arrays l_mod_name=\"udf\" # set module name l_mod_type=\"fs\" # set module type l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_chk() { l_dl=\"y\" # Set to ignore duplicate checks a_showconfig=() # Create array with modprobe output while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '\\b'\"$l_mod_name\"'\\b') if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loaded\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loaded\") fi if grep -Pq -- '\\binstall\\h+'\"${l_mod_name/-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loadable\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loadable\") fi if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name/-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is deny listed\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is not deny listed\") fi } for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" [ \"$l_dl\" != \"y\" ] && f_module_chk else a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\") fi done [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\" if [ \"${#a_output2[@]}\" -le 0 ]; then printf '%s\\n' \"\" \"- Audit Result:\" \"  ** PASS **\" \"${a_output[@]}\" else printf '%s\\n' \"\" \"- Audit Result:\" \"  ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\" [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\" fi }",
    "remediation": "Run the following script to unload and disable the udf module: - IF - the udf kernel module is available in ANY installed kernel: • Create a file ending in .conf with install udf /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist udf in the /etc/modprobe.d/ directory • Run modprobe -r udf 2>/dev/null; rmmod udf 2>/dev/null to remove udf from the kernel - IF - the udf kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary #!/usr/bin/env bash { unset a_output2; l_output3=\"\" l_dl=\"\" # unset arrays and clear variables l_mod_name=\"udf\" # set module name l_mod_type=\"fs\" # set module type l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() { l_dl=\"y\" # Set to ignore duplicate checks a_showconfig=() # Create array with modprobe output while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b') if  lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\") modprobe -r \"$l_mod_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '\\binstall\\h+'\"${l_mod_name//- /_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then a_output2+=(\" - setting kernel  module: \\\"$l_mod_name\\\" to \\\"/bin/false\\\"\") printf '%s\\n' \"install $l_mod_name /bin/false\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then a_output2+=(\" - denylisting kernel  module: \\\"$l_mod_name\\\"\") printf '%s\\n' \"blacklist $l_mod_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi } for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" [ \"$l_dl\" != \"y\" ] && f_module_fix else echo -e \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\" fi done [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\" [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\\n' \"${a_output2[@]}\" echo -e \"\\n - remediation of kernel module: \\\"$l_mod_name\\\" complete\\n\" } References: 1. NIST SP 800-53 Rev. 5: CM-7",
    "profile_applicability": "•  Level 2 - Server •  Level 2 - Workstation",
    "impact": "Microsoft Azure requires the usage of udf. udf should not be disabled on systems run on Microsoft Azure.",
    "references": "1. NIST SP 800-53 Rev. 5: CM-7",
    "function_names": [
      "check_compliance_7_demo"
    ],
    "gpt_analysis": {
      "confidence": 95,
      "reasoning": "Demo analysis - would be generated by GPT-4o Mini",
      "compliance_type": "demo_check"
    }
  },
  {
    "id": "1.1.1.8",
    "title": "Ensure usb-storage kernel module is not available",
    "assessment": "Automated",
    "description": "USB storage provides a means to transfer and store files ensuring persistence and availability of the files independent of network connection status. Its popularity and utility has led to USB-based malware being a simple and common means for network infiltration and a first step to establishing a persistent threat within a networked environment.",
    "rationale": "Restricting USB access on the system will decrease the physical attack surface for a device and diminish the possible vectors to introduce malware. Impact: Disabling the usb-storage module will disable any usage of USB storage devices. If requirements and local site policy allow the use of such devices, other solutions should be configured accordingly instead. One example of a commonly used solution is USBGuard.",
    "audit": "Run the following script to verify: - IF - the usb-storage kernel module is available in ANY installed kernel, verify: • An entry including /bin/true or /bin/false exists in a file within the /etc/modprobe.d/ directory • The module is deny listed in a file within the /etc/modprobe.d/ directory • The module is not loaded in the running kernel - IF - the usb-storage kernel module is not available on the system, or pre-compiled into the kernel, no additional configuration is necessary #!/usr/bin/env bash { l_output3=\"\" l_dl=\"\" # clear variables unset a_output; unset a_output2 # unset arrays l_mod_name=\"usb-storage\" # set module name l_mod_type=\"drivers\" # set module type l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_chk() { l_dl=\"y\" # Set to ignore duplicate checks a_showconfig=() # Create array with modprobe output while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b') if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loaded\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loaded\") fi if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loadable\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loadable\") fi if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is deny listed\") else a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is not deny listed\") fi } for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" [ \"$l_dl\" != \"y\" ] && f_module_chk else a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\") fi done [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\" if [ \"${#a_output2[@]}\" -le 0 ]; then printf '%s\\n' \"\" \"- Audit Result:\" \"  ** PASS **\" \"${a_output[@]}\" else printf '%s\\n' \"\" \"- Audit Result:\" \"  ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\" [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\" fi }",
    "remediation": "Run the following script to unload and disable the usb-storage module: - IF - the usb-storage kernel module is available in ANY installed kernel: • Create a file ending in .conf with install usb-storage /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with blacklist usb-storage in the /etc/modprobe.d/ directory • Run modprobe -r usb-storage 2>/dev/null; rmmod usb-storage 2>/dev/null to remove usb-storage from the kernel - IF - the usb-storage kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary #!/usr/bin/env bash { unset a_output2; l_output3=\"\" l_dl=\"\" # unset arrays and clear variables l_mod_name=\"usb-storage\" # set module name l_mod_type=\"drivers\" # set module type l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() { l_dl=\"y\" # Set to ignore duplicate checks a_showconfig=() # Create array with modprobe output while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b') if  lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\") modprobe -r \"$l_mod_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '\\binstall\\h+'\"${l_mod_name//- /_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then a_output2+=(\" - setting kernel  module: \\\"$l_mod_name\\\" to \\\"/bin/false\\\"\") printf '%s\\n' \"install $l_mod_name /bin/false\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then a_output2+=(\" - denylisting kernel  module: \\\"$l_mod_name\\\"\") printf '%s\\n' \"blacklist $l_mod_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi } for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" [ \"$l_dl\" != \"y\" ] && f_module_fix else echo -e \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\" fi done [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\" [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\\n' \"${a_output2[@]}\" echo -e \"\\n - remediation of kernel module: \\\"$l_mod_name\\\" complete\\n\" } References: 1. NIST SP 800-53 Rev. 5: SI-3 Additional Information: An alternative solution to disabling the usb-storage module may be found in USBGuard. Use of USBGuard and construction of USB device policies should be done in alignment with site policy.",
    "profile_applicability": "•  Level 1 - Server •  Level 2 - Workstation",
    "impact": "Disabling the usb-storage module will disable any usage of USB storage devices. If requirements and local site policy allow the use of such devices, other solutions should be configured accordingly instead. One example of a commonly used solution is USBGuard.",
    "references": "1. NIST SP 800-53 Rev. 5: SI-3 Additional Information: An alternative solution to disabling the usb-storage module may be found in USBGuard. Use of USBGuard and construction of USB device policies should be done in alignment with site policy.",
    "function_names": [
      "check_compliance_8_demo"
    ],
    "gpt_analysis": {
      "confidence": 95,
      "reasoning": "Demo analysis - would be generated by GPT-4o Mini",
      "compliance_type": "demo_check"
    }
  },
  {
    "id": "1.1.1.9",
    "title": "Ensure unused filesystems kernel modules are not available",
    "assessment": "Manual",
    "description": "Filesystem kernel modules are pieces of code that can be dynamically loaded into the Linux kernel to extend its filesystem capabilities, or so-called base kernel, of an operating system. Filesystem kernel modules are typically used to add support for new hardware (as device drivers), or for adding system calls.",
    "rationale": "While loadable filesystem kernel modules are a convenient method of modifying the running kernel, this can be abused by attackers on a compromised system to prevent detection of their processes or files, allowing them to maintain control over the system. Many rootkits make use of loadable filesystem kernel modules in this way. Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it. The following filesystem kernel modules have known CVE's and should be made unavailable if no dependencies exist: • afs - CVE-2022-37402 • ceph - CVE-2022-0670 • cifs - CVE-2022-29869 • exfat CVE-2022-29973 • ext CVE-2022-1184 • fat CVE-2022-22043 • fscache CVE-2022-3630 • fuse CVE-2023-0386 • gfs2 CVE-2023-3212 • nfs_common CVE-2023-6660 • nfsd CVE-2022-43945 • smbfs_common CVE-2022-2585 Impact: This list may be quite extensive and covering all edges cases is difficult. Therefore, it's crucial to carefully consider the implications and dependencies before making any changes to the filesystem kernel module configurations.",
    "audit": "Run the following script to: • Look at the filesystem kernel modules available to the currently running kernel. • Exclude mounted filesystem kernel modules that don't currently have a CVE • List filesystem kernel modules that are not fully disabled, or are loaded into the kernel Review the generated output #! /usr/bin/env bash { a_output=(); a_output2=(); a_modprope_config=(); a_excluded=(); a_available_modules=() a_ignore=(\"xfs\" \"vfat\" \"ext2\" \"ext3\" \"ext4\") a_cve_exists=(\"afs\" \"ceph\" \"cifs\" \"exfat\" \"ext\" \"fat\" \"fscache\" \"fuse\" \"gfs2\" \"nfs_common\" \"nfsd\" \"smbfs_common\") f_module_chk() { l_out2=\"\"; grep -Pq -- \"\\b$l_mod_name\\b\" <<< \"${a_cve_exists[*]}\" && l_out2=\" <- CVE exists!\" if ! grep -Pq -- '\\bblacklist\\h+'\"$l_mod_name\"'\\b' <<< \"${a_modprope_config[*]}\"; then a_output2+=(\"  - Kernel module: \\\"$l_mod_name\\\" is not fully disabled $l_out2\") elif ! grep -Pq -- '\\binstall\\h+'\"$l_mod_name\"'\\h+\\/bin\\/(false|true)\\b' <<< \"${a_modprope_config[*]}\"; then a_output2+=(\"  - Kernel module: \\\"$l_mod_name\\\" is not fully disabled $l_out2\") fi if lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded l_output2+=(\"  - Kernel module: \\\"$l_mod_name\\\" is loaded\" \"\") fi } while IFS= read -r -d $'\\0' l_module_dir; do a_available_modules+=(\"$(basename \"$l_module_dir\")\") done < <(find \"$(readlink -f /lib/modules/\"$(uname -r)\"/kernel/fs)\" -mindepth 1 -maxdepth 1 - type d ! -empty -print0) while IFS= read -r l_exclude; do if grep -Pq -- \"\\b$l_exclude\\b\" <<< \"${a_cve_exists[*]}\"; then a_output2+=(\"  - ** WARNING: kernel module: \\\"$l_exclude\\\" has a CVE and is currently mounted! **\") elif grep -Pq -- \"\\b$l_exclude\\b\" <<< \"${a_available_modules[*]}\"; then a_output+=(\"  - Kernel module: \\\"$l_exclude\\\" is currently mounted - do NOT unload or disable\") fi ! grep -Pq -- \"\\b$l_exclude\\b\" <<< \"${a_ignore[*]}\" && a_ignore+=(\"$l_exclude\") done < <(findmnt -knD | awk '{print $2}' | sort -u) while IFS= read -r l_config; do a_modprope_config+=(\"$l_config\") done < <(modprobe --showconfig | grep -P '^\\h*(blacklist|install)') for l_mod_name in \"${a_available_modules[@]}\"; do # Iterate over all filesystem modules [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" if grep -Pq -- \"\\b$l_mod_name\\b\" <<< \"${a_ignore[*]}\"; then a_excluded+=(\" - Kernel module: \\\"$l_mod_name\\\"\") else f_module_chk fi done [ \"${#a_excluded[@]}\" -gt 0 ] && printf '%s\\n' \"\" \" -- INFO --\" \\ \"The following intentionally skipped\" \\ \"${a_excluded[@]}\" if [ \"${#a_output2[@]}\" -le 0 ]; then printf '%s\\n' \"\" \"  - No unused filesystem kernel modules are enabled\" \"${a_output[@]}\" \"\" else printf '%s\\n' \"\" \"-- Audit Result: --\" \"  ** REVIEW the following **\" \"${a_output2[@]}\" [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"\" \"-- Correctly set: --\" \"${a_output[@]}\" \"\" fi } WARNING : disabling or denylisting filesystem modules that are in use on the system may be FATAL. It is extremely important to thoroughly review this list.",
    "remediation": "- IF - the module is available in the running kernel: • Unload the filesystem kernel module from the kernel • Create a file ending in .conf with install filesystem kernel modules /bin/false in the /etc/modprobe.d/ directory • Create a file ending in .conf with deny list filesystem kernel modules in the /etc/modprobe.d/ directory WARNING : unloading, disabling or denylisting filesystem modules that are in use on the system maybe FATAL. It is extremely important to thoroughly review the filesystems returned by the audit before following the remediation procedure. Example of unloading the gfs2kernel module: # modprobe -r gfs2 2>/dev/null # rmmod gfs2 2>/dev/null Example of fully disabling the gfs2 kernel module: # printf '%s\\n' \"blacklist gfs2\" \"install gfs2 /bin/false\" >> /etc/modprobe.d/gfs2.conf Note: • Disabling a kernel module by modifying the command above for each unused filesystem kernel module • The example gfs2 must be updated with the appropriate module name for the command or example script below to run correctly. Below is an example Script that can be modified to use on various filesystem kernel modules manual remediation process: Example Script #!/usr/bin/env bash { unset a_output2; l_output3=\"\" l_dl=\"\" # unset arrays and clear variables l_mod_name=\"gfs2\" # set module name l_mod_type=\"fs\" # set module type l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\" f_module_fix() { l_dl=\"y\" # Set to ignore duplicate checks a_showconfig=() # Create array with modprobe output while IFS= read -r l_showconfig; do a_showconfig+=(\"$l_showconfig\") done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b') if  lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\") modprobe -r \"$l_mod_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null fi if ! grep -Pq -- '\\binstall\\h+'\"${l_mod_name//- /_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then a_output2+=(\" - setting kernel  module: \\\"$l_mod_name\\\" to \\\"/bin/false\\\"\") printf '%s\\n' \"install $l_mod_name /bin/false\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi if ! grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then a_output2+=(\" - denylisting kernel  module: \\\"$l_mod_name\\\"\") printf '%s\\n' \"blacklist $l_mod_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf fi } for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\" [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" [ \"$l_dl\" != \"y\" ] && f_module_fix else echo -e \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\" fi done [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\" [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\\n' \"${a_output2[@]}\" echo -e \"\\n - remediation of kernel module: \\\"$l_mod_name\\\" complete\\n\" } References: 1. https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=filesystem",
    "profile_applicability": "•  Level 1 - Server •  Level 1 - Workstation",
    "impact": "This list may be quite extensive and covering all edges cases is difficult. Therefore, it's crucial to carefully consider the implications and dependencies before making any changes to the filesystem kernel module configurations.",
    "references": "1. https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=filesystem",
    "function_names": [
      "check_compliance_9_demo"
    ],
    "gpt_analysis": {
      "confidence": 95,
      "reasoning": "Demo analysis - would be generated by GPT-4o Mini",
      "compliance_type": "demo_check"
    }
  },
  {
    "id": "1.1.2.1.1",
    "title": "Ensure /tmp is a separate partition",
    "assessment": "Automated",
    "description": "The /tmp directory is a world-writable directory used for temporary storage by all users and some applications. - IF - an entry for /tmp exists in /etc/fstab it will take precedence over entries in systemd default unit file. Note: In an environment where the main system is diskless and connected to iSCSI, entries in /etc/fstab may not take precedence. /tmp can be configured to use tmpfs. tmpfs puts everything into the kernel internal caches and grows and shrinks to accommodate the files it contains and is able to swap unneeded pages out to swap space. It has maximum size limits which can be adjusted on the fly via mount -o remount. Since tmpfs lives completely in the page cache and on swap, all tmpfs pages will be shown as \"Shmem\" in /proc/meminfo and \"Shared\" in free. Notice that these counters also include shared memory. The most reliable way to get the count is using df and du. tmpfs has three mount options for sizing: • size: The limit of allocated bytes for this tmpfs instance. The default is half of your physical RAM without swap. If you oversize your tmpfs instances the machine will deadlock since the OOM handler will not be able to free that memory. • nr_blocks: The same as size, but in blocks of PAGE_SIZE. • nr_inodes: The maximum number of inodes for this instance. The default is half of the number of your physical RAM pages, or (on a machine with highmem) the number of lowmem RAM pages, whichever is the lower. These parameters accept a suffix k, m or g and can be changed on remount. The size parameter also accepts a suffix % to limit this tmpfs instance to that percentage of your physical RAM. The default, when neither size nor nr_blocks is specified, is size=50%.",
    "rationale": "Making /tmp its own file system allows an administrator to set additional mount options such as the noexec option on the mount, making /tmp useless for an attacker to install executable code. It would also prevent an attacker from establishing a hard link to a system setuid program and wait for it to be updated. Once the program was updated, the hard link would be broken, and the attacker would have his own copy of the program. If the program happened to have a security vulnerability, the attacker could continue to exploit the known flaw. This can be accomplished by either mounting tmpfs to /tmp, or creating a separate partition for /tmp. Impact: By design files saved to /tmp should have no expectation of surviving a reboot of the system. tmpfs is ram based and all files stored to tmpfs will be lost when the system is rebooted. If files need to be persistent through a reboot, they should be saved to /var/tmp not /tmp. Since the /tmp directory is intended to be world-writable, there is a risk of resource exhaustion if it is not bound to tmpfs or a separate partition. Running out of /tmp space is a problem regardless of what kind of filesystem lies under it, but in a configuration where /tmp is not a separate file system it will essentially have the whole disk available, as the default installation only creates a single / partition. On the other hand, a RAM-based /tmp (as with tmpfs) will almost certainly be much smaller, which can lead to applications filling up the filesystem much more easily. Another alternative is to create a dedicated partition for /tmp from a separate volume or disk. One of the downsides of a disk-based dedicated partition is that it will be slower than tmpfs which is RAM-based.",
    "audit": "Run the following command and verify the output shows that /tmp is mounted. Particular requirements pertaining to mount options are covered in ensuing sections. # findmnt -kn /tmp Example output: /tmp   tmpfs  tmpfs  rw,nosuid,nodev,noexec Ensure that systemd will mount the /tmp partition at boot time. # systemctl is-enabled tmp.mount Example output: generated Verify output is not masked or disabled. Note: By default, systemd will output generated if there is an entry in /etc/fstab for /tmp. This just means systemd will use the entry in /etc/fstab instead of its default unit file configuration for /tmp.",
    "remediation": "First ensure that systemd is correctly configured to ensure that /tmp will be mounted at boot time. # systemctl unmask tmp.mount For specific configuration requirements of the /tmp mount for your environment, modify /etc/fstab. Example of using tmpfs with specific mount options: tmpfs /tmp tmpfs     defaults,rw,nosuid,nodev,noexec,relatime,size=2G  0 0 Note: the size=2G is an example of setting a specific size for tmpfs. Example of using a volume or disk with specific mount options. The source location of the volume or disk will vary depending on your environment: <device> /tmp    <fstype>    defaults,nodev,nosuid,noexec   0 0 References: 1. https://www.freedesktop.org/wiki/Software/systemd/APIFileSystems/ 2. https://www.freedesktop.org/software/systemd/man/systemd-fstab-generator.html 3. https://www.kernel.org/doc/Documentation/filesystems/tmpfs.txt 4. NIST SP 800-53 Rev. 5: CM-7",
    "profile_applicability": "•  Level 1 - Server •  Level 1 - Workstation",
    "impact": "By design files saved to /tmp should have no expectation of surviving a reboot of the system. tmpfs is ram based and all files stored to tmpfs will be lost when the system is rebooted. If files need to be persistent through a reboot, they should be saved to /var/tmp not /tmp. Since the /tmp directory is intended to be world-writable, there is a risk of resource exhaustion if it is not bound to tmpfs or a separate partition. Running out of /tmp space is a problem regardless of what kind of filesystem lies under it, but in a configuration where /tmp is not a separate file system it will essentially have the whole disk available, as the default installation only creates a single / partition. On the other hand, a RAM-based /tmp (as with tmpfs) will almost certainly be much smaller, which can lead to applications filling up the filesystem much more easily. Another alternative is to create a dedicated partition for /tmp from a separate volume or disk. One of the downsides of a disk-based dedicated partition is that it will be slower than tmpfs which is RAM-based.",
    "references": "1. https://www.freedesktop.org/wiki/Software/systemd/APIFileSystems/ 2. https://www.freedesktop.org/software/systemd/man/systemd-fstab-generator.html 3. https://www.kernel.org/doc/Documentation/filesystems/tmpfs.txt 4. NIST SP 800-53 Rev. 5: CM-7",
    "function_names": [
      "check_compliance_10_demo"
    ],
    "gpt_analysis": {
      "confidence": 95,
      "reasoning": "Demo analysis - would be generated by GPT-4o Mini",
      "compliance_type": "demo_check"
    }
  }
]