[
  {
    "id": "1.1.1",
    "title": "Ensure any changes to code are tracked in a version control platform",
    "assessment": "Manual",
    "description": "Manage all code projects in a version control platform.",
    "rationale": "Version control platforms keep track of every modification to code. They represent the cornerstone of code security, as well as allowing for better code collaboration within engineering teams. With granular access management, change tracking, and key signing of code edits, version control platforms are the first step in securing the software supply chain.",
    "audit": "Ensure that all code activity is managed in a GitLab repository for every micro- service or application developed by your organization.",
    "remediation": "Upload existing code projects to a GitLab group or instance and create an identity for each active team member who might contribute or need access to it.",
    "function_names": [
      "code_repository_version_control_enabled",
      "code_repository_commit_history_enabled",
      "code_repository_branch_protection_enabled",
      "code_repository_approval_required",
      "code_repository_code_review_enabled",
      "code_repository_change_tracking_enabled",
      "code_repository_access_control_enabled",
      "code_repository_immutable_history_enabled"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "1.1.2",
    "title": "Ensure any change to code can be traced back to its associated task",
    "assessment": "Manual",
    "description": "Use a task management system to trace any code back to its associated task.",
    "rationale": "The ability to trace each piece of code back to its associated task simplifies the Agile and DevOps process by enabling transparency of any code changes. This allows faster remediation of bugs and security issues, while also making it harder to push unauthorized code changes to sensitive projects. Additionally, using a task management system simplifies achieving compliance, as it is easier to track each regulation.",
    "audit": "Ensure every code change can be traced back to its origin task in a task management system.",
    "remediation": "Use GitLab issues to manage tasks as the starting point for each code change. Whether it is a new feature, bug fix, or security fix - all should originate from a dedicated task (GitLab issue) in your organization's task management system. Tasks (issues) should be linked to Merge Requests, and Merge requests should be linked to Issues. References: 1. https://docs.gitlab.com/ee/user/project/issues/related_issues.html",
    "function_names": [
      "code_repository_commit_task_linked",
      "code_repository_commit_traceable",
      "code_repository_change_task_associated",
      "code_repository_commit_history_tracked",
      "code_repository_task_integration_enabled"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/user/project/issues/related_issues.html"
  },
  {
    "id": "1.1.3",
    "title": "Ensure any change to code receives approval of two strongly authenticated users",
    "assessment": "Automated",
    "description": "Ensure that every code change is reviewed and approved by two authorized contributors who are both strongly authenticated - using Multi-Factor Authentication (MFA), from the team relevant to the code change.",
    "rationale": "To prevent malicious or unauthorized code changes, the first layer of protection is the process of code review. This process involves engineer teammates reviewing each other's code for errors, optimizations, and general knowledge-sharing. With proper peer reviews in place, an organization can detect unwanted code changes very early in the process of release. In order to help facilitate code review, companies should employ automation to verify that every code change has been reviewed and approved by at least two team members before it is pushed into the code base. These team members should be from the team that is related to the code change, so it will be a meaningful review. Impact: To enforce a code review requirement, verification for a minimum of two reviewers must be put into place. This will ensure new code will not be able to be pushed to the code base before it has received two independent approvals.",
    "audit": "For every project in use, perform the next steps to verify that two approvals from the specific project team are required to push new code to the code base: \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Settings > Merge requests. \u2022 In the Merge request approvals section, in the Approval rules section, next to the rule you want to edit, select Edit. \u2022 Review the field In Approvals required, if the number is 2 or above, you are compliant.",
    "remediation": "For every project in use, perform the next steps to require two approvals from the specific project team in order to push new code to the code base: \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Settings > Merge requests. \u2022 In the Merge request approvals section, in the Approval rules section, next to the rule you want to edit, select Edit. \u2022 Edit the field In Approvals required to ensure the value is 2 or above. \u2022 Select Update approval rule. Default Value: 0 References: 1. https://docs.gitlab.com/ee/user/project/merge_requests/approvals/rules.html#edit -an-approval-rule",
    "function_names": [
      "code_repository_change_approval_two_users",
      "code_repository_change_approval_mfa_required",
      "code_repository_change_approval_team_relevant",
      "code_repository_change_approval_strong_auth",
      "code_repository_change_approval_two_strong_auth_users",
      "code_repository_change_approval_mfa_team_relevant",
      "code_repository_change_approval_strong_auth_team_relevant",
      "code_repository_change_approval_two_mfa_users_team_relevant"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "To enforce a code review requirement, verification for a minimum of two reviewers must be put into place. This will ensure new code will not be able to be pushed to the code base before it has received two independent approvals.",
    "references": "1. https://docs.gitlab.com/ee/user/project/merge_requests/approvals/rules.html#edit -an-approval-rule"
  },
  {
    "id": "1.1.4",
    "title": "Ensure previous approvals are dismissed when updates are introduced to a code change proposal",
    "assessment": "Manual",
    "description": "Ensure that when a proposed code change is updated, previous approvals are declined, and new approvals are required.",
    "rationale": "An approval process is necessary when code changes are suggested. Through this approval process, however, changes can still be made to the original proposal even after some approvals have already been given. This means malicious code can find its way into the code base even if the organization has enforced a review policy. To ensure this is not possible, outdated approvals must be declined when changes to the suggestion are introduced. Impact: If new code changes are pushed to a specific proposal, all previously accepted code change proposals must be declined.",
    "audit": "For each code repository in use, perform the next steps to verify that each updated code suggestion declines the previously received approvals: \u2022 On GitLab, navigate to the main page of a repository. \u2022 Navigate to Settings > Merge Requests. \u2022 Click Expand next to the Merge Request Approvals section. \u2022 Verify the repository has merge request approvals configured on all protected branches. \u2022 Verify that \"Remove all approvals\" is selected under Approval Settings for \"When a commit is added\".",
    "remediation": "For each code repository in use, perform the next steps to enforce dismissal of given approvals to code change suggestions if those suggestions were updated: \u2022 On GitLab, navigate to the main page of a repository. \u2022 Navigate to Settings > Merge Requests. \u2022 Click Expand next to the Merge Request Approvals section. \u2022 Configure approval rules and a list of eligible approvers for all protected branches (or all branches). \u2022 Select Remove all approvals under \"When a commit is added\". \u2022 Click Save changes References: 1. https://docs.gitlab.com/ee/user/project/merge_requests/approvals/rules.html",
    "function_names": [
      "code_review_approvals_dismissed_on_update",
      "code_change_proposal_approvals_reset_on_update",
      "pull_request_approvals_invalidated_on_update",
      "code_review_approvals_require_reapproval_on_update",
      "code_change_approvals_revoked_on_modification",
      "pull_request_approvals_cleared_on_update",
      "code_review_approvals_expired_on_change",
      "code_change_proposal_approvals_revoked_on_update"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "If new code changes are pushed to a specific proposal, all previously accepted code change proposals must be declined.",
    "references": "1. https://docs.gitlab.com/ee/user/project/merge_requests/approvals/rules.html"
  },
  {
    "id": "1.1.5",
    "title": "Ensure there are restrictions on who can dismiss code change reviews",
    "assessment": "Manual",
    "description": "Only trusted users should be allowed to dismiss code change reviews.",
    "rationale": "Dismissing a code change review permits users to merge new suggested code changes without going through the standard process of approvals. Controlling who can perform this action will prevent malicious actors from simply dismissing the required reviews to code changes and merging malicious or dysfunctional code into the code base. Impact: In cases where a code change proposal has been updated since it was last reviewed and the person who reviewed it isn't available for approval, a general collaborator would not be able to merge their code changes until a user with \"dismiss review\" abilities could dismiss the open review. Users who are not allowed to dismiss code change reviews will not be permitted to do so, and thus are unable to waive the standard flow of approvals.",
    "audit": "For each code repository in use, perform the next steps to verify that only trusted users are allowed to dismiss code change reviews: To verify that restrictions are in place around who can dismiss code change reviews, view your branch protection settings for a project. You must have at least the Maintainer role. 1. On the left sidebar, select Search or go to and find your project. 2. Select Settings > Repository. 3. Expand Protected branches.",
    "remediation": "Prerequisites: You must have at least the Maintainer role. When granting a group Allowed to merge or Allowed to push and merge permissions on a protected branch, the group must be added to the project. To protect a branch: 1. On the left sidebar, select Search or go to and find your project. 2. Select Settings > Repository. 3. Expand Protected branches. 4. Select Add protected branch. 5. From the Branch dropdown list, select the branch you want to protect. 6. From the Allowed to merge list, select a role that can merge into this branch. 7. From the Allowed to push and merge list, select a role that can push to this branch. In GitLab Premium and Ultimate, you can also add groups or individual users to Allowed to merge and Allowed to push and merge. Select Protect. The protected branch displays in the list of protected branches. Default Value: By default, all users who have write access to the code repository are able to dismiss code change reviews. References: 1. https://docs.gitlab.com/ee/user/project/protected_branches.html",
    "profile_applicability": "\u2022  Level 1",
    "impact": "In cases where a code change proposal has been updated since it was last reviewed and the person who reviewed it isn't available for approval, a general collaborator would not be able to merge their code changes until a user with \"dismiss review\" abilities could dismiss the open review. Users who are not allowed to dismiss code change reviews will not be permitted to do so, and thus are unable to waive the standard flow of approvals.",
    "references": "1. https://docs.gitlab.com/ee/user/project/protected_branches.html"
  },
  {
    "id": "1.1.6",
    "title": "Ensure code owners are set for extra sensitive code or configuration",
    "assessment": "Manual",
    "description": "Code owners are trusted users that are responsible for reviewing and managing an important piece of code or configuration. An organization is advised to set code owners for every extremely sensitive code or configuration.",
    "rationale": "Configuring code owners protects data by verifying that trusted users will notice and review every edit, thus preventing unwanted or malicious changes from potentially compromising sensitive code or configurations. Impact: Code owner users will receive notifications for every change that occurs to the code and subsequently added as reviewers of pull requests automatically.",
    "audit": "In every project, view the Code Owners of a file or directory: 1. On the left sidebar, select Search or go to and find your project. 2. Select Code > Repository. 3. Go to the file or directory you want to see the Code Owners for. 4. Optional. Select a branch or tag. GitLab shows the Code Owners at the top of the page.",
    "remediation": "Prerequisite: You must be able to either push to the default branch or create a merge request. 1. Create a CODEOWNERS file in your preferred location. 2. Define some rules in the file following the Code Owners syntax reference. Some suggestions: o Configure All eligible approvers approval rule. o Require Code Owner approval on a protected branch. 3. Commit your changes, and push them up to GitLab.  Default Value: None References: 1. https://docs.gitlab.com/ee/user/project/codeowners/",
    "function_names": [
      "code_repository_owner_defined",
      "code_repository_owner_required",
      "code_repository_owner_sensitive_defined",
      "code_repository_owner_sensitive_required",
      "code_repository_owner_high_risk_defined",
      "code_repository_owner_high_risk_required",
      "code_repository_owner_extra_sensitive_defined",
      "code_repository_owner_extra_sensitive_required"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Code owner users will receive notifications for every change that occurs to the code and subsequently added as reviewers of pull requests automatically.",
    "references": "1. https://docs.gitlab.com/ee/user/project/codeowners/"
  },
  {
    "id": "1.1.7",
    "title": "Ensure code owner's review is required when a change affects owned code",
    "assessment": "Manual",
    "description": "Ensure trusted code owners are required to review and approve any code change proposal made to their respective owned areas in the code base.",
    "rationale": "Configuring code owners ensures that no code, especially code which could prove malicious, will slip into the source code or configuration files of a repository. This allows an organization to mark areas in the code base that are especially sensitive or more prone to an attack. It can also enforce review by specific individuals who are designated as owners to those areas so that they may filter out unauthorized or unwanted changes beforehand. Impact: If an organization enforces code owner-based reviews, some code change proposals would not be able to be merged to the codebase before specific, trusted individuals approve them.",
    "audit": "With merge request approval rules, you can set the minimum number of required approvals by code owners before work can merge into your project. 1. On the left sidebar, select Search or go to and find your project. 2. Select Settings > Repository . 3. Expand Protected branches . 4. Next to the default branch, turn on the toggle under Code owner approval .",
    "remediation": "Prerequisites: \u2022 You must have at least the Maintainer role for the project. \u2022 To add a group as an approver in GitLab.com, you must be a member of the group or the group must be public. To add a merge request approval rule: 1. On the left sidebar, select Search or go to and find your project. 2. Select Settings > Merge requests . 3. In the Merge request approvals section, in the Approval rules section, select Add approval rule . 4. Complete the fields: o In Approvals required , a value of 0 makes the rule optional, and any number greater than 0 creates a required rule. Maximum number of required approvals is 100. o From Add approvers , select users or groups that are eligible to approve. GitLab suggests approvers based on previous authors of the files changed by the merge request. 5. Select Add approval rule . You can add multiple approval rules. Default Value: Code owners are not required to review changes by default. References: 1. https://docs.gitlab.com/ee/user/project/merge_requests/approvals/ 2. https://docs.gitlab.com/ee/user/project/merge_requests/approvals/rules.html 3. https://docs.gitlab.com/ee/user/project/codeowners/index.html",
    "function_names": [
      "code_repository_code_owner_review_required",
      "code_repository_change_approval_required",
      "code_repository_owned_code_review_enabled",
      "code_repository_trusted_owner_approval_enabled",
      "code_repository_code_change_review_required"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "If an organization enforces code owner-based reviews, some code change proposals would not be able to be merged to the codebase before specific, trusted individuals approve them.",
    "references": "1. https://docs.gitlab.com/ee/user/project/merge_requests/approvals/ 2. https://docs.gitlab.com/ee/user/project/merge_requests/approvals/rules.html 3. https://docs.gitlab.com/ee/user/project/codeowners/index.html"
  },
  {
    "id": "1.1.8",
    "title": "Ensure inactive branches are periodically reviewed and removed",
    "assessment": "Manual",
    "description": "Keep track of code branches that are inactive for a lengthy period of time and periodically remove them.",
    "rationale": "Git branches that have been inactive (i.e., no new changes introduced) for a long period of time are enlarging the surface of attack for malicious code injection, sensitive data leaks, and CI pipeline exploitation. They potentially contain outdated dependencies which may leave them highly vulnerable. They are more likely to be improperly managed, and could possibly be accessed by a large number of members of the organization. Impact: Removing inactive Git branches means that any code changes they contain would be removed along with them, thus work done in the past might not be accessible after auditing for inactivity.",
    "audit": "For each project, verify that all existing Git branches are active or have yet to be checked for inactivity by performing the next steps: \u2022 Navigate to the main page of the project. \u2022 In the sidebar select Code > Branches \u2022 Use the navigation at the top of the page to view the Stale branches. The Stale view shows all branches that no one has committed to in the last three months, ordered by the branches with the oldest commits first. \u2022 If the list is empty, you are compliant. If the list is not empty, but there is a valid reason the branches listed are not deleted, you are compliant. You can perform the next steps to verify that merge request branches are prevented from becoming stale branches by default: \u2022 Navigate to the main page of the project. \u2022 In the left sidebar select Settings > Merge requests \u2022 Verify if 'Enable \"Delete source branch\" option by default' is selected. If it is not selected, you are more likely to become non-compliant.",
    "remediation": "For each project, review existing Git branches and remove those which were identified during the audit as being non-compliant by performing the following: \u2022 Navigate to the main page of the project. \u2022 In the sidebar select Code > Branches \u2022 Next to each non-compliant branch select the vertical ellipsis \u2022 Select 'Delete branch' \u2022 Read the warning \u2022 Select 'Yes, delete branch' You can perform the next steps to reduce the likelihood of a stale branches remaining after a merge request: \u2022 Navigate to the main page of the project. \u2022 In the left sidebar select Settings > Merge requests \u2022 Select 'Enable \"Delete source branch\" option by default'. Default Value: By default, newly opened Git branches would never be removed, regardless of activity or inactivity. References: 1. https://docs.gitlab.com/ee/user/project/repository/branches/",
    "function_names": [
      "code_repository_branch_inactive_reviewed_over_90d",
      "code_repository_branch_inactive_removed_over_90d",
      "code_repository_branch_activity_monitored_periodically",
      "code_repository_branch_inactive_cleanup_enabled",
      "code_repository_branch_lifecycle_policy_enforced"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Removing inactive Git branches means that any code changes they contain would be removed along with them, thus work done in the past might not be accessible after auditing for inactivity.",
    "references": "1. https://docs.gitlab.com/ee/user/project/repository/branches/"
  },
  {
    "id": "1.1.9",
    "title": "Ensure all checks have passed before merging new code",
    "assessment": "Manual",
    "description": "Before a code change request can be merged to the code base, all predefined checks must successfully pass.",
    "rationale": "On top of manual reviews of code changes, a code protect should contain a set of prescriptive checks which validate each change. Organizations should enforce those status checks so that changes can only be introduced if all checks have successfully passed. This set of checks should serve as the absolute quality, stability, and security conditions which must be met in order to merge new code to a project. Impact: Code changes in which all checks do not pass successfully would not be able to be pushed into the code base of the specific code repository.",
    "audit": "Within each project\u2019s settings, you can see a list of status check services added to the project: 1. In your project, go to Settings > Merge requests section. 2. Scroll down to Status checks . 3. Ensure that the Status checks must succeed checkbox has been selected.",
    "remediation": "To block the merging of merge requests when checks fail: 1. On the left sidebar, select Search or go to and find your project. 2. Select Settings > Merge requests . 3. Select the Status checks must succeed checkbox. 4. Select Save changes . Default Value: By default, no checks are defined per project, and thus no enforcement of checks is made.  References: 1. https://docs.gitlab.com/ee/user/project/merge_requests/status_checks.html",
    "function_names": [
      "code_repository_merge_checks_passed",
      "code_repository_merge_requirements_satisfied",
      "code_repository_pre_merge_validation_successful",
      "code_repository_merge_approval_checks_completed",
      "code_repository_merge_conditions_met",
      "code_repository_merge_prerequisites_fulfilled",
      "code_repository_merge_quality_gate_passed",
      "code_repository_merge_compliance_checks_passed"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Code changes in which all checks do not pass successfully would not be able to be pushed into the code base of the specific code repository.",
    "references": "1. https://docs.gitlab.com/ee/user/project/merge_requests/status_checks.html"
  },
  {
    "id": "1.1.10",
    "title": "Ensure open Git branches are up to date before they can be merged into code base",
    "assessment": "Manual",
    "description": "Organizations should make sure each suggested code change is in full sync with the existing state of its origin code repository before allowing merging.",
    "rationale": "Git branches can easily become outdated since the origin code repository is constantly being edited. This means engineers working on separate code branches can accidentally include outdated code with potential security issues which might have already been fixed, overriding the potential solutions for those security issues when merging their own changes. Impact: If enforced, outdated branches would not be able to be merged into their origin repository without first being updated to contain any recent changes.",
    "audit": "For each project, verify that open branches must be updated before merging by performing the following: \u2022 Navigate to the main page of the project \u2022 In the sidebar, select Settings > Merge requests \u2022 Look at the 'Merge method'. If 'Merge commit with semi-linear history' or 'Fast- forward merge' is selected, the project is compliant.",
    "remediation": "For each project identified as being non-compliant, performing the following: \u2022 Navigate to the main page of the project \u2022 In the sidebar, select Settings > Merge requests \u2022 Under the 'Merge method' select either 'Merge commit with semi-linear history' or 'Fast-forward merge'. Default Value: By default, there is no requirement to update a branch before merging it.  References: 1. https://docs.gitlab.com/ee/user/project/merge_requests/methods/",
    "function_names": [
      "git_branch_up_to_date_before_merge",
      "git_branch_sync_with_main_before_merge",
      "git_branch_rebase_required_before_merge",
      "git_branch_merge_conflict_free",
      "git_branch_latest_commit_before_merge",
      "git_branch_ci_checks_passed_before_merge",
      "git_branch_approval_required_before_merge",
      "git_branch_status_checks_enabled_before_merge"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "If enforced, outdated branches would not be able to be merged into their origin repository without first being updated to contain any recent changes.",
    "references": "1. https://docs.gitlab.com/ee/user/project/merge_requests/methods/"
  },
  {
    "id": "1.1.11",
    "title": "Ensure all open comments are resolved before allowing code change merging",
    "assessment": "Manual",
    "description": "Organizations should enforce a \"no open comments\" policy before allowing code change merging.",
    "rationale": "In an open code change proposal, reviewers can leave comments containing their questions and suggestions. These comments can also include potential bugs and security issues. Requiring all comments on a code change proposal to be resolved before it can be merged ensures that every concern is properly addressed or acknowledged before the new code changes are introduced to the code base. Impact: Code change proposals containing open comments would not be able to be merged into the code base.",
    "audit": "Ensure that All threads must be resolved before changes in a branch can be merged. To review these settings: 1. On the left sidebar, select Search or go to and find your project. 2. Select Settings > Merge requests . 3. In the Merge checks section, check to see that the All threads must be resolved checkbox has been selected.",
    "remediation": "You can prevent merge requests from being merged until all threads are resolved. When this setting is enabled, the Unresolved threads counter in a merge request is shown in orange when at least one thread remains unresolved. 1. On the left sidebar, select Search or go to and find your project. 2. Select Settings > Merge requests . 3. In the Merge checks section, select the All threads must be resolved checkbox. 4. Select Save changes .  Default Value: By default, code changes with open comments on them are able to be merged into the code base. References: 1. https://docs.gitlab.com/ee/user/project/merge_requests/index.html#prevent- merge-unless-all-threads-are-resolved",
    "function_names": [
      "code_repository_comments_resolved_before_merge",
      "code_repository_merge_no_open_comments",
      "code_repository_change_approval_comments_resolved",
      "code_repository_pr_no_open_comments_before_merge",
      "code_repository_merge_request_comments_closed"
    ],
    "profile_applicability": "\u2022  Level 2",
    "impact": "Code change proposals containing open comments would not be able to be merged into the code base.",
    "references": "1. https://docs.gitlab.com/ee/user/project/merge_requests/index.html#prevent- merge-unless-all-threads-are-resolved"
  },
  {
    "id": "1.1.12",
    "title": "Ensure verification of signed commits for new changes before merging",
    "assessment": "Manual",
    "description": "Ensure every commit in a pull request is signed and verified before merging.",
    "rationale": "Signing commits, or requiring to sign commits, gives other users confidence about the origin of a specific code change. It ensures that the author of the change is not hidden and is verified by the version control system, thus the change comes from a trusted source. Impact: Pull requests with unsigned commits cannot be merged.",
    "audit": "Identify which projects permit unsigned commits by performing the following steps for each project: \u2022 Navigate to the main page of the project. \u2022 In the sidebar, select Settings > Repository. \u2022 Expand the Push rules section. \u2022 Identify the Select push rules section. \u2022 If 'Reject unsigned commits' is selected the project is compliant.",
    "remediation": "Ensure only signed commits can be merged for every branch via branch protection rules by performing the following steps for each project: \u2022 Navigate to the main page of the project. \u2022 In the sidebar, select Settings > Repository. \u2022 Expand the Push rules section. \u2022 Under Select push rules select 'Reject unsigned commits'. \u2022 Select 'Save push rules'. As an administrator you can configure a secure default for new projects by performing the following steps: \u2022 Navigate to the Admin Area. \u2022 In the sidebar, select Push Rules. \u2022 Select 'Reject unsigned commits'. \u2022 Select 'Save push rules'. References: 1. https://docs.gitlab.com/ee/user/project/repository/push_rules.html",
    "function_names": [
      "git_repository_signed_commits_required",
      "git_repository_commit_verification_enabled",
      "git_repository_merge_verification_enabled",
      "git_repository_signed_commits_before_merge",
      "git_repository_commit_signing_enforced",
      "git_repository_merge_commit_verification_required",
      "git_repository_signed_commits_policy_enabled",
      "git_repository_commit_verification_before_merge"
    ],
    "profile_applicability": "\u2022  Level 2",
    "impact": "Pull requests with unsigned commits cannot be merged.",
    "references": "1. https://docs.gitlab.com/ee/user/project/repository/push_rules.html"
  },
  {
    "id": "1.1.13",
    "title": "Ensure linear history is required",
    "assessment": "Manual",
    "description": "Linear history is the name for Git history where all commits are listed in chronological order, one after another. Such history exists if a pull request is merged either by rebase merge (re-order the commits history) or squash merge (squashes all commits to one). Ensure that linear history is required by requiring the use of rebase or squash merge when merging a pull request.",
    "rationale": "Enforcing linear history produces a clear record of activity, and as such it offers specific advantages: it is easier to follow, easier to revert a change, and bugs can be found more easily. Impact: Pull request cannot be merged except squash or rebase merge.",
    "audit": "For every project, perform the following steps: \u2022 Navigate to your project \u2022 In the sidebar, select Settings > Repository \u2022 Under 'Merge method', if 'Merge Commit' or 'Merge commit with semi-linear history' is selected then the project is not-compliant.",
    "remediation": "For every project, perform the following steps: \u2022 Navigate to your project \u2022 In the sidebar, select Settings > Repository \u2022 Under 'Merge method', select 'Fast-forward merge'. References: 1. https://docs.gitlab.com/ee/user/project/merge_requests/methods/",
    "function_names": [
      "git_repository_linear_history_required",
      "git_repository_rebase_merge_required",
      "git_repository_squash_merge_required",
      "git_repository_merge_strategy_restricted",
      "git_repository_non_linear_history_blocked"
    ],
    "profile_applicability": "\u2022  Level 2",
    "impact": "Pull request cannot be merged except squash or rebase merge.",
    "references": "1. https://docs.gitlab.com/ee/user/project/merge_requests/methods/"
  },
  {
    "id": "1.1.14",
    "title": "Ensure branch protection rules are enforced for administrators",
    "assessment": "Manual",
    "description": "Ensure administrators are subject to branch protection rules.",
    "rationale": "Administrators by default are excluded from any branch protection rules. This means these privileged users (both on the repository and organization levels) are not subject to protections meant to prevent untrusted code insertion, including malicious code. This is extremely important since administrator accounts are often targeted for account hijacking due to their privileged role. Impact: Administrator users won't be able to push code directly to the protected branch without being compliant with listed branch protection rules.",
    "audit": "GitLab administrators can validate this privilege for group owners, enforcing the instance-level protection rule: 1. Select Settings > Repository. 2. On the left sidebar, at the bottom, select Admin Area. 3. Expand the Default branch section. 4. Ensure that the Allow owners to manage default branch protection per group is unchecked. 5. Select Save changes.",
    "remediation": "GitLab administrators can disable this privilege for group owners, enforcing the instance-level protection rule: 1. On the left sidebar, at the bottom, select Admin Area. 2. Select Settings > Repository. 3. Expand the Default branch section. 4. Uncheck Allow owners to manage default branch protection per group checkbox. 5. Select Save changes.  Default Value: Administrator accounts are not subject to branch protection rules by default. References: 1. https://docs.gitlab.com/ee/user/project/repository/branches/default.html 2. https://docs.gitlab.com/ee/user/project/protected_branches.html#who-can- modify-a-protected-branch",
    "function_names": [
      "github_repository_branch_protection_admin_enforced",
      "github_repository_admin_branch_restrictions_enabled",
      "github_branch_protection_admin_compliance_required",
      "github_repository_admin_branch_protection_enabled",
      "github_branch_admin_protection_rules_enforced"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Administrator users won't be able to push code directly to the protected branch without being compliant with listed branch protection rules.",
    "references": "1. https://docs.gitlab.com/ee/user/project/repository/branches/default.html 2. https://docs.gitlab.com/ee/user/project/protected_branches.html#who-can- modify-a-protected-branch"
  },
  {
    "id": "1.1.15",
    "title": "Ensure pushing or merging of new code is restricted to specific individuals or teams",
    "assessment": "Manual",
    "description": "Ensure that only trusted users can push or merge new code to protected branches.",
    "rationale": "Requiring that only trusted users may push or merge new changes reduces the risk of unverified code, especially malicious code, to a protected branch by reducing the number of trusted users who are capable of doing such. Impact: Only administrators and trusted users can push or merge to the protected branch.",
    "audit": "For every code repository in use, ensure only trusted and responsible users can push or merge new code by performing the following: 1. On the left sidebar, select Search or go to and find your project. 2. Select Settings > Repository. 3. Expand Protected branches. 4. If there are no protected branches, the repository is not compliant. 5. For each protected branch, ensure: 1. The role(s) and user(s) who are 'Allowed to merge' are trusted 2. The role(s) and user(s) who are 'Allowed to push and merge' are trusted 3. The 'Allowed to force push' toggle is not selected",
    "remediation": "Prerequisites: You must have at least the Maintainer role in the group. For every code repository in use, allow only trusted and responsible users to push or merge new code by performing the following: 1. On the left sidebar, select Search or go to and find your project. 2. Select Settings > Repository. 3. Expand Protected branches. 4. Select Add protected branch. 5. From the Branch dropdown list, select the branch you want to protect. 6. From the Allowed to merge list, select a role that can merge into this branch. 7. From the Allowed to push and merge list, select a role that can push to this branch. References: 1. https://docs.gitlab.com/ee/administration/merge_requests_approvals.html",
    "function_names": [
      "git_repository_push_restricted_to_trusted_users",
      "git_repository_merge_restricted_to_trusted_teams",
      "git_branch_protection_push_restricted",
      "git_branch_protection_merge_restricted",
      "git_repository_protected_branch_access_controlled",
      "git_branch_protection_trusted_users_only",
      "git_branch_protection_trusted_teams_only",
      "git_repository_protected_branch_push_restricted",
      "git_repository_protected_branch_merge_restricted",
      "git_branch_protection_push_merge_restricted_to_trusted_entities"
    ],
    "profile_applicability": "\u2022  Level 2",
    "impact": "Only administrators and trusted users can push or merge to the protected branch.",
    "references": "1. https://docs.gitlab.com/ee/administration/merge_requests_approvals.html"
  },
  {
    "id": "1.1.16",
    "title": "Ensure force push code to branches is denied",
    "assessment": "Manual",
    "description": "The \"Force Push\" option allows users with \"Push\" permissions to force their changes directly to the branch without a pull request, and thus should be disabled.",
    "rationale": "The \"Force Push\" option allows users to override the existing code with their own code. This can lead to both intentional and unintentional data loss, as well as data infection with malicious code. Disabling the \"Force Push\" option prohibits users from forcing their changes to the master branch, which ultimately prevents malicious code from entering source code. Impact: Users cannot force push to protected branches.",
    "audit": "For every code repository in use, validate that no one can force push code by performing the following: \u2022 On GitLab, navigate to the main page of the repository. \u2022 Navigate to Settings > Repository . \u2022 Click Expand next to the Protected Branches section. \u2022 Verify that your repository's main (or default) branch is protected. \u2022 Verify that \"Allowed to force push\" is toggled off.",
    "remediation": "For each repository in use, block the option to \"Force Push\" code by performing the following: \u2022 On GitLab, navigate to the main page of the repository. \u2022 Navigate to Settings > Repository . \u2022 Click Expand next to the Protected Branches section. \u2022 Ensure your project's default branch is protected. \u2022 Toggle \"Allowed to force push\" off. References: 1. https://docs.gitlab.com/ee/user/project/protected_branches.html",
    "function_names": [
      "git_branch_force_push_denied",
      "git_branch_force_push_disabled",
      "git_branch_protection_force_push_blocked",
      "git_repository_force_push_restricted",
      "git_branch_force_push_prevention_enabled"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Users cannot force push to protected branches.",
    "references": "1. https://docs.gitlab.com/ee/user/project/protected_branches.html"
  },
  {
    "id": "1.1.17",
    "title": "Ensure branch deletions are denied",
    "assessment": "Manual",
    "description": "Ensure that users with only push access are incapable of deleting a protected branch.",
    "rationale": "When enabling deletion of a protected branch, any user with at least push access to the repository can delete a branch. This can be potentially dangerous, as a simple human mistake or a hacked account can lead to data loss if a branch is deleted. It is therefore crucial to prevent such incidents by denying protected branch deletion. Impact: Protected branches cannot be deleted.",
    "audit": "For each repository that is being used, verify that protected branches cannot be deleted by performing the following: View your protected branches by going to the left sidebar and selecting Search or go to and find your project. Select Settings > Repository. Expand Protected branches to view a list of protected branches.",
    "remediation": "For each repository that is being used, protect a branch in order to block the option to delete branches. To protect a branch for one project: 1. On the left sidebar, select Search or go to and find your project. 2. Select Settings > Repository . 3. Expand Protected branches . 4. Select Add protected branch . 5. From the Branch dropdown list, select the branch you want to protect. 6. From the Allowed to merge list, select a role that can merge into this branch. 7. From the Allowed to push and merge list, select a role that can push to this branch. Group owners can create protected branches at the group level. These settings are inherited by all projects in the group and can\u2019t be overridden by project settings. If a specific branch is configured with Allowed to force push settings at both the group and project levels, the Allowed to force push setting at the project level is ignored in favor of the group level setting. Prerequisites: \u2022 You must have the Owner role in the group. To protect a branch for all the projects in a group: 1. On the left sidebar, select Search or go to and find your group. 2. Select Settings > Repository . 3. Expand Protected branches . 4. Select Add protected branch . 5. In the Branch text box, type the branch name or a wildcard. Branch names and wildcards are case-sensitive. 6. From the Allowed to merge list, select a role that can merge into this branch. 7. From the Allowed to push and merge list, select a role that can push to this branch. 8. Select Protect . References: 1. https://docs.gitlab.com/ee/user/project/protected_branches.html",
    "function_names": [
      "git_branch_delete_denied",
      "git_protected_branch_delete_restricted",
      "git_branch_push_only_no_delete",
      "git_protected_branch_delete_denied",
      "git_branch_delete_permission_restricted"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Protected branches cannot be deleted.",
    "references": "1. https://docs.gitlab.com/ee/user/project/protected_branches.html"
  },
  {
    "id": "1.1.18",
    "title": "Ensure any merging of code is automatically scanned for risks",
    "assessment": "Manual",
    "description": "Ensure that every pull request is required to be scanned for risks.",
    "rationale": "Scanning pull requests to detect risks allows for early detection of vulnerable code and/or dependencies and helps mitigate potentially malicious code.",
    "audit": "For each project in use, ensure that every merge request must be scanned for risks by performing the following: 1. On the left sidebar, select Search or go to and search for the \u201cgo-example- a\u201d project. 2. Go to Secure > Policies. 3. Review your list of existing policies. The Policy Type column will indicate whether you have enabled a Scan Execution Policy for the specified project. 4. Click on the Name in order to view the policy details which specifies which scanners run when code is merged.",
    "remediation": "For each project in use, ensure that every merge request must be scanned for risks by creating a scan execution policy: 1. On the left sidebar, select Search or go to and search for the \u201cgo-example- a\u201d project. 2. Go to Secure > Policies. 3. Select New policy. 4. In the Scan execution policy section, select Select policy. 5. Complete the fields. o Name: Enforce secret detection. o Policy status: Enabled. o Actions: Run a Secret Detection scan. o Conditions: Triggers every time a pipeline runs for all branches. 6. Select Configure with a merge request. The policy project \u201cgo-example-a\u201d security project is created, and a merge request is created. 7. Optional. Review the generated policy YAML in the merge request\u2019s Changes tab. 8. Go to the Overview tab and select Merge. 9. On the left sidebar, select Search or go to and search for the \u201cgo-example- a\u201d project. 10. Go to Secure > Policies. You now have a scan execution policy that runs a secret detection scan on every MR, for any branch. Test the policy by creating a merge request in project A. References: 1. https://docs.gitlab.com/ee/user/application_security/index.html#enforce-scan- execution 2. https://docs.gitlab.com/ee/user/application_security/policies/scan-execution- policies.html",
    "function_names": [
      "code_repository_pull_request_scan_required",
      "code_repository_merge_scan_enabled",
      "code_repository_risk_scan_on_merge",
      "code_repository_pr_scan_mandatory",
      "code_repository_merge_security_scan",
      "code_repository_pr_risk_scan_enabled",
      "code_repository_merge_scan_required",
      "code_repository_pr_scan_before_merge"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/user/application_security/index.html#enforce-scan- execution 2. https://docs.gitlab.com/ee/user/application_security/policies/scan-execution- policies.html"
  },
  {
    "id": "1.1.19",
    "title": "Ensure any changes to branch protection rules are audited",
    "assessment": "Manual",
    "description": "Ensure that changes in the branch protection rules are audited.",
    "rationale": "Branch protection rules should be configured on every repository. The only users who may change such rules are administrators. In a case of an attack on an administrator account or of human error on the part of an administrator, protection rules could be disabled, and thus decrease source code confidentiality as a result. It is important to track and audit such changes to prevent potential incidents as soon as possible.",
    "audit": "Ensure that changes in the branch protection rules are audited regularly. You can view audit events from user actions across an entire GitLab instance. To view instance audit events: 1. On the left sidebar, select Search or go to. 2. Select Admin Area. 3. On the left sidebar, select Monitoring > Audit Events. 4. Filter by the following:Event Type protected_branch_updated. This event type is triggered when the setting for protected branches is updated. 5. Ensure every action is reasonable and secure and is investigated if not.",
    "remediation": "Use the audit log to audit changes in branch protection rules by performing the following: 1. On the left sidebar, select Search or go to. 2. Select Admin Area. 3. On the left sidebar, select Monitoring > Audit Events. 4. Filter by the following:Event Type protected_branch_updated 5. Ensure every action is reasonable and secure and is investigated if not. References: 1. https://docs.gitlab.com/ee/administration/audit_event_streaming/audit_event_typ es.html",
    "function_names": [
      "github_repository_branch_protection_audit_enabled",
      "github_repository_branch_protection_changes_logged",
      "github_repository_branch_protection_monitoring_enabled",
      "github_repository_branch_protection_event_tracking_enabled",
      "github_repository_branch_protection_audit_logging_enabled"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/administration/audit_event_streaming/audit_event_typ es.html"
  },
  {
    "id": "1.1.20",
    "title": "Ensure branch protection is enforced on the default branch",
    "assessment": "Manual",
    "description": "Enforce branch protection on the default and main branch.",
    "rationale": "The default or main branch of repositories is considered very important, as it is eventually gets deployed to the production. Therefore it needs protection. By enforcing branch protection rules on this branch, it is secured from unwanted or unauthorized changes. It can also be protected from untested and unreviewed changes and more.",
    "audit": "The default branch of GitLab repositories are protected by default. This setting can be overridden at the instance, group, or project level. To verify that branch protection is enabled for the main or default branch at the project level: 1. Navigate to the main page of the GitLab repository. 2. Select Settings > Repository . 3. Expand Protected branches . 4. Verify that initial default branch protection is applied to the \"main\" or default branch. GitLab Group Owners can also perform the following to ensure branch protection is enabled by default for new projects at the group level: 1. Navigate to the main page for your GitLab group. 2. Select Settings > Repository . 3. Under Default branch , verify that initial default branch protection is applied to the \"main\" or default branch. GitLab administrators can perform the following to ensure branch protection is enabled by default for the main or default branch of all new projects at the instance level (self- managed GitLab only): 1. Navigate to Admin Area . 2. Select Settings > Repository . 3. Under Default branch , verify that initial default branch protection is applied to the \"main\" or default branch.",
    "remediation": "Perform the following to enforce branch protection on the main or default branch at the project level: 1. Navigate to your project page. 2. Select Settings > Repository. 3. Expand Protected branches . 4. Select Add protected branch . 5. From the Branch dropdown list, select the project's main or default branch. 6. Choose the roles who should be Allowed to merge and Allowed to push and merge for this protected default branch. 7. Select Protect . Perform the following to enforce branch protection on the main or default branch of new projects at the group level: 1. Navigate to the main page for your GitLab group. 2. Select Settings > Repository . 3. Expand Default branch 4. Enable initial default branch protection for the \"main\" or default branch of new repositories created in the group. 5. Select Save changes . Perform the following to enforce branch protection on the main branch of new projects at the instance level (self-managed GitLab administrators only): 1. Navigate to Admin Area . 2. Select Settings > Repository . 3. Expand Default branch . 4. Enable initial default branch protection for the \"main\" or default branch of new repositories created on this GitLab instance. 5. Select Save changes . References: 1. https://docs.gitlab.com/ee/api/protected_branches.html 2. https://docs.gitlab.com/ee/api/group_protected_branches.html(PREMIUM, SaaS only) 3. https://docs.gitlab.com/ee/api/settings.html(Instance-level Admin Only)",
    "function_names": [
      "github_repository_branch_protection_enabled",
      "github_repository_default_branch_protection_enabled",
      "github_repository_main_branch_protection_enabled",
      "github_repository_branch_protection_requirements_set",
      "github_repository_default_branch_admin_restrictions_enabled",
      "github_repository_branch_protection_status_checks_required",
      "github_repository_branch_protection_linear_history_required",
      "github_repository_branch_protection_approvals_required"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/api/protected_branches.html 2. https://docs.gitlab.com/ee/api/group_protected_branches.html(PREMIUM, SaaS only) 3. https://docs.gitlab.com/ee/api/settings.html(Instance-level Admin Only)"
  },
  {
    "id": "1.2.1",
    "title": "Ensure all public repositories contain a SECURITY.md file",
    "assessment": "Manual",
    "description": "A SECURITY.md file is a security policy file that offers instruction on reporting security vulnerabilities in a project. When someone creates an issue within a specific project, a link to the SECURITY.md file will subsequently be shown.",
    "rationale": "A SECURITY.md file provides users with crucial security information. It can also serve an important role in project maintenance, encouraging users to think ahead about how to properly handle potential security issues, updates, and general security practices.",
    "audit": "Verify that each public repository has a SECURITY.md file by performing the following: \u2022 Navigate to the main page of a GitLab repository. \u2022 Verify that the repository has a SECURITY.md file with crucial security information at the top-level.",
    "remediation": "Ensure that each public repository has a SECURITY.md file by performing the following: \u2022 Navigate to the main page of a repository without a SECURITY.md file in GitLab. \u2022 Create a SECURITY.md file (in the web UI or locally) with security information like supported versions of your project and how to report a vulnerability. \u2022 Commit this file to the repository and push your changes. \u2022 If you open a merge request to add the SECURITY.md file, make sure this change is merged to your repository's default branch. References: 1. https://docs.gitlab.com/ee/api/projects.html 2. https://docs.gitlab.com/ee/api/repository_files.html",
    "function_names": [
      "github_repository_security_file_present",
      "github_repository_security_policy_defined",
      "github_repository_public_security_file_required",
      "github_repository_security_md_exists",
      "github_repository_vulnerability_reporting_configured"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/api/projects.html 2. https://docs.gitlab.com/ee/api/repository_files.html"
  },
  {
    "id": "1.2.2",
    "title": "Ensure repository creation is limited to specific members",
    "assessment": "Manual",
    "description": "Limit the ability to create repositories to trusted users and teams.",
    "rationale": "Restricting repository creation to trusted users and teams is recommended in order to keep the organization properly structured, track fewer items, prevent impersonation, and to not overload the version-control system. It will allow administrators easier source code tracking and management capabilities, as they will have fewer repositories to track. The process of detecting potential attacks also becomes far more straightforward, as well, since the easier it is to track the source code, the easier it is to detect malicious acts within it. Additionally, the possibility of a member creating a public repository and sharing the organization's data externally is significantly decreased. Impact: Specific users will not be permitted to create repositories.",
    "audit": "Verify that only trusted users and teams can create repositories by performing the following. As an administrator: \u2022 Navigate to the Admin Area \u2022 In the sidebar, select Settings > General \u2022 Expand the Sign-up restrictions section \u2022 If 'Sign up enabled' is disabled, the instance is compliant. \u2022 If 'Sign-up enabled' and 'Require admin approval for new sign-ups' are selected, and if 'Email confirmation settings' is set to Hard, the instance is compliant.",
    "remediation": "Ensure that only trusted users and teams can create repositories by performing the following. As an administrator: \u2022 Navigate to the Admin Area \u2022 In the sidebar, select Settings > General \u2022 Expand the Sign-up restrictions section \u2022 (Option 1) Deselect 'Sign-up enabled', OR \u2022 (Option 2) Select 'Sign-up enabled', select 'Require admin approval for new sign- ups' are selected, and under 'Email confirmation settings' select 'Hard' \u2022 Select 'Save changes' References: 1. https://docs.gitlab.com/ee/administration/settings/sign_up_restrictions.html",
    "function_names": [
      "github_repository_creation_limited_to_specific_members",
      "github_repository_creation_restricted",
      "github_repository_creation_permissions_restricted",
      "github_repository_creation_trusted_members_only",
      "github_repository_creation_admin_restricted"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Specific users will not be permitted to create repositories.",
    "references": "1. https://docs.gitlab.com/ee/administration/settings/sign_up_restrictions.html"
  },
  {
    "id": "1.2.3",
    "title": "Ensure repository deletion is limited to specific users",
    "assessment": "Manual",
    "description": "Ensure only a limited number of trusted users can delete repositories.",
    "rationale": "Restricting the ability to delete repositories protects the organization from intentional and unintentional data loss. This ensures that users cannot delete repositories or cause other potential damage \u2014 whether by accident or due to their account being hacked \u2014 unless they have the correct privileges. Impact: Certain users will not be permitted to delete repositories.",
    "audit": "Verify that only a limited number of trusted users can delete repositories by performing either of the following steps: \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Manage > Members. \u2022 At the top of the member list, from the dropdown list, select Max role the members have in the group and descending order. \u2022 If there are minimum number of members with Owner/Maintainer role in the list, you are compliant.",
    "remediation": "Enforce repository deletion by a few trusted and responsible users only by performing either of the following steps: \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Manage > Members. \u2022 At the top of the member list, from the dropdown list, select Max role the members have in the group and descending order. \u2022 Next to the project member you want to remove, select Remove member. Default Value: Only organization owners or members with admin privileges can delete repositories.  References: 1. https://docs.gitlab.com/ee/user/permissions.html",
    "function_names": [
      "code_repository_deletion_restricted_to_specific_users",
      "code_repository_delete_permission_limited",
      "code_repository_admin_access_restricted",
      "code_repository_deletion_policy_enforced",
      "code_repository_delete_access_controlled",
      "code_repository_privileged_deletion_limited",
      "code_repository_delete_permission_restricted",
      "code_repository_deletion_scope_limited"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Certain users will not be permitted to delete repositories.",
    "references": "1. https://docs.gitlab.com/ee/user/permissions.html"
  },
  {
    "id": "1.2.4",
    "title": "Ensure issue deletion is limited to specific users",
    "assessment": "Manual",
    "description": "Ensure only trusted and responsible users can delete issues.",
    "rationale": "Issues are a way to keep track of things happening in repositories, such as setting new milestones or requesting urgent fixes. Deleting an issue is not a benign activity, as it might harm the development workflow or attempt to hide malicious behavior. Because of this, it should be restricted and allowed only by trusted and responsible users. Impact: Certain users will not be permitted to delete issues.",
    "audit": "Verify that only a limited number of trusted users can delete issues by performing either of the following steps: \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Manage > Members. \u2022 At the top of the member list, from the dropdown list, select Max role the members have in the group and descending order. \u2022 If there are minimum number of members with Owner/Maintainer role in the list, you are compliant.",
    "remediation": "Enforce issue deletion by a few trusted and responsible users only by performing either of the following steps: \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Manage > Members. \u2022 At the top of the member list, from the dropdown list, select Max role the members have in the group and descending order. \u2022 Next to the project member you want to remove, select Remove member. Default Value: Only organization owners or members with admin privileges can delete issues.  References: 1. https://docs.gitlab.com/ee/user/permissions.html#project-features-permissions",
    "function_names": [
      "issue_deletion_restricted_to_specific_users",
      "issue_deletion_user_permissions_restricted",
      "issue_deletion_admin_only",
      "issue_deletion_trusted_users_only",
      "issue_deletion_responsible_users_only",
      "issue_deletion_privilege_restricted",
      "issue_deletion_access_controlled",
      "issue_deletion_authorized_users_only"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Certain users will not be permitted to delete issues.",
    "references": "1. https://docs.gitlab.com/ee/user/permissions.html#project-features-permissions"
  },
  {
    "id": "1.2.5",
    "title": "Ensure all copies (forks) of code are tracked and accounted for",
    "assessment": "Manual",
    "description": "Track every fork of code and ensure it is accounted for.",
    "rationale": "A fork is a copy of a repository. On top of being a plain copy, any updates to the original repository itself can be pulled and reflected by the fork under certain conditions. A large number of repository copies (forks) become difficult to manage and properly secure. New and sensitive changes can often be pushed into a critical repository without developer knowledge of an updated copy of the very same repository. If there is no limit on doing this, then it is recommended to track and delete copies of organization repositories as needed. Impact: Disabling forks completely may slow down the development process as more actions will be necessary to take in order to fork a repository.",
    "audit": "Verify that the following steps are done regularly to track and examine forks. \u2022 Navigate to the project home page. \u2022 Find the 'Fork' button, and select the number next to it. \u2022 Examine the forks listed there.",
    "remediation": "Track forks and examine them by performing the following on a regular basis: \u2022 Navigate to the project home page. \u2022 Find the 'Fork' button, and select the number next to it. \u2022 Examine the forks listed there.",
    "function_names": [
      "code_repository_fork_tracking_enabled",
      "code_repository_fork_accounting_enabled",
      "code_repository_fork_inventory_maintained",
      "code_repository_fork_monitoring_enabled",
      "code_repository_fork_visibility_restricted",
      "code_repository_fork_approval_required",
      "code_repository_fork_audit_logs_enabled",
      "code_repository_fork_retention_policy_enforced"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Disabling forks completely may slow down the development process as more actions will be necessary to take in order to fork a repository."
  },
  {
    "id": "1.2.6",
    "title": "Ensure all code projects are tracked for changes in visibility status",
    "assessment": "Manual",
    "description": "Ensure every change in visibility of projects is tracked.",
    "rationale": "Visibility of projects determines who can access a project and/or fork it: anyone, designated users, or only members of the organization. If a private project becomes public, this may point to a potential attack, which can ultimately lead to data loss, the leaking of sensitive information, and finally to a supply chain attack. It is crucial to track these changes in order to prevent such incidents.",
    "audit": "Ensure that every change in project visibility is investigated by performing the following regularly. As an administrator: \u2022 Navigate to the Admin Area. \u2022 In the sidebar, select Monitoring > Audit Events. \u2022 Review the log for Actions with the content 'Changed visibility from Private to Public' or 'Changed visibility from Internal to Public'. \u2022 Ensure every change is reasonable and secure and is investigated if it is not.",
    "remediation": "Ensure that every change in project visibility is investigated by performing the following regularly. As an administrator: \u2022 Navigate to the Admin Area. \u2022 In the sidebar, select Monitoring > Audit Events. \u2022 Review the log for Actions with the content 'Changed visibility from Private to Public' or 'Changed visibility from Internal to Public'. \u2022 Ensure every change is reasonable and secure and is investigated if it is not. \u2022 (Optional) Use Instance Audit Event Streaming (https://docs.gitlab.com/ee/administration/audit_event_streaming/#instance- streaming-destinations) to send visibility change events to a third party alerting tool. Integrate these alerts in to your change management and/or incident response processes.  References: 1. https://docs.gitlab.com/ee/administration/audit_event_streaming/audit_event_typ es.html#groups-and-projects",
    "function_names": [
      "cloud_source_repository_visibility_tracking_enabled",
      "cloud_source_repository_visibility_audit_logging_enabled",
      "cloud_source_repository_visibility_change_monitoring_enabled",
      "cloud_source_repository_visibility_history_retention_enabled",
      "cloud_source_repository_visibility_notification_enabled"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/administration/audit_event_streaming/audit_event_typ es.html#groups-and-projects"
  },
  {
    "id": "1.2.7",
    "title": "Ensure inactive repositories are reviewed and archived periodically",
    "assessment": "Manual",
    "description": "Track inactive repositories and remove them periodically.",
    "rationale": "Inactive repositories (i.e., no new changes introduced for a long period of time) can enlarge the surface of a potential attack or data leak. These repositories are more likely to be improperly managed, and thus could possibly be accessed by a large number of users in an organization. Impact: Bug fixes and deployment of necessary changes could prove complicated for archived repositories.",
    "audit": "Perform the following to ensure that all the projects in the organization are active. For each group: \u2022 Navigate to the group homepage. \u2022 Expand any sub-groups. \u2022 For each project, review the updated date and ensure it has been updated within the last 6 months.",
    "remediation": "Perform the following to remediate the presence of inactive projects. For each inactive project identified during the audit: \u2022 Navigate to the project homepage. \u2022 In the sidebar, select Settings > General. \u2022 In the 'Advanced' section, select 'Expand'. \u2022 Select 'Archive project'. \u2022 Read the warning. \u2022 Select 'Archive project'. To automate the deletion of inactive projects, perform the following steps as an Administrator: \u2022 On the left sidebar, at the bottom, select Admin Area. \u2022 Select Settings > Repository. \u2022 Expand Repository maintenance. \u2022 In the Inactive project deletion section, select Delete inactive projects. \u2022 Configure the settings. o The warning email is sent to users who have the Owner and Maintainer role for the inactive project. o The email duration must be less than the Delete project after duration. \u2022 Select Save changes. References: 1. https://docs.gitlab.com/ee/administration/inactive_project_deletion.html",
    "function_names": [
      "code_repository_inactive_reviewed_periodically",
      "code_repository_inactive_archived_periodically",
      "code_repository_inactive_removed_periodically",
      "code_repository_activity_monitored_over_90d",
      "code_repository_cleanup_policy_enabled",
      "code_repository_retention_policy_enabled",
      "code_repository_inactive_alerts_enabled",
      "code_repository_lifecycle_policy_enabled"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Bug fixes and deployment of necessary changes could prove complicated for archived repositories.",
    "references": "1. https://docs.gitlab.com/ee/administration/inactive_project_deletion.html"
  },
  {
    "id": "1.3.1",
    "title": "Ensure inactive users are reviewed and removed periodically",
    "assessment": "Manual",
    "description": "Track inactive user accounts and periodically remove them.",
    "rationale": "User accounts that have been inactive for a long period of time are enlarging the surface of attack. Inactive users with high-level privileges are of particular concern, as these accounts are more likely to be targets for attackers. This could potentially allow access to large portions of an organization should such an attack prove successful. It is recommended to remove them as soon as possible in order to prevent this.",
    "audit": "As an Administrator: \u2022 Navigate to the Admin Area \u2022 In the sidebar, select Users \u2022 Select the 'Deactivated' filter tab \u2022 Identify if any users are present \u2022 Select the 'Active' filter tab \u2022 Sort by 'Oldest updated' \u2022 Use the 'Last activity' column to determine which users are inactive",
    "remediation": "As an Administrator: \u2022 Navigate to the Admin Area \u2022 In the sidebar, select Users \u2022 Next to each inactive user, select the vertical ellipsis \u2022 Select either 'Block' (recommended), 'Delete user', or 'Delete user and contributions' Perform the following steps as an Administrator to automatically deactivate dormant users: \u2022 Navigate to the Admin Area \u2022 Select Settings > General. \u2022 Expand the Account and limit section. \u2022 Under Dormant users, check Deactivate dormant users after a period of inactivity. \u2022 Under Days of inactivity before deactivation, enter the number of days before deactivation. Minimum value is 90 days. \u2022 Select Save changes. References: 1. https://docs.gitlab.com/ee/administration/moderate_users.html",
    "function_names": [
      "iam_user_inactive_reviewed_periodically",
      "iam_user_inactive_removed_periodically",
      "iam_user_inactive_over_90d_reviewed",
      "iam_user_inactive_over_90d_removed",
      "iam_user_last_login_reviewed",
      "iam_user_last_login_over_90d_removed"
    ],
    "profile_applicability": "\u2022  Level 2",
    "references": "1. https://docs.gitlab.com/ee/administration/moderate_users.html"
  },
  {
    "id": "1.3.2",
    "title": "Ensure top-level group creation is limited to specific members",
    "assessment": "Manual",
    "description": "Limit ability to create teams to trusted and specific users.",
    "rationale": "The ability to create new teams should be restricted to specific members in order to keep the organization orderly and ensure users have access to only the lowest privilege level necessary. Teams typically inherit permissions from their parent team, thus if base permissions are less restricted and any user has the ability to create a team, a permission leverage could occur in which certain data is made available to users who should not have access to it. Such a situation could potentially lead to the creation of shadow teams by an attacker. Restricting team creation will also reduce additional clutter in the organizational structure, and as a result will make it easier to track changes and anomalies. Impact: Only specific users will be able to create new teams.",
    "audit": "For every organization, ensure that top-level group creation is limited to specific, trusted users by performing the following: \u2022 On the left sidebar, at the bottom, select Admin Area. \u2022 Select Settings > General. \u2022 Expand Account and limit. \u2022 Verify that the Allow new users to create top-level groups checkbox is not checked.",
    "remediation": "For every organization, limit top-level group creation to specific, trusted users by performing the following: \u2022 On the left sidebar, at the bottom, select Admin Area. \u2022 Select Settings > General. \u2022 Expand Account and limit. \u2022 Clear the Allow new users to create top-level groups checkbox.  References: 1. https://docs.gitlab.com/ee/administration/settings/account_and_limit_settings.htm l#prevent-new-users-from-creating-top-level-groups",
    "function_names": [
      "iam_group_creation_restricted_to_specific_members",
      "iam_group_creation_limited_to_trusted_users",
      "iam_group_creation_permissions_restricted",
      "iam_group_creation_admin_restricted",
      "iam_group_creation_scope_limited"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Only specific users will be able to create new teams.",
    "references": "1. https://docs.gitlab.com/ee/administration/settings/account_and_limit_settings.htm l#prevent-new-users-from-creating-top-level-groups"
  },
  {
    "id": "1.3.3",
    "title": "Ensure minimum number of administrators are set for the organization",
    "assessment": "Manual",
    "description": "Ensure the organization has a minimum number of administrators.",
    "rationale": "Organization administrators have the highest level of permissions, including the ability to add/remove collaborators, create or delete repositories, change branch protection policy, and convert to a publicly-accessible repository. Due to the permissive access granted to an organization administrator, it is highly recommended to keep the number of administrator accounts as minimal as possible.",
    "audit": "Verify the minimum number of administrators in your project by performing the following: \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Manage > Members. \u2022 At the top of the member list, from the dropdown list, select Max role the members have in the group and descending order. \u2022 If there are minimum number of members with Owner/Maintainer role in the list, you are compliant.",
    "remediation": "Set the minimum number of administrators in your project by performing the following: \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Manage > Members. \u2022 At the top of the member list, from the dropdown list, select Max role the members have in the group and descending order. \u2022 Next to the project member you want to remove, select Remove member. References: 1. https://docs.gitlab.com/ee/user/project/members/#filter-and-sort-project-members",
    "function_names": [
      "iam_user_admin_count_minimum",
      "iam_role_admin_count_minimum",
      "iam_policy_admin_count_minimum",
      "iam_group_admin_count_minimum",
      "organization_admin_count_minimum",
      "iam_admin_privileges_count_minimum",
      "iam_admin_roles_count_minimum",
      "iam_admin_users_count_minimum"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/user/project/members/#filter-and-sort-project-members"
  },
  {
    "id": "1.3.4",
    "title": "Ensure Multi-Factor Authentication (MFA) is required for contributors of new code",
    "assessment": "Manual",
    "description": "Require collaborators from outside the organization to use Multi-Factor Authentication (MFA) in addition to a standard user name and password when authenticating to the source code management platform.",
    "rationale": "By default every user authenticates within the system by password only. If the password of a user is compromised, however, the user account and every repository to which they have access are in danger of data loss, malicious code commits, and data theft. It is therefore recommended that each user has Multi-Factor Authentication enabled. This adds an additional layer of protection to ensure the account remains secure even if the user's password is compromised. Impact: A member without enabled Multi-Factor Authentication cannot contribute to the project. They must enable Multi-Factor Authentication a before they can contribute any code.",
    "audit": "For your top-level group, verify that Multi-Factor Authentication is enforced for contributors and is the only way to authenticate, by doing the following: \u2022 On the left sidebar, at the bottom, select Admin Area. \u2022 Select Settings > General. \u2022 Expand Sign-in restrictions: \u2022 Check if Enforce two-factor authentication is enabled. If so, you are compliant.",
    "remediation": "For your top-level group, enforce that Multi-Factor Authentication is enforced for contributors and is the only way to authenticate, by doing the following: \u2022 On the left sidebar, at the bottom, select Admin Area. \u2022 Select Settings > General. \u2022 Expand Sign-in restrictions: \u2022 Select Enforce two-factor authentication to enable this feature.  References: 1. https://docs.gitlab.com/ee/security/two_factor_authentication.html",
    "function_names": [
      "iam_user_mfa_required_for_contributors",
      "source_code_collaborator_mfa_enabled",
      "scm_contributor_mfa_enforced",
      "code_repo_external_collaborator_mfa_required",
      "github_contributor_mfa_enabled",
      "gitlab_external_user_mfa_enforced",
      "source_code_management_mfa_required_for_contributors",
      "scm_external_collaborator_mfa_required",
      "code_repository_contributor_mfa_enabled",
      "version_control_external_user_mfa_enforced"
    ],
    "profile_applicability": "\u2022  Level 2",
    "impact": "A member without enabled Multi-Factor Authentication cannot contribute to the project. They must enable Multi-Factor Authentication a before they can contribute any code.",
    "references": "1. https://docs.gitlab.com/ee/security/two_factor_authentication.html"
  },
  {
    "id": "1.3.5",
    "title": "Ensure the organization is requiring members to use Multi- Factor Authentication (MFA)",
    "assessment": "Manual",
    "description": "Require members of the organization to use Multi-Factor Authentication (MFA) in addition to a standard user name and password when authenticating to the source code management platform.",
    "rationale": "By default every user authenticates within the system by password only. If the password of a user is compromised, however, the user account and every repository to which they have access are in danger of data loss, malicious code commits, and data theft. It is therefore recommended that each user has Multi-Factor Authentication enabled. This adds an additional layer of protection to ensure the account remains secure even if the user's password is compromised. Impact: Members will be removed from the organization if they don't have Multi-Factor Authentication already enabled. If this is the case, it is recommended that an invitation be sent to reinstate the user's access and former privileges. They must enable Multi- Factor Authentication to accept the invitation.",
    "audit": "For every organization that exists in your GitLab platform, verify that Two-Factor Authentication is enforced and is the only way to authenticate. Administrators can enforce 2FA for all users in two different ways: \u2022 Enforce on next sign in. \u2022 Suggest on next sign in, but allow a grace period before enforcing. Use the UI: 1. On the left sidebar, select Search or go to. 2. Select Admin Area. 3. On the left sidebar, select Settings > General. 4. Expand the Sign-in restrictions section: 5. Verify that Enforce two-factor authentication is enabled.",
    "remediation": "Use the UI: 1. On the left sidebar, select Search or go to. 2. Select Admin Area. 3. On the left sidebar, select Settings > General. 4. Expand the Sign-in restrictions section: o Select Enforce two-factor authentication to enable this feature. o In Two-factor grace period, enter a number of hours. If you want to enforce 2FA on next sign-in attempt, enter 0. Use the API: Use the application settings API to modify the following settings: \u2022 require_two_factor_authentication, set to TRUE. References: 1. https://docs.gitlab.com/ee/security/two_factor_authentication.html",
    "function_names": [
      "organization_members_mfa_required",
      "organization_mfa_enforced",
      "organization_members_mfa_enabled",
      "organization_authentication_mfa_required",
      "organization_security_mfa_enforced"
    ],
    "profile_applicability": "\u2022  Level 2",
    "impact": "Members will be removed from the organization if they don't have Multi-Factor Authentication already enabled. If this is the case, it is recommended that an invitation be sent to reinstate the user's access and former privileges. They must enable Multi- Factor Authentication to accept the invitation.",
    "references": "1. https://docs.gitlab.com/ee/security/two_factor_authentication.html"
  },
  {
    "id": "1.3.6",
    "title": "Ensure new members are required to be invited using company-approved email",
    "assessment": "Manual",
    "description": "Existing members of an organization can invite new members to join, however new members must only be invited with their company-approved email.",
    "rationale": "Ensuring new members of an organization have company-approved email prevents existing members of the organization from inviting arbitrary new users to join. Without this verification, they can invite anyone who is using the organization's version control system or has an active email account, thus allowing outside users (and potential threat actors) to easily gain access to company private code and resources. This practice will subsequently reduce the chance of human error or typos when inviting a new member. Impact: Existing members would not be able to invite new users who do not have a company- approved email address.",
    "audit": "For each group in use, verify for every invitation that the invited email address is company-approved by performing the following: On the left sidebar, select Search or go to and find your group. Select Manage > Members. Members that are not automatically added are displayed on the Invited tab. Verify that each invitation email is company approved by your company.",
    "remediation": "For each group, allow only users with company-approved email to be invited. If a user was invited without company-approved email, perform the following: On the left sidebar, select Search or go to and find your group. Select Manage > Members. Members that are not automatically added are displayed on the Invited tab. Verify that each invitation email is company approved by your company. To cancel the user's invitation to join your organization, click Cancel invitation. References: 1. https://docs.gitlab.com/ee/user/group/#add-users-to-a-group",
    "function_names": [
      "iam_member_invitation_company_email_required",
      "iam_member_invitation_email_domain_restricted",
      "iam_organization_invitation_email_approved_only",
      "iam_invitation_email_company_domain_enforced",
      "iam_new_member_invitation_email_restricted",
      "iam_invitation_email_company_approved_required",
      "iam_member_invitation_email_domain_validation_enabled",
      "iam_organization_invitation_email_domain_restricted"
    ],
    "profile_applicability": "\u2022  Level 2",
    "impact": "Existing members would not be able to invite new users who do not have a company- approved email address.",
    "references": "1. https://docs.gitlab.com/ee/user/group/#add-users-to-a-group"
  },
  {
    "id": "1.3.7",
    "title": "Ensure two administrators are set for each repository",
    "assessment": "Manual",
    "description": "Ensure every repository has two users with administrative permissions.",
    "rationale": "Repository administrators have the highest permissions to said repository. These include the ability to add/remove collaborators, change branch protection policy, and convert to a publicly-accessible repository. Due to the liberal access granted to a repository administrator, it is highly recommended that only two contributors occupy this role. Impact: Removing administrative users from a repository would result in them losing high-level access to that repository.",
    "audit": "For every group, verify there are two administrators by performing the following: \u2022 On the left sidebar, at the bottom, select Admin Area. \u2022 Select Overview > Users. \u2022 List users selecting the Admin tab. \u2022 Verify that there are only 2 members with Admin permission.",
    "remediation": "For every group in use, set two administrators by performing the following: \u2022 On the left sidebar, at the bottom, select Admin Area. \u2022 Select Overview > Users. \u2022 List users selecting the Admin tab. \u2022 Find the team or person whose you'd like to revoke admin permissions. To edit a user, in the user\u2019s row, select Edit. References: 1. https://docs.gitlab.com/ee/administration/admin_area.html#administering-users",
    "function_names": [
      "github_repository_two_admins",
      "gitlab_repository_two_admins",
      "bitbucket_repository_two_admins",
      "codecommit_repository_two_admins",
      "azure_repos_two_admins",
      "git_repository_two_admins",
      "source_repository_two_admins",
      "repository_two_admins",
      "repository_admin_count_min_two",
      "repository_admin_users_min_two"
    ],
    "profile_applicability": "\u2022  Level 2",
    "impact": "Removing administrative users from a repository would result in them losing high-level access to that repository.",
    "references": "1. https://docs.gitlab.com/ee/administration/admin_area.html#administering-users"
  },
  {
    "id": "1.3.8",
    "title": "Ensure strict base permissions are set for repositories",
    "assessment": "Manual",
    "description": "Base permissions define the permission level automatically granted to all organization members. Define strict base access permissions for all of the repositories in the organization, including new ones.",
    "rationale": "Defining strict base permissions is the best practice in every role-based access control (RBAC) system. If the base permission is high \u2014 for example, \"write\" permission \u2014 every member of the organization will have \"write\" permission to every repository in the organization. This will apply regardless of the specific permissions a user might need, which generally differ between organization repositories. The higher the permission, the higher the risk for incidents such as bad code commit or data breach. It is therefore recommended to set the base permissions to the strictest level possible. Impact: Users might not be able to access organization repositories or perform some acts as commits. These specific permissions should be granted individually for each user or team, as needed.",
    "audit": "Verify that strict base permissions are set for the organization groups by doing the following: \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Manage > Members. \u2022 At the top of the member list, from the dropdown list, select Max role the members have in the group and descending order. In GitLab, you set the specific role for each new user in your group. Check the roles of your users to determine if it matches the least-privilege principle.",
    "remediation": "Set strict base permissions for the organization groups with the next steps: \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Manage > Members. \u2022 At the top of the member list, from the dropdown list, select Max role the members have in the group and descending order. In GitLab, you set the specific role for each new user in your group. Ensure the roles for your users match the least-privilege principle. Default Value: Read permission",
    "function_names": [
      "github_repository_base_permissions_strict",
      "github_repository_base_permissions_restricted",
      "github_repository_base_permissions_minimal",
      "github_repository_base_permissions_secure",
      "github_repository_base_permissions_limited"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Users might not be able to access organization repositories or perform some acts as commits. These specific permissions should be granted individually for each user or team, as needed."
  },
  {
    "id": "1.3.9",
    "title": "Ensure an organization\u2019s identity is confirmed with a \u201cVerified\u201d badge",
    "assessment": "Manual",
    "description": "Confirm the domains an organization owns with a \"Verified\" badge.",
    "rationale": "Verifying the organization's domain gives developers assurance that a given domain is truly the official home for a public organization. Attackers can pretend to be an organization and steal information via a faked/spoof domain, therefore the use of a \"Verified\" badge instills more confidence and trust between developers and the open- source community.",
    "audit": "On the left sidebar, select Search or go to and find your top-level group. Select Settings > Domain Verification. View your domains and if they are verified or unverified.",
    "remediation": "Step 1: \u2022 On the left sidebar, select Search or go to and find your top-level group. \u2022 Select Settings > Domain Verification. \u2022 In the upper-right corner, select Add Domain. \u2022 In Domain, enter the domain name. \u2022 In Project, link to a project. \u2022 In Certificate: o If you do not have or do not want to use an SSL certificate, leave Automatic certificate management using Let\u2019s Encrypt selected. o Optional. Turn on the Manually enter certificate information toggle to add an SSL/TLS certificate. You can also add the certificate and key later. \u2022 Select Add Domain. Step 2: After you create a new domain, the verification code prompts you. Copy the values from GitLab and paste them in your domain\u2019s control panel as a TXT record. Step 3: After you have added all the DNS records: \u2022 On the left sidebar, select Search or go to and find your group. \u2022 Select Settings > Domain Verification. \u2022 On the domain table row, Select Retry verification (). References: 1. https://docs.gitlab.com/ee/user/enterprise_user/#verified-domains-for-groups",
    "function_names": [
      "iam_organization_domain_verified",
      "iam_identity_domain_verification_enabled",
      "iam_organization_domain_ownership_confirmed",
      "iam_domain_verification_badge_required",
      "iam_identity_verification_enabled"
    ],
    "profile_applicability": "\u2022  Level 2",
    "references": "1. https://docs.gitlab.com/ee/user/enterprise_user/#verified-domains-for-groups"
  },
  {
    "id": "1.3.10",
    "title": "Ensure Source Code Management (SCM) email notifications are restricted to verified domains",
    "assessment": "Manual",
    "description": "Restrict the Source Code Management (SCM) organization's email notifications to approved domains only.",
    "rationale": "Restricting Source Code Management email notifications to verified domains only prevents data leaks, as personal emails and custom domains are more prone to account takeover via DNS hijacking or password breach. Impact: Only members with approved email would be able to receive Source Code Management notifications.",
    "audit": "Ensure Source Code Management email notifications are restricted to approved domains only by performing the following: \u2022 On the left sidebar, select Search or go to and find your top-level group. \u2022 Select Settings > Domain Verification. \u2022 When viewing Domain Verification, select the project listed next to the relevant domain. \u2022 Check if access is limited to the relevant domains.",
    "remediation": "Restrict Source Code Management email notifications to approved domains only by performing the following: \u2022 On the left sidebar, select Search or go to and find your top-level group. \u2022 Select Settings > Domain Verification. \u2022 When viewing Domain Verification, select the project listed next to the relevant domain. \u2022 Ensure access is limited to the relevant domains.   References: 1. https://docs.gitlab.com/ee/user/enterprise_user/#verified-domains-for-groups 2. https://docs.gitlab.com/ee/user/group/access_and_permissions.html#restrict- group-access-by-domain",
    "function_names": [
      "scm_organization_email_notifications_restricted_to_verified_domains",
      "scm_notification_email_domain_restriction_enabled",
      "scm_org_email_notification_domain_verified_only",
      "scm_email_notification_approved_domains_enforced",
      "scm_notification_email_domain_whitelisted"
    ],
    "profile_applicability": "\u2022  Level 2",
    "impact": "Only members with approved email would be able to receive Source Code Management notifications.",
    "references": "1. https://docs.gitlab.com/ee/user/enterprise_user/#verified-domains-for-groups 2. https://docs.gitlab.com/ee/user/group/access_and_permissions.html#restrict- group-access-by-domain"
  },
  {
    "id": "1.3.11",
    "title": "Ensure an organization provides SSH certificates",
    "assessment": "Manual",
    "description": "As an organization, become an SSH Certificate Authority and provide SSH keys for accessing repositories.",
    "rationale": "There are two ways for remotely working with Source Code Management: via HTTPS, which requires authentication by user/password, or via SSH, which requires the use of SSH keys. SSH authentication is better in terms of security; key creation and distribution, however, must be done in a secure manner. This can be accomplished by implementing SSH certificates, which are used to validate the server's identity. A developer will not be able to connect to a Git server if its key cannot be verified by the SSH Certificate Authority (CA) server. As an organization, one can verify the SSH certificate signature used to authenticate if a CA is defined and used. This ensures that only verified developers can access organization repositories, as their SSH key will be the only one signed by the CA certificate. This reduces the risk of misuse and malicious code commits. Impact: Members with unverified keys will not be able to clone organization repositories. Signing, certification, and verification might also slow down the development process.",
    "audit": "GitLab allows you to restrict the allowed SSH key technology as well as specify the minimum key length for each technology: 1. On the left sidebar, at the bottom, select Admin Area. 2. Select Settings > General . 3. Expand Visibility and access controls 4. If a restriction is imposed on any key type, users cannot upload new SSH keys that don\u2019t meet the requirement. Any existing keys that don\u2019t meet it are disabled but not removed and users cannot pull or push code using them.",
    "remediation": "If you do not have an existing SSH key pair, generate a new one: 1. Open a terminal. 2. Run ssh-keygen -t followed by the key type and an optional comment. This comment is included in the .pub file that\u2019s created. 3. Press Enter. 4. Accept the suggested filename and directory, unless you are generating a deploy key or want to save in a specific directory where you store other keys. 5. Specify a passphrase 6. A confirmation is displayed, including information about where your files are stored. A public and private key are generated. 7. Add the public SSH key to your GitLab account and keep the private key secure. References: 1. https://docs.gitlab.com/ee/user/ssh.html#generate-an-ssh-key-pair 2. https://docs.gitlab.com/ee/security/ssh_keys_restrictions.html",
    "function_names": [
      "iam_ssh_certificate_authority_enabled",
      "iam_ssh_certificate_authority_provides_keys",
      "iam_ssh_certificate_authority_repository_access",
      "iam_ssh_certificate_authority_configured",
      "iam_ssh_certificate_authority_active"
    ],
    "profile_applicability": "\u2022  Level 2",
    "impact": "Members with unverified keys will not be able to clone organization repositories. Signing, certification, and verification might also slow down the development process.",
    "references": "1. https://docs.gitlab.com/ee/user/ssh.html#generate-an-ssh-key-pair 2. https://docs.gitlab.com/ee/security/ssh_keys_restrictions.html"
  },
  {
    "id": "1.3.12",
    "title": "Ensure Git access is limited based on IP addresses",
    "assessment": "Manual",
    "description": "Limit Git access based on IP addresses by having a allowlist of IP addresses from which connection is possible.",
    "rationale": "Allowing access to Git repositories (source code) only from specific IP addresses adds yet another layer of restriction and reduces the risk of unauthorized connection to the organization's assets. This will prevent attackers from accessing Source Code Management (SCM), as they would first need to know the allowed IP addresses to gain access to them. Impact: Only members with allowlisted IP addresses will be able to access the organization's Git repositories.",
    "audit": "To ensure only people from your organization can access particular resources, you can restrict access to groups by IP address. This top-level group setting applies to: \u2022 The GitLab UI, including subgroups, projects, and issues. It does not apply to GitLab Pages. In GitLab 12.3 and later, the API. \u2022 In self-managed installations of GitLab 15.1 and later, you can also configure globally-allowed IP address ranges at the group level.  To determine whether IP restrictions are in place: \u2022 On the left sidebar, select Search or go to and find your group. \u2022 Select Settings > General. \u2022 Expand the Permissions and group features section. \u2022 In the Restrict access by IP address text box, view the list of IP addresses.",
    "remediation": "To restrict group access by IP address: 1. On the left sidebar, select Search or go to and find your group. 2. Select Settings > General. 3. Expand the Permissions and group features section. 4. In the Restrict access by IP address text box, enter a list of IPv4 or IPv6 address ranges in CIDR notation. This list: o Has no limit on the number of IP address ranges. o Has a size limit of 1 GB. o Applies to both SSH or HTTP authorized IP address ranges. You cannot split this list by type of authorization. 5. Select Save changes . References: 1. https://docs.gitlab.com/ee/user/group/access_and_permissions.html#restrict- group-access-by-ip-address",
    "function_names": [
      "git_repository_ip_allowlist_enabled",
      "git_repository_ip_restriction_configured",
      "git_repository_access_ip_filtered",
      "git_repository_connection_ip_whitelisted",
      "git_repository_network_ip_restricted"
    ],
    "profile_applicability": "\u2022  Level 2",
    "impact": "Only members with allowlisted IP addresses will be able to access the organization's Git repositories.",
    "references": "1. https://docs.gitlab.com/ee/user/group/access_and_permissions.html#restrict- group-access-by-ip-address"
  },
  {
    "id": "1.3.13",
    "title": "Ensure anomalous code behavior is tracked",
    "assessment": "Manual",
    "description": "Track code anomalies.",
    "rationale": "Carefully analyze any code anomalies within the organization. For example, a code anomaly could be a push made outside of working hours. Such a code push has a higher likelihood of being the result of an attack, as most if not all members of the organization would likely be outside the office. Another example is an activity that exceeds the average activity of a particular user. Tracking and auditing such behaviors creates additional layers of security and can aid in early detection of potential attacks.",
    "audit": "For every project in use, ensure code anomalies relevant to the organization are promptly investigated.",
    "remediation": "For every project in use, track and investigate anomalous code behavior and activity.",
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "1.4.1",
    "title": "Ensure administrator approval is required for every installed application",
    "assessment": "Manual",
    "description": "Ensure an administrator approval is required when installing applications.",
    "rationale": "Applications are typically automated integrations that improve the workflow of an organization. They are written by third-party developers, and therefore should be validated before using in case they're malicious or not trustable. Because administrators are expected to be the most qualified and trusted members of the organization, they should review the applications being installed and decide whether they are both trusted and necessary. Impact: Applications will not be installed without administrator approval.",
    "audit": "Verify that applications are installed only after receiving administrator approval: You are compliant by default. That is because by default only maintainers and owners can integrate with external applications. For OAuth Apps, perform the following: \u2022 On the left sidebar, select your avatar. \u2022 Select Edit profile and then select Applications. \u2022 See the Authorized applications section. \u2022 Review the scope level for the authorised applications with your credentials",
    "remediation": "Require an administrator approval for every installed application: You are compliant by default. That is because by default only maintainers and owners can integrate with external applications. For OAuth Apps, perform the following: \u2022 On the left sidebar, select your avatar. \u2022 Select Edit profile and then select Applications. \u2022 See the Authorized applications section. \u2022 Update the scope level for the authorised applications with your credentials  Default Value: Maintainers are organization owners. References: 1. https://docs.gitlab.com/ee/integration/oauth_provider.html#create-a-user-owned- application 2. https://docs.gitlab.com/ee/integration/oauth_provider.html#view-all-authorized- applications",
    "function_names": [
      "device_management_application_install_admin_approval_required",
      "endpoint_security_application_install_admin_approval_required",
      "mobile_device_application_install_admin_approval_required",
      "windows_device_application_install_admin_approval_required",
      "macos_device_application_install_admin_approval_required",
      "linux_device_application_install_admin_approval_required",
      "enterprise_mobility_application_install_admin_approval_required",
      "intune_application_install_admin_approval_required",
      "jamf_application_install_admin_approval_required",
      "workspace_one_application_install_admin_approval_required"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Applications will not be installed without administrator approval.",
    "references": "1. https://docs.gitlab.com/ee/integration/oauth_provider.html#create-a-user-owned- application 2. https://docs.gitlab.com/ee/integration/oauth_provider.html#view-all-authorized- applications"
  },
  {
    "id": "1.4.2",
    "title": "Ensure stale applications are reviewed and inactive ones are removed",
    "assessment": "Manual",
    "description": "Ensure stale (inactive) applications are reviewed and removed if no longer in use.",
    "rationale": "Applications that have been inactive for a long period of time are enlarging the surface of attack for data leaks. They are more likely to be improperly managed, and could possibly be accessed by third-party developers as a tool for collecting internal data of the organization or repository in which they are installed. It is important to remove these inactive applications as soon as possible.",
    "audit": "Verify that all the applications in the organization are actively used, and remove those that are no longer in use. Ensure that Dependency scanning is enabled, which enables Continuous Vulnerability scanning by default and identifies vulnerabilities applications, even if they are stale.",
    "remediation": "1. Review all stale applications and periodically remove them. 2. Enable dependency scanning to automatically detect vulnerabilities in stale applications. 3. Add the following to your .gitlab-ci.yml file: include: - template: Security/Dependency-Scanning.gitlab-ci.yml",
    "function_names": [
      "compute_application_stale_reviewed",
      "compute_application_inactive_removed",
      "compute_application_activity_monitored_over_90d",
      "compute_application_usage_tracked",
      "compute_application_lifecycle_managed",
      "compute_application_inactive_identified",
      "compute_application_stale_alerted",
      "compute_application_review_scheduled"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "1.4.3",
    "title": "Ensure the access granted to each installed application is limited to the least privilege needed",
    "assessment": "Manual",
    "description": "Ensure installed application permissions are limited to the lowest privilege level required.",
    "rationale": "Applications are typically automated integrations that can improve the workflow of an organization. They are written by third-party developers, and therefore should be reviewed carefully before use. It is recommended to use the \"least privilege\" principle, granting applications the lowest level of permissions required. This may prevent harm from a potentially malicious application with unnecessarily high-level permissions leaking data or modifying source code.",
    "audit": "Verify that each installed integration and application has the least privilege needed. For each Project and each Group, perform the following: \u2022 Navigate to the project or group homepage \u2022 In the sidebar, select Settings > Integrations \u2022 Next to every integration, select 'Configure' \u2022 Review the integration's configuration and verify that it is limited to the least privilege needed For each Group, perform the following: \u2022 Navigate to the project or group homepage \u2022 In the sidebar, select Settings > Applications o Next to every Application, select Edit o Review the Applications configuration and verify that it is limited to the least privilege needed As an administrator, perform the following: \u2022 Navigate to the Admin Area \u2022 In the sidebar, select Applications o Next to every Application, select Edit o Review the Applications configuration and verify that it is limited to the least privilege needed \u2022 In the sidebar, select Settings > Integrations o Next to every integration, select 'Configure' o Review the integration's configuration and verify that it is limited to the least privilege needed \u2022 In the sidebar, select Overview > Users o Select each user's first name o On the users detail page, select 'Impersonate' o Navigate to their Preferences page o In the sidebar, select Applications o Next to every Application under 'Authorized applications', review the scopes permitted o Select the 'Stop impersonating' icon (next to the impersonated user's avatar) o Repeat for each user",
    "remediation": "Grant permissions to applications by the \"least privilege\" principle, meaning the lowest possible permission necessary. For any Integrations identified during the audit as needing modification: \u2022 Next to the integration, select Configure. \u2022 Edit the permissions or settings so that they grant the least possible privileges. For example, restrict the branches it can access, or the features that are enabled. \u2022 (Optionally) Select 'Test settings' \u2022 Select 'Save changes'. For any Applications identified during the audit as needing modification: \u2022 Next to the application, select 'Edit'. \u2022 Edit the permissions or settings so that they grant the least possible privileges. For example, restrict the API scopes it can use. \u2022 Select 'Save application'. If any user authorized applications were identified during the audit as having overly permissive scopes, as an administrator perform the following: \u2022 Navigate to the Admin Area \u2022 In the sidebar, select Overview > Users o Select the user's first name o On the users detail page, select 'Impersonate' o Navigate to their Preferences page o In the sidebar, select Applications o Under 'Authorized applications', re-identify the overly permissive application o Select 'Revoke' o Select the 'Stop impersonating' icon (next to the impersonated user's avatar)",
    "function_names": [
      "iam_role_least_privilege",
      "iam_policy_least_privilege",
      "iam_user_least_privilege",
      "compute_instance_least_privilege",
      "cloudtrail_trail_least_privilege",
      "s3_bucket_least_privilege",
      "lambda_function_least_privilege",
      "cloud_cdn_distribution_least_privilege",
      "rds_instance_least_privilege",
      "eks_cluster_least_privilege"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "1.4.4",
    "title": "Ensure only secured webhooks are used",
    "assessment": "Manual",
    "description": "Use only secured webhooks in the source code management platform.",
    "rationale": "A webhook is an event listener, attached to critical and sensitive parts of the software delivery process. It is triggered by a list of events (such as a new code being committed), and when triggered, the webhook sends out a notification with some payload to specific internet endpoints. Since the payload of the webhook contains sensitive organization data, it's important all webhooks are directed to an endpoint (URL) protected by SSL verification (HTTPS). This helps ensure that the data sent is delivered to securely without any man-in-the-middle, who could easily access and even alter the payload of the request. Impact: Perform the following to ensure all webhooks used are secured (HTTPS): 1. Navigate to your organization or repository and select Settings . 2. Select Webhooks on the side menu. 3. Verify that each webhook URL starts with 'https'.",
    "audit": "Perform the following to secure all webhooks. For each project and for each group: \u2022 Navigate to the project or group \u2022 Select Settings > Webhooks on the side menu. \u2022 Ensure all webhooks starts with 'https'. \u2022 Ensure all webhooks state 'SSL Verification: enabled' As an Administrator: \u2022 Navigate to the Admin Area \u2022 Select System Hooks on the side menu. \u2022 Ensure all webhooks starts with 'https'. \u2022 Ensure all webhooks state 'SSL Verification: enabled'",
    "remediation": "Perform the following to secure all webhooks. For each project and for each group: \u2022 Navigate to the project or group \u2022 Select Settings > Webhooks on the side menu. \u2022 Find any webhooks that start with 'http' and not 'https', or which have 'SSL Verification: disabled'. \u2022 Click Edit. \u2022 Change the payload URL to begin with 'https' \u2022 Select the 'Enable SSL verification' checkbox \u2022 Click Update webhook. As an Administrator: \u2022 Navigate to the Admin Area \u2022 Select System Hooks on the side menu. \u2022 Find any webhooks that start with 'http' and not 'https', or which have 'SSL Verification: disabled'. \u2022 Click Edit. \u2022 Change the payload URL to begin with 'https' \u2022 Select the 'Enable SSL verification' checkbox \u2022 Click Update webhook. References: 1. https://docs.gitlab.com/ee/user/project/integrations/webhooks.html",
    "function_names": [
      "scm_webhook_https_enabled",
      "scm_webhook_tls_1_2_required",
      "scm_webhook_authentication_required",
      "scm_webhook_ip_whitelisted",
      "scm_webhook_secret_validation_enabled",
      "scm_webhook_no_public_exposure",
      "scm_webhook_signature_verification_enabled",
      "scm_webhook_rate_limiting_enabled"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Perform the following to ensure all webhooks used are secured (HTTPS): 1. Navigate to your organization or repository and select Settings . 2. Select Webhooks on the side menu. 3. Verify that each webhook URL starts with 'https'.",
    "references": "1. https://docs.gitlab.com/ee/user/project/integrations/webhooks.html"
  },
  {
    "id": "1.5.1",
    "title": "Ensure scanners are in place to identify and prevent sensitive data in code",
    "assessment": "Manual",
    "description": "Detect and prevent sensitive data in code, such as confidential ID numbers, passwords, etc.",
    "rationale": "Having sensitive data in the source code makes it easier for attackers to maliciously use such information. In order to avoid this, designate scanners to identify and prevent the existence of sensitive data in the code.",
    "audit": "For every repository in use, verify that scanners are set to identify and prevent the existence of sensitive data in code by performing the following: 1. On GitLab, navigate to the main page of the repository. 2. Review the CI pipeline configuration to verify that Secret Detection has been enabled on this project.",
    "remediation": "For every repository in use, designate scanners to identify and prevent sensitive data in code by performing the following: 1. On GitLab, navigate to the main page of the repository. 2. Enable secret detection for this project. Additional Information: By January 2023, this feature is supposed to be open to all plans. Until then it is only for enterprise users.",
    "function_names": [
      "code_repository_scanner_enabled",
      "code_repository_sensitive_data_detection_enabled",
      "code_repository_secret_scanning_enabled",
      "code_repository_prevent_sensitive_data_enabled",
      "code_repository_data_leakage_protection_enabled",
      "code_repository_confidential_data_blocking_enabled",
      "code_repository_credential_scanning_enabled",
      "code_repository_sensitive_content_monitoring_enabled"
    ],
    "profile_applicability": "\u2022  Level 2"
  },
  {
    "id": "1.5.2",
    "title": "Ensure scanners are in place to secure Continuous Integration (CI) pipeline instructions",
    "assessment": "Manual",
    "description": "Detect and prevent misconfigurations and insecure instructions in CI pipelines",
    "rationale": "Detecting and fixing misconfigurations or insecure instructions in CI pipelines decreases the risk for a successful attack through or on the CI pipeline. The more secure the pipeline, the less risk there is for potential exposure of sensitive data, a deployment being compromised, or external access mistakenly being granted to the CI infrastructure or the source code.",
    "audit": "For every project: \u2022 Identify if one or more CI configuration files exist \u2022 Review CI configuration files for misconfigurations or insecure instructions \u2022 Review whether the absence of any CI configuration is itself a misconfiguration",
    "remediation": "For every project identified during the Audit as having misconfigured or insecure CI instructions: \u2022 Update the CI instructions \u2022 Consider using Scan Execution Policies at the project or group level to enforce security scans \u2022 Consider using the Compliance Framework feature to enforce pipeline configuration \u2022 Consider procuring and enabling a CI instructions scanning tool to identify and prevent misconfigurations and insecure instructions and scans all CI pipelines.",
    "function_names": [
      "ci_pipeline_scanner_enabled",
      "ci_pipeline_instruction_secure",
      "ci_pipeline_misconfiguration_detected",
      "ci_pipeline_insecure_instruction_blocked",
      "ci_pipeline_security_scanner_active",
      "ci_pipeline_instruction_validation_enabled",
      "ci_pipeline_misconfiguration_prevention_enabled",
      "ci_pipeline_instruction_security_verified"
    ],
    "profile_applicability": "\u2022  Level 2"
  },
  {
    "id": "1.5.3",
    "title": "Ensure scanners are in place to secure Infrastructure as Code (IaC) instructions",
    "assessment": "Manual",
    "description": "Detect and prevent misconfigurations or insecure instructions in Infrastructure as Code (IaC) files, such as Terraform files.",
    "rationale": "Detecting and fixing misconfigurations and/or insecure instructions in IaC (Infrastructure as Code) files decreases the risk for data leak or data theft. It is important to secure IaC instructions in order to prevent further problems of deployment, exposed assets, or improper configurations, which can ultimately lead to easier ways to attack and steal organization data.",
    "audit": "For every repository that holds IaC instructions files, verify that a scanning tool such as GitLab's Infrastructure as Code scanning is configured to identify and prevent misconfigurations and insecure instructions. 1. On GitLab, navigate to the main page of the repository. 2. Review the CI pipeline configuration to verify that IaC scanning has been enabled on this project.",
    "remediation": "For every repository that holds IaC instructions files, configure GitLab's Infrastructure as Code scanning (or another IaC scanning tool) to identify and prevent misconfigurations and insecure instructions. 1. On GitLab, navigate to the main page of the repository. 2. Enable IaC scanning for this project.",
    "function_names": [
      "iac_scanner_misconfigurations_detected",
      "iac_scanner_insecure_instructions_blocked",
      "iac_scanner_terraform_files_analyzed",
      "iac_scanner_pre_deployment_validation_enabled",
      "iac_scanner_security_policy_enforced",
      "iac_scanner_compliance_checks_passed",
      "iac_scanner_vulnerability_detection_enabled",
      "iac_scanner_continuous_monitoring_active"
    ],
    "profile_applicability": "\u2022  Level 2"
  },
  {
    "id": "1.5.4",
    "title": "Ensure scanners are in place for code vulnerabilities",
    "assessment": "Manual",
    "description": "Detect and prevent known open source vulnerabilities in the code.",
    "rationale": "Open source code blocks are used a lot in developed software. This has its own advantages, but it also has risks. Because the code is open for everyone, it means that attackers can publish or add malicious code to these open-source code blocks, or use their knowledge to find vulnerabilities in an existing code. Detecting and fixing such code vulnerabilities, by SCA (Software Composition Analysis) prevents insecure flaws from reaching production. It gives another opportunity for developers to secure the source code before it is deployed in production, where it is far more exposed and vulnerable to attacks.",
    "audit": "For every repository that is in use, verify that a scanning tool is set to identify and prevent code vulnerabilities by performing the following: 1. On GitLab, navigate to the main page of the repository. 2. Review the CI pipeline configuration to verify that SAST has been configured to run on this project.",
    "remediation": "For every repository that is in use, set a scanning tool to identify and prevent code vulnerabilities by performing the following: 1. On GitLab, navigate to the main page of the repository. 2. Configure SAST to run on this project.",
    "function_names": [
      "code_scanner_vulnerability_detection_enabled",
      "code_scanner_open_source_vulnerability_prevention_enabled",
      "code_scanner_known_vulnerability_protection_enabled",
      "code_scanner_security_vulnerability_scanning_enabled",
      "code_scanner_dependency_vulnerability_check_enabled"
    ],
    "profile_applicability": "\u2022  Level 2"
  },
  {
    "id": "1.5.5",
    "title": "Ensure scanners are in place for open-source vulnerabilities in used packages",
    "assessment": "Manual",
    "description": "Detect, prevent and monitor known open-source vulnerabilities in packages that are being used.",
    "rationale": "Open-source vulnerabilities might exist before one starts to use a package, but they are also discovered over time. New attacks and vulnerabilities are announced every now and then. It is important to keep track of these and to monitor whether the dependencies used are affected by the recent vulnerability. Detecting and fixing those packages' vulnerabilities decreases the attack surface within deployed and running applications that use such packages. It prevents security flaws from reaching the production environment which could eventually lead to a security breach.",
    "audit": "For every repository that is in use, verify that a dependency scanning tool is set to detect, prevent, and monitor vulnerabilities in project dependencies by performing the following: 1. On GitLab, navigate to the main page of the repository. 2. Review the CI pipeline configuration to verify that Dependency Scanning has been configured to run on this project.",
    "remediation": "For every repository that is in use, set a dependency scanning tool to detect, prevent, and monitor vulnerabilities in project packages by performing the following: 1. On GitLab, navigate to the main page of the repository. 2. Configure Dependency Scanning to run on this project. Additional Information: Note: GitLab Dependency Scanning is only available in GitLab Ultimate. If you're not using GitLab Ultimate, consider using a free open-source dependency scanner as part of your CI pipeline.",
    "function_names": [
      "compute_image_vulnerability_scanning_enabled",
      "container_image_vulnerability_scanning_enabled",
      "package_manager_vulnerability_scanning_enabled",
      "dependency_vulnerability_scanning_enabled",
      "artifact_repository_vulnerability_scanning_enabled",
      "runtime_vulnerability_scanning_enabled",
      "build_pipeline_vulnerability_scanning_enabled",
      "registry_image_vulnerability_scanning_enabled",
      "code_repository_vulnerability_scanning_enabled",
      "deployment_vulnerability_scanning_enabled"
    ],
    "profile_applicability": "\u2022  Level 2"
  },
  {
    "id": "1.5.6",
    "title": "Ensure scanners are in place for open-source license issues in used packages",
    "assessment": "Manual",
    "description": "Detect open-source license problems in used dependencies and fix them.",
    "rationale": "A software license is a legal document that establishes several key conditions between a software company or developer and a user in order to allow the use of software. Software licenses have the potential to create code dependencies. Not following the conditions in the software license can also lead to lawsuits. When using packages with a software license, especially commercial ones (which are the most permissive), it is important to verify what is allowed by that license in order to be protected against lawsuits.",
    "audit": "Ensure a license scanning tool is set up to identify open-source license problems and that every package you use is scanned by it. \u2022 The Dependency Scanning or Container Scanning CI job must be configured for your project. \u2022 Your project uses at least one of the languages and package managers supported by Gemnasium. \u2022 A successful pipeline was run on the default branch. You should not change the default behavior of allowing the application security jobs to fail. \u2022 Review the output from the scan in Secure > Dependency list.",
    "remediation": "\u2022 The Dependency Scanning or Container Scanning CI job must be configured for your project. \u2022 Your project uses at least one of the languages and package managers supported by Gemnasium. \u2022 A successful pipeline was run on the default branch. You should not change the default behavior of allowing the application security jobs to fail. \u2022 Take necessary actions based on the outcome of the scan in Secure > Dependency list.  References: 1. https://docs.gitlab.com/ee/user/compliance/license_scanning_of_cyclonedx_files/ index.html 2. https://docs.gitlab.com/ee/user/application_security/dependency_list/index.html",
    "function_names": [
      "compute_package_license_scanner_enabled",
      "compute_dependency_license_scanner_active",
      "compute_package_license_compliance_checked",
      "compute_dependency_license_issue_detected",
      "compute_package_license_remediation_required",
      "compute_dependency_license_scanner_all_regions",
      "compute_package_license_scanner_min_coverage",
      "compute_dependency_license_scanner_auto_remediation"
    ],
    "profile_applicability": "\u2022  Level 2",
    "references": "1. https://docs.gitlab.com/ee/user/compliance/license_scanning_of_cyclonedx_files/ index.html 2. https://docs.gitlab.com/ee/user/application_security/dependency_list/index.html"
  },
  {
    "id": "1.5.7",
    "title": "Ensure scanners are in place for web application runtime security weaknesses",
    "assessment": "Manual",
    "description": "Dynamic Application Security Testing (DAST) runs automated penetration tests to find vulnerabilities in your web applications as they are running. DAST automates a hacker\u2019s approach and simulates real-world attacks for critical threats such as cross-site scripting (XSS), SQL injection (SQLi), and cross-site request forgery (CSRF) to uncover vulnerabilities and misconfigurations that other security tools cannot detect.",
    "rationale": "",
    "audit": "Ensure Browser-based DAST is set up to identify dynamic vulnerabilities in web applications that cannot be detected by other tools earlier in the SDLC. Ensure that every project that contains a web application is scanned by DAST. \u2022 The DAST template must be configured for your project. \u2022 Review the output from the previous scan on your default branch in Secure > Vulnerability Report.",
    "remediation": "1. Include the DAST.gitlab-ci.yml template in your .gitlab-ci.yml file. 2. Add a dast stage to your GitLab CI/CD stages configuration. 3. Define the URL to be scanned by DAST by setting the DAST_WEBSITE CI/CD variable. 4. Add any additionally desired CI variables to customize the test. 5. After configuration, the analyzer will run in your pipeline. 6. View the results in the Vulnerability report and remediate the vulnerabilities. References: 1. https://docs.gitlab.com/ee/user/application_security/dast/browser/configuration/cu stomize_settings.html",
    "function_names": [
      "compute_web_app_dast_scanner_enabled",
      "compute_web_app_runtime_security_scanner_enabled",
      "compute_web_app_vulnerability_scanner_enabled",
      "compute_web_app_xss_protection_scanner_enabled",
      "compute_web_app_sqli_protection_scanner_enabled",
      "compute_web_app_csrf_protection_scanner_enabled",
      "compute_web_app_automated_penetration_testing_enabled",
      "compute_web_app_security_weakness_scanner_enabled"
    ],
    "profile_applicability": "\u2022  Level 2",
    "references": "1. https://docs.gitlab.com/ee/user/application_security/dast/browser/configuration/cu stomize_settings.html"
  },
  {
    "id": "1.5.8",
    "title": "Ensure scanners are in place for API runtime security weaknesses",
    "assessment": "Manual",
    "description": "Dynamic Application Security Testing (DAST) runs automated penetration tests to find vulnerabilities in your APIs as they are running. DAST automates a hacker\u2019s approach and simulates real-world attacks for critical threats such as cross-site scripting (XSS), SQL injection (SQLi), and cross-site request forgery (CSRF) to uncover vulnerabilities and misconfigurations that other security tools cannot detect.",
    "rationale": "",
    "audit": "Ensure a dynamic API scanning tool is set up to identify API-specific vulnerabilities and that every project that contains an APi is scanned by it. \u2022 The DAST-API template must be configured for your project. \u2022 A successful pipeline was run on the default branch. You should not change the default behavior of allowing the application security jobs to fail. \u2022 Review the output from the scan in Secure > Vulnerability Report",
    "remediation": "1. Include the DAST-API.gitlab-ci.yml template in your .gitlab-ci.yml file. 2. The configuration file has several testing profiles defined with different checks enabled. Select a profile and provide it by adding the DAST_API_PROFILE CI/CD variable to your .gitlab-ci.yml file. 3. Provide the location of the OpenAPI Specification as either a file or URL. Specify the location by adding the DAST_API_OPENAPI variable. 4. The target API instance\u2019s base URL is also required. Provide it by using the DAST_API_TARGET_URL variable or an environment_url.txt file. 5. After configuration, the analyzer will run in your pipeline. 6. View the results in the Vulnerability report and remediate the vulnerabilities. References: 1. https://docs.gitlab.com/ee/user/application_security/dast_api/",
    "function_names": [
      "api_gateway_stage_dast_scanner_enabled",
      "api_gateway_rest_api_dast_scanner_enabled",
      "api_gateway_http_api_dast_scanner_enabled",
      "api_gateway_web_socket_dast_scanner_enabled",
      "api_gateway_dast_scanner_min_coverage",
      "api_gateway_dast_scanner_high_severity_enabled",
      "api_gateway_dast_scanner_continuous_monitoring",
      "api_gateway_dast_scanner_automated_remediation",
      "api_gateway_dast_scanner_sqli_protection_enabled",
      "api_gateway_dast_scanner_xss_protection_enabled",
      "api_gateway_dast_scanner_csrf_protection_enabled",
      "api_gateway_dast_scanner_owasp_top_10_enabled"
    ],
    "profile_applicability": "\u2022  Level 2",
    "references": "1. https://docs.gitlab.com/ee/user/application_security/dast_api/"
  },
  {
    "id": "2.1.1",
    "title": "Ensure each pipeline has a single responsibility",
    "assessment": "Manual",
    "description": "Ensure each pipeline has a single responsibility in the build process.",
    "rationale": "Build pipelines generally have access to multiple secrets depending on their purposes. There are, for example, secrets of the test environment for the test phase, repository and artifact credentials for the build phase, etc. Limiting access to these credentials/secrets is therefore recommended by dividing pipeline responsibilities, as well as having a dedicated pipeline for each phase with the lowest privilege instead of a single pipeline for all. This will ensure that any potential damage caused by attacks on a workflow will be limited.",
    "audit": "For each pipeline, ensure it has only one responsibility in the build process.",
    "remediation": "Divide each multi-responsibility pipeline into multiple pipelines, each having a single responsibility with the least privilege. Additionally, create all new pipelines with a sole purpose going forward. References: 1. https://docs.gitlab.com/ee/user/permissions.html#job-permissions",
    "function_names": [
      "codebuild_pipeline_single_responsibility",
      "codebuild_pipeline_responsibility_segregated",
      "codebuild_pipeline_no_multiple_responsibilities",
      "codebuild_pipeline_function_separated",
      "codebuild_pipeline_task_isolated"
    ],
    "profile_applicability": "\u2022  Level 2",
    "references": "1. https://docs.gitlab.com/ee/user/permissions.html#job-permissions"
  },
  {
    "id": "2.1.2",
    "title": "Ensure all aspects of the pipeline infrastructure and configuration are immutable",
    "assessment": "Manual",
    "description": "Ensure the pipeline orchestrator and its configuration are immutable.",
    "rationale": "An immutable infrastructure is one that cannot be changed during execution of the pipeline. This can be done, for example, by using Infrastructure as Code for configuring the pipeline and the pipeline environment. Utilizing such infrastructure creates a more predictable environment because updates will require re-deployment to prevent any previous configuration from interfering. Because it is dependent on automation, it is easier to revert changes. Testing code is also simpler because it is based on virtualization. Most importantly, an immutable pipeline infrastructure ensures that a potential attacker seeking to compromise the build environment itself would not be able to do so if the orchestrator, its configuration, and any other component cannot be changed. Verifying that all aspects of the pipeline infrastructure and configuration are immutable therefore keeps them safe from malicious tampering attempts.",
    "audit": "Verify that the pipeline orchestrator, its configuration, and all other aspects of the build environment are immutable.",
    "remediation": "Use an immutable pipeline orchestrator and ensure that its configuration and all other aspects of the built environment are immutable, as well.",
    "function_names": [
      "pipeline_infrastructure_immutable",
      "pipeline_orchestrator_immutable",
      "pipeline_configuration_immutable",
      "pipeline_infrastructure_configuration_immutable",
      "pipeline_orchestrator_configuration_immutable"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "2.1.3",
    "title": "Ensure the build environment is logged",
    "assessment": "Manual",
    "description": "Keep build logs of the build environment detailing configuration and all activity within it. Also, consider to store them in a centralized organizational log store.",
    "rationale": "Logging the environment is important for two primary reasons: one, for debugging and investigating the environment in case of a bug or security incident; and two, for reproducing the environment easily when needed. Storing these logs in a centralized organizational log store allows the organization to generate useful insights and identify anomalies in the build process faster.",
    "audit": "Verify that the build environment is logged and stored in a centralized organizational log store. When a build environment is created, all information related to the environment is logged as part of the job logs. Depending on the stage in the build environment lifecycle, the path to retrieve the logs will differ: \u2022 When a job is running: #{ROOT_PATH}/gitlab- ci/builds/#{YYYY_mm}/#{project_id}/#{job_id}.log \u2022 After a job is finished: #{ROOT_PATH}/gitlab- rails/shared/artifacts/#{disk_hash}/#{YYYY_mm_dd}/#{job_id}/#{job_artifact_id}/jo b.log \u2022 After a log is archived: #{bucket_name}/#{disk_hash}/#{YYYY_mm_dd}/#{job_id}/#{job_artifact_id}/job.lo g",
    "remediation": "Keep logs of the build environment. Also, store the logs in a centralized organizational log store. This is automatically done by GitLab and can be retrieved in the paths mentioned in the audit section. References: 1. https://docs.gitlab.com/ee/administration/job_logs.html",
    "function_names": [
      "cloud_build_logging_enabled",
      "cloud_build_logs_centralized",
      "cloud_build_logs_retained_over_90d",
      "cloud_build_logs_immutable_storage",
      "cloud_build_logs_encryption_enabled",
      "cloud_build_logs_access_restricted",
      "cloud_build_logs_export_enabled",
      "cloud_build_logs_monitoring_enabled"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/administration/job_logs.html"
  },
  {
    "id": "2.1.4",
    "title": "Ensure the creation of the build environment is automated",
    "assessment": "Manual",
    "description": "Automate the creation of the build environment.",
    "rationale": "Automating the deployment of the build environment reduces the risk for human mistakes \u2014 such as a wrong configuration or exposure of sensitive data \u2014 because it requires less human interaction and intervention. It also eases re-deployment of the environment. It is best to automate with Infrastructure as Code because it offers more control over changes made to the environment creation configuration and stores to a version control platform.",
    "audit": "Verify that the deployment of the build environment is automated and can be easily redeployed. In GitLab, build environments are automatically created for each CI/CD pipeline. To verify that a build environment has been automatically created, do the following: \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Operate > Environments. \u2022 Review the environments.",
    "remediation": "Automate the deployment of the build environment. In GitLab, build environments are automatically created for each CI/CD pipeline. To automate a deployment of the build environment, you need to create a CI/CD pipeline using the gitlab-ci.yml file. References: 1. https://docs.gitlab.com/ee/ci/environments/",
    "function_names": [
      "compute_build_environment_automated",
      "compute_build_environment_automated_creation",
      "build_environment_automated_creation",
      "build_environment_automated",
      "compute_environment_automated_creation",
      "build_environment_creation_automated",
      "compute_build_automated_creation",
      "build_automated_environment_creation"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/ci/environments/"
  },
  {
    "id": "2.1.5",
    "title": "Ensure access to build environments is limited",
    "assessment": "Manual",
    "description": "Restrict access to the build environment (orchestrator, pipeline executor, their environment, etc.) to trusted and qualified users only.",
    "rationale": "A build environment contains sensitive data such as environment variables, secrets, and the source code itself. Any user that has access to this environment can make changes to the build process, including changes to the code within it. Restricting access to the build environment to trusted and qualified users only will reduce the risk for mistakes such as exposure of secrets or misconfiguration. Limiting access also reduces the number of accounts that are vulnerable to hijacking in order to potentially harm the build environment. Impact: Reducing the number of users who have access to the build process means those users would lose their ability to make direct changes to that process.",
    "audit": "Verify each build environment is accessible only to known and authorized users. In GitLab, viewing environments in private projects is limited to Reporter roles at least and you must have at least the Developer role to create a new environment \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Manage > Members. \u2022 At the top of the member list, from the dropdown list, select Max role the members have in the group and descending order. \u2022 If there are minimum number of members with Reporter/Developer role or above in the list, you are compliant.",
    "remediation": "Restrict access to the build environment to trusted and qualified users. In GitLab, viewing environments in private projects is limited to Reporter roles at least and you must have at least the Developer role to create a new environment \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Manage > Members. \u2022 At the top of the member list, from the dropdown list, select Max role the members have in the group and descending order. \u2022 Next to the project member you want to remove, select Remove member References: 1. https://docs.gitlab.com/ee/ci/environments/#environment-permissions",
    "function_names": [
      "iam_build_environment_access_restricted",
      "iam_build_environment_access_trusted_users_only",
      "iam_build_environment_access_qualified_users_only",
      "compute_build_environment_access_restricted",
      "compute_build_environment_access_trusted_users_only",
      "compute_build_environment_access_qualified_users_only",
      "build_environment_access_restricted",
      "build_environment_access_trusted_users_only",
      "build_environment_access_qualified_users_only",
      "build_environment_iam_policy_restricted"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Reducing the number of users who have access to the build process means those users would lose their ability to make direct changes to that process.",
    "references": "1. https://docs.gitlab.com/ee/ci/environments/#environment-permissions"
  },
  {
    "id": "2.1.6",
    "title": "Ensure users must authenticate to access the build environment",
    "assessment": "Manual",
    "description": "Require users to login in to access the build environment - where the orchestrator, the pipeline executer, where the build workers are running, etc.",
    "rationale": "Requiring users to authenticate and disabling anonymous access to the build environment allows organization to track every action on that environment, good or bad, to its actor. This will help recognizing attack and its attacker becuase the authentication is required. Impact: Anonymous users won't be able to access the build environment.",
    "audit": "Ensure authentication is required to access the build environment. In GitLab, viewing environments in private projects is limited to Reporter roles at least and you must have at least the Developer role to create a new environment. Both require prior authentication. \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Manage > Members. \u2022 At the top of the member list, from the dropdown list, select Max role the members have in the group and descending order. \u2022 If there are minimum number of members with Reporter/Developer role or above in the list, you are compliant.",
    "remediation": "Require authentication to access the build environment and disable anonymous access. In GitLab, viewing environments in private projects is limited to Reporter roles at least and you must have at least the Developer role to create a new environment. Both require prior authentication. \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Manage > Members. \u2022 At the top of the member list, from the dropdown list, select Max role the members have in the group and descending order. \u2022 Next to the project member you want to remove, select Remove member References: 1. https://docs.gitlab.com/ee/ci/environments/#environment-permissions",
    "function_names": [
      "compute_build_environment_authentication_required",
      "compute_pipeline_authentication_enabled",
      "compute_build_worker_authentication_required",
      "compute_orchestrator_authentication_enabled",
      "compute_build_access_authentication_required"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Anonymous users won't be able to access the build environment.",
    "references": "1. https://docs.gitlab.com/ee/ci/environments/#environment-permissions"
  },
  {
    "id": "2.1.7",
    "title": "Ensure build secrets are limited to the minimal necessary scope",
    "assessment": "Manual",
    "description": "Build tools providers offer a secure way to store secrets that should be used during the build process. These secrets will often be credentials used to access other tools, for example for pulling code or for uploading artifacts. Access to these secrets can be defined on various scopes. To protect these critical assets it is important to choose the most restrictive scope necessary.",
    "rationale": "Allowing over permissive access to these secrets may affect on their exposure. For example if a secret is defined in an organization level, and users can create new repositories, there is a scenario where a user can create a new repo and run a controlled build just to exfiltrate these secrets. Impact: Increased risk of exposure of build related secrets.",
    "audit": "In the gitlab-ci.yml file, review the secrets permission scope defined in either a file or in an external secrets manager.",
    "remediation": "In the gitlab-ci.yml file, review the secrets defined in either a file or in an external secrets manager and change over permissive scopes to more restrictive ones based on the required access. References: 1. https://docs.gitlab.com/ee/ci/yaml/index.html#secrets 2. https://docs.gitlab.com/ee/ci/secrets/index.html",
    "function_names": [
      "build_secret_minimal_scope",
      "build_secret_restricted_access",
      "build_secret_least_privilege_scope",
      "build_secret_scope_limited",
      "build_secret_access_minimized",
      "build_secret_narrow_scope",
      "build_secret_scope_restricted",
      "build_secret_access_limited"
    ],
    "profile_applicability": "\u2022  Level 2",
    "impact": "Increased risk of exposure of build related secrets.",
    "references": "1. https://docs.gitlab.com/ee/ci/yaml/index.html#secrets 2. https://docs.gitlab.com/ee/ci/secrets/index.html"
  },
  {
    "id": "2.1.8",
    "title": "Ensure the build infrastructure is automatically scanned for vulnerabilities",
    "assessment": "Manual",
    "description": "Scan the build infrastructure and its dependencies for vulnerabilities. It is recommended that this be done automatically.",
    "rationale": "Automatic scanning for vulnerabilities detects known vulnerabilities in the tooling used by the build infrastructure and its dependencies. These vulnerabilities can lead to a potentially massive breach if not handled as fast as possible, as attackers might also be aware of such vulnerabilities.",
    "audit": "Verify that your build infrastructure is reviewed for vulnerabilities. GitLab Runner is designed to run user-controlled scripts. To reduce the attack surface if a job is malicious, you can consider running them in their own network segment. This would provide network separation from other infrastructure and services.",
    "remediation": "Ensure security hardening for your build infrastructure. For a cloud environment, this could include: \u2022 Configuring runner virtual machines in their own network segment \u2022 Blocking SSH access from the Internet to runner virtual machines \u2022 Restricting traffic between runner virtual machines \u2022 Filtering access to cloud provider metadata endpoints For static host runner, whether bare-metal or virtual machine, you should implement security best practices for the host operating system: Malicious code executed in the context of a CI job could compromise the host, so security protocols can help mitigate the impact. Other points to keep in mind include securing or removing files such as SSH keys from the host system that may enable an attacker to access other endpoints in the environment. References: 1. https://docs.gitlab.com/runner/security/",
    "function_names": [
      "build_infrastructure_vulnerability_scanning_enabled",
      "build_infrastructure_automated_scanning_enabled",
      "build_infrastructure_dependency_scanning_enabled",
      "build_infrastructure_continuous_vulnerability_scanning_enabled",
      "build_infrastructure_security_scanning_enabled"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/runner/security/"
  },
  {
    "id": "2.1.9",
    "title": "Ensure default passwords are not used",
    "assessment": "Manual",
    "description": "Do not use default passwords of build tools and components.",
    "rationale": "Sometimes build tools and components are provided with default passwords for the first login. This password is intended to be used only on the first login and should be changed immediately after. Using the default password substantially increases the attack risk. It is especially important to ensure that default passwords are not used in build tools and components.",
    "audit": "GitLab\u2019s default root password depends on the installation method, and when the installation occurred: 1. When deploying a GitLab instance using the official AWS AMI, the root password to the instance is the EC2 Instance ID 2. Most installation methods allow a non-default password to be provided as configuration 3. Prior to 14.0 the default password was 5iveL!fe 4. Otherwise the default password is unique and randomly generated. Attempt to log in as root using a suspected default password to audit whether it has changed. For any other external build tools, ensure the password used is not the default one.",
    "remediation": "GitLab\u2019s root password can be changed by an administrator using the UI, the \u201cgitlab:password:reset\u201d rake task, or by using the Rails console. For each build tool with a default password, change to a unique cryptographically secure pseudorandom password.",
    "function_names": [
      "compute_instance_default_passwords_disabled",
      "database_instance_default_passwords_disabled",
      "container_image_default_passwords_disabled",
      "build_tool_default_passwords_disabled",
      "application_component_default_passwords_disabled",
      "network_device_default_passwords_disabled",
      "storage_service_default_passwords_disabled",
      "security_service_default_passwords_disabled",
      "monitoring_service_default_passwords_disabled",
      "cloud_service_default_passwords_disabled"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "2.1.10",
    "title": "Ensure webhooks of the build environment are secured",
    "assessment": "Manual",
    "description": "Use secured webhooks of the build environment.",
    "rationale": "Webhooks are used for triggering an HTTP request based on an action made in the platform. Typically, build environment feature webhooks for a pipeline trigger based on source code event. Since webhooks are an HTTP POST request, they can be malformed if not secured over SSL. To prevent a potential hack and compromise of the webhook or to the environment or web server excepting the request, use only secured webhooks.",
    "audit": "For each webhook in use, ensure it is secured (HTTPS) via the following process: \u2022 In your project or group, on the left sidebar, select Settings > Webhooks. \u2022 For each webhook, click Edit. \u2022 Verify if the Enable SSL verification checkbox is checked. \u2022 Select Add webhook.",
    "remediation": "For each webhook in use, change it to secured (over HTTPS). \u2022 In your project or group, on the left sidebar, select Settings > Webhooks. \u2022 For each webhook, click Edit. \u2022 Ensure the Enable SSL verification checkbox is checked. \u2022 Select Save. References: 1. https://docs.gitlab.com/ee/user/project/integrations/webhooks.html#configure-a- webhook-in-gitlab",
    "function_names": [
      "build_environment_webhook_https_enabled",
      "build_environment_webhook_authentication_required",
      "build_environment_webhook_ip_restricted",
      "build_environment_webhook_secret_configured",
      "build_environment_webhook_signature_validation_enabled"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/user/project/integrations/webhooks.html#configure-a- webhook-in-gitlab"
  },
  {
    "id": "2.1.11",
    "title": "Ensure minimum number of administrators are set for the build environment",
    "assessment": "Manual",
    "description": "Ensure the build environment has a minimum number of administrators.",
    "rationale": "Build environment administrators have the highest level of permissions, including the ability to add/remove users, create or delete pipelines, control build workers, change build trigger permissions and more. Due to the permissive access granted to a build environment administrator, it is highly recommended to keep the number of administrator accounts as minimal as possible.",
    "audit": "Verify that the build environment has only the minimum number of administrators. \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Manage > Members. \u2022 At the top of the member list, from the dropdown list, select Max role the members have in the group and descending order. \u2022 If there are minimum number of members with Owner/Maintainer role in the list, you are compliant.",
    "remediation": "Set the minimum number of administrators in the build environment. \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Manage > Members. \u2022 At the top of the member list, from the dropdown list, select Max role the members have in the group and descending order. \u2022 Next to the project member you want to remove, select Remove member.",
    "function_names": [
      "iam_user_minimum_administrators",
      "iam_role_minimum_administrators",
      "build_environment_minimum_administrators",
      "build_project_minimum_administrators",
      "compute_instance_minimum_administrators",
      "cloud_identity_minimum_administrators",
      "cloud_resource_minimum_administrators",
      "environment_minimum_administrators",
      "project_minimum_administrators",
      "service_account_minimum_administrators"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "2.2.1",
    "title": "Ensure build workers are single-used",
    "assessment": "Manual",
    "description": "Use a clean instance of build worker for every pipeline run.",
    "rationale": "Using a clean instance of build worker for every pipeline run eliminates the risks of data theft, data integrity breaches, and unavailability. It limits the pipeline's access to data stored on the file system from previous runs, and the cache is volatile. This prevents malicious changes from affecting other pipelines or the Continuous Integration/Continuous Delivery system itself. Impact: Data and cache will not be saved in different pipeline runs.",
    "audit": "Ensure that every pipeline that is being run has its own clean, new runner. In GitLab, each of your jobs runs in a newly provisioned VM, which is dedicated to the specific job. The VM is active only for the duration of the job and immediately deleted. This means that any changes that your job makes to the virtual machine will not be available to a subsequent job. The virtual machine where your job runs has sudo access with no password.",
    "remediation": "Create a clean build worker for every pipeline that is being run, or use build platform- hosted runners, as they typically offer a clean instance for every run. In GitLab, use Runner SaaS to ensure all of these settings are available by default and that each job runs in a dedicated VM. References: 1. https://docs.gitlab.com/ee/ci/runners/index.html",
    "function_names": [
      "compute_build_worker_single_use",
      "compute_build_worker_clean_instance",
      "compute_pipeline_worker_single_use",
      "compute_pipeline_worker_clean_instance",
      "compute_worker_single_use_per_run",
      "compute_worker_clean_instance_per_run"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Data and cache will not be saved in different pipeline runs.",
    "references": "1. https://docs.gitlab.com/ee/ci/runners/index.html"
  },
  {
    "id": "2.2.2",
    "title": "Ensure build worker environments and commands are passed and not pulled",
    "assessment": "Manual",
    "description": "A worker\u2019s environment can be passed (for example, a pod in a Kubernetes cluster in which an environment variable is passed to it). It also can be pulled, like a virtual machine that is installing a package. Ensure that the environment and commands are passed to the workers and not pulled from it.",
    "rationale": "Passing an environment means additional configuration happens in the build time phase and not in run time. It will also pass locally and not remotely. Passing a worker environment, instead of pulling it from an outer source, reduces the possibility for an attacker to gain access and potentially pull malicious code into it. By passing locally and not pulling from remote, there is also less chance of an attack based on the remote connection, such as a man-in-the-middle or malicious scripts that can run from remote. This therefore prevents possible infection of the build worker.",
    "audit": "For each build worker, ensure its environment and commands are passed and not pulled. 1. Review .gitlab-ci.yml and Runner Configurations : Check your project's .gitlab-ci.yml file and any associated Runner configurations to ensure that all necessary environment variables, commands, and configurations are explicitly defined and passed to the Runner. This involves reviewing the job definitions to confirm they do not rely on external sources for configuration at runtime. 2. Examine Runner Execution Environment : Verify that the execution environment of the Runner (whether it's a Docker container, a Kubernetes pod, or a virtual machine) receives its configuration from the .gitlab-ci.yml file or the GitLab project settings directly, without pulling from external sources during the job execution. 3. Check for External Dependencies : Ensure that any external dependencies, such as third-party libraries or tools, are explicitly defined and version-controlled within the project repository or through secure, trusted registries. Avoid configurations that allow the Runner to dynamically fetch or update these dependencies during the build process without strict version controls.",
    "remediation": "For each build worker, pass its environment and commands to it instead of pulling it. 1. Update .gitlab-ci.yml : Amend your .gitlab-ci.yml file to include all necessary environment variables and configurations directly within the file or through secure, project-level settings in GitLab. Avoid dynamic fetching of configurations from external sources during runtime. 2. Secure Runner Environment : Configure your GitLab Runner environments (Docker, Kubernetes, VMs, etc.) to use pre-defined images and configurations that do not require pulling additional settings or scripts during execution. Use trusted, version-controlled base images and scripts. 3. Utilize Secure Variables and Templates : Leverage GitLab's features for secure variables and include templates for common configurations to ensure that environment settings and commands are passed securely and consistently across all projects. References: 1. https://docs.gitlab.com/ee/ci/#the-gitlab-ciyml-file",
    "function_names": [
      "compute_worker_environment_passed",
      "compute_worker_commands_passed",
      "compute_worker_no_environment_pull",
      "compute_worker_no_commands_pull",
      "kubernetes_pod_environment_passed",
      "kubernetes_pod_commands_passed",
      "kubernetes_pod_no_environment_pull",
      "kubernetes_pod_no_commands_pull",
      "vm_worker_no_package_install",
      "vm_worker_environment_passed"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/ci/#the-gitlab-ciyml-file"
  },
  {
    "id": "2.2.3",
    "title": "Ensure the duties of each build worker are segregated",
    "assessment": "Manual",
    "description": "Separate responsibilities in the build workflow, such as testing, compiling, pushing artifacts, etc., to different build workers so that each worker will have a single duty.",
    "rationale": "Separating duties and allocating them to many workers makes it easier to verify each step in the build process and ensure there is no corruption. It also limits the effect of an attack on a build worker, as such an attack would be less critical if the worker has less access and duties that are subject to harm.",
    "audit": "To ensure separation of duties, you can have runner only running jobs for a specific project or a specific group. For a group: \u2022 On the left sidebar, select Search or go to and find your group. \u2022 Select Settings > CI/CD. \u2022 Expand the Runners section. \u2022 Review the Runners related to your specific group. For a project: \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Settings > CI/CD. \u2022 Expand the Runners section. \u2022 Review the Runners related to your specific project.",
    "remediation": "To ensure separation of duties, create runners dedicated to a single group or project. For a group: \u2022 On the left sidebar, select Search or go to and find your group. \u2022 Select Build > Runners. \u2022 Select New group runner. \u2022 Select the operating system where GitLab Runner is installed. \u2022 In the Tags section, in the Tags field, enter the job tags to specify jobs the runner can run. If there are no job tags for this runner, select Run untagged. \u2022 Optional. In the Runner description field, add a runner description that displays in GitLab. \u2022 Optional. In the Configuration section, add additional configurations. \u2022 Select Create runner. \u2022 Follow the on-screen instructions to register the runner from the command line. When prompted by the command line: o For the GitLab instance URL, use the URL for your GitLab instance. For example, if your project is hosted on gitlab.example.com/yourname/yourproject, your GitLab instance URL is https://gitlab.example.com. o For the executor, enter the type of executor. The executor is the environment where the runner executes the job. For a project: \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Settings > CI/CD. \u2022 Expand the Runners section. \u2022 Select New project runner. \u2022 Select the operating system where GitLab Runner is installed. \u2022 In the Tags section, in the Tags field, enter the job tags to specify jobs the runner can run. If there are no job tags for this runner, select Run untagged. \u2022 Optional. In the Runner description field, add a description for the runner that displays in GitLab. \u2022 Optional. In the Configuration section, add additional configurations. \u2022 Select Create runner. \u2022 Follow the on-screen instructions to register the runner from the command line. When prompted by the command line: o For the GitLab instance URL, use the URL for your GitLab instance. For example, if your project is hosted on gitlab.example.com/yourname/yourproject, your GitLab instance URL is https://gitlab.example.com. o For the executor, enter the type of executor. The executor is the environment where the runner executes the job.  References: 1. https://docs.gitlab.com/ee/ci/runners/runners_scope.html",
    "function_names": [
      "build_worker_duties_segregated",
      "build_worker_single_responsibility",
      "build_worker_role_separation",
      "build_worker_task_isolation",
      "build_worker_duty_isolation",
      "build_worker_responsibility_segregation",
      "build_worker_function_separation",
      "build_worker_workflow_isolation"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/ci/runners/runners_scope.html"
  },
  {
    "id": "2.2.4",
    "title": "Ensure build workers have minimal network connectivity",
    "assessment": "Manual",
    "description": "Ensure that build workers have minimal network connectivity.",
    "rationale": "Restricting the network connectivity of build workers decreases the possibility that an attacker would be capable of entering the organization from the outside. If the build workers are connected to the public internet without any restriction, it is far simpler for attackers to compromise them. Limiting network connectivity between build workers also protects the organization in case an attacker was successful and subsequently attempts to spread the attack to other components of the environment. Impact: Developers will not have connectivity to every resource they might need from the outside. Workers will also only be able to exchange data through shareable storage.",
    "audit": "Verify that build workers, environment, and any other components have only the required minimum of network connectivity. Review these configuration measures for your self-managed runners: \u2022 Configuring runner virtual machines in their own network segment \u2022 Blocking SSH access from the Internet to runner virtual machines \u2022 Restricting traffic between runner virtual machines \u2022 Filtering access to cloud provider metadata endpoints",
    "remediation": "Limit the network connectivity of build workers, environment, and any other components to the necessary minimum. Ensure these configuration measures are in place for your self-managed runners: \u2022 Configuring runner virtual machines in their own network segment \u2022 Blocking SSH access from the Internet to runner virtual machines \u2022 Restricting traffic between runner virtual machines \u2022 Filtering access to cloud provider metadata endpoints  References: 1. https://docs.gitlab.com/runner/security/#network-segmentation",
    "function_names": [
      "compute_build_worker_minimal_network_connectivity",
      "compute_build_worker_network_restricted",
      "compute_build_worker_outbound_traffic_limited",
      "compute_build_worker_inbound_traffic_limited",
      "compute_build_worker_network_acl_restricted",
      "compute_build_worker_security_group_restricted",
      "compute_build_worker_no_public_ip",
      "compute_build_worker_private_subnet_only",
      "compute_build_worker_vpc_endpoint_only",
      "compute_build_worker_no_internet_access"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Developers will not have connectivity to every resource they might need from the outside. Workers will also only be able to exchange data through shareable storage.",
    "references": "1. https://docs.gitlab.com/runner/security/#network-segmentation"
  },
  {
    "id": "2.2.5",
    "title": "Ensure run-time security is enforced for build workers",
    "assessment": "Manual",
    "description": "Add traces to build workers' operating systems and installed applications so that in run time, collected events can be analyzed to detect suspicious behavior patterns and malware.",
    "rationale": "Build workers are exposed to data exfiltration attacks, code injection attacks, and more while running. It is important to secure them from such attacks by enforcing run-time security on the build worker itself. This will identify attempted attacks in real time and prevent them.",
    "audit": "Verify that a run-time security solution is enforced on every active build worker.",
    "remediation": "Deploy and enforce a run-time security solution on build workers.",
    "function_names": [
      "compute_build_worker_runtime_security_enabled",
      "compute_build_worker_trace_collection_enabled",
      "compute_build_worker_event_monitoring_enabled",
      "compute_build_worker_malware_detection_enabled",
      "compute_build_worker_os_tracing_enabled",
      "compute_build_worker_application_tracing_enabled",
      "compute_build_worker_suspicious_behavior_detection_enabled"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "2.2.6",
    "title": "Ensure build workers are automatically scanned for vulnerabilities",
    "assessment": "Manual",
    "description": "Scan build workers for vulnerabilities. It is recommended that this be done automatically.",
    "rationale": "Automatic scanning for vulnerabilities detects known weaknesses in environmental sources in use, such as docker images or kernel versions. Such vulnerabilities can lead to a massive breach if these environments are not replaced as fast as possible, since attackers also know about these vulnerabilities and often try to take advantage of them. Setting automatic scanning which scans environmental sources ensures that if any new vulnerability is revealed, it can be replaced quickly and easily. This protects the worker from being exposed to attacks.",
    "audit": "If you are using a static host for a runner, whether bare-metal or virtual machine, you should implement security best practices for the host operating system. Malicious code executed in the context of a CI job could compromise the host, so security protocols can help mitigate the impact. Other points to keep in mind include securing or removing files such as SSH keys from the host system that may enable an attacker to access other endpoints in the environment.",
    "remediation": "For each build worker, automatically scan its environmental sources, such as docker image, for vulnerabilities. \u2022 Create a new project. \u2022 Add a Dockerfile file to the project. This Dockerfile contains minimal configuration required to create a Docker image. \u2022 Create pipeline configuration for the new project to create a Docker image from the Dockerfile, build and push a Docker image to the container registry, and then scan the Docker image for vulnerabilities. \u2022 Check for reported vulnerabilities. \u2022 Update the Docker image and scan the updated image. References: 1. https://docs.gitlab.com/ee/tutorials/container_scanning/",
    "function_names": [
      "compute_build_worker_vulnerability_scanning_enabled",
      "compute_build_worker_auto_scan_enabled",
      "compute_worker_vulnerability_scanning_active",
      "compute_worker_auto_vulnerability_scan_enabled",
      "build_worker_vulnerability_scanning_enabled",
      "build_worker_auto_scan_enabled"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/tutorials/container_scanning/"
  },
  {
    "id": "2.2.7",
    "title": "Ensure build workers' deployment configuration is stored in a version control platform",
    "assessment": "Manual",
    "description": "Store the deployment configuration of build workers in a version control platform, such as GitLab.",
    "rationale": "Build workers are a sensitive part of the build phase. They generally have access to the code repository, the Continuous Integration platform, the deployment platform, etc. This means that an attacker gaining access to a build worker may compromise other platforms in the organization and cause a major incident. One thing that can protect workers is to ensure that their deployment configuration is safe and well-configured. Storing the deployment configuration in version control enables more observability of these configurations because everything is catalogued in a single place. It adds another layer of security, as every change will be reviewed and noticed, and thus malicious changes will theoretically occur less. In the case of a mistake, bug, or security incident, it also offers an easier way to \"revert\" back to a safe version or add a \"hot fix\" quickly. Impact: Changes in deployment configuration may only be applied by declaration in the version control platform. This could potentially slow down the development process.",
    "audit": "Verify that the deployment configuration of build workers is stored in a version control platform. \u2022 On the left sidebar, select Code > Repository. \u2022 Check if a .gitlab-ci.yml file is at the root of your repository.",
    "remediation": "Document and store every deployment configuration of build workers in a version control platform. \u2022 On the left sidebar, select Code > Repository. \u2022 Above the file list, select the branch you want to commit to. If you\u2019re not sure, leave master or main. Then select the plus icon () and New file: \u2022 For the Filename, type .gitlab-ci.yml. \u2022 Select Commit changes.  References: 1. https://docs.gitlab.com/ee/ci/quick_start/index.html",
    "function_names": [
      "compute_build_worker_config_version_controlled",
      "compute_build_worker_deployment_config_in_vcs",
      "compute_worker_deployment_config_versioned",
      "compute_build_worker_config_source_controlled",
      "compute_worker_config_in_version_control"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Changes in deployment configuration may only be applied by declaration in the version control platform. This could potentially slow down the development process.",
    "references": "1. https://docs.gitlab.com/ee/ci/quick_start/index.html"
  },
  {
    "id": "2.2.8",
    "title": "Ensure resource consumption of build workers is monitored",
    "assessment": "Manual",
    "description": "Monitor the resource consumption of build workers and set alerts for high consumption that can lead to resource exhaustion.",
    "rationale": "Resource exhaustion is when machine resources or services are highly consumed until exhausted. Resource exhaustion may lead to DOS (Denial of Service). When such a situation happens to build workers, it slows down and even stops the build process, which harms the production of artifacts and the organization's ability to deliver software on schedule. To prevent that, it is recommended to monitor resources consumption in the build workers and set alerts to notify when they are highly consumed. That way resource exhaustion can be acknowledged and prevented at an early stage.",
    "audit": "Verify that there is monitoring of resources consumption for each build worker. GitLab Runner is instrumented with native Prometheus metrics, which can be exposed via an embedded HTTP server on the /metrics path. The server - if enabled - can be scraped by the Prometheus monitoring system or accessed with any other HTTP client. This is the list of available metrics: \u2022 #HELP gitlab_runner_api_request_statuses_total The total number of api requests, partitioned by runner, endpoint and status. \u2022 #HELP gitlab_runner_autoscaling_machine_creation_duration_seconds Histogram of machine creation time. \u2022 #HELP gitlab_runner_autoscaling_machine_states The current number of machines per state in this provider. \u2022 #HELP gitlab_runner_concurrent The current value of concurrent setting \u2022 #HELP gitlab_runner_errors_total The number of caught errors. \u2022 #HELP gitlab_runner_limit The current value of limit setting \u2022 #HELP gitlab_runner_request_concurrency The current number of concurrent requests for a new job \u2022 #HELP gitlab_runner_request_concurrency_exceeded_total Count of excess requests above the configured request_concurrency limit \u2022 #HELP gitlab_runner_version_info A metric with a constant '1' value labeled by different build stats fields.",
    "remediation": "Set resources consumption monitoring for each build worker. To learn how to set up a Prometheus server to scrape this HTTP endpoint and make use of the collected metrics, see Prometheus\u2019s Getting started guide. Once this is done, the following information will be exposed: The exposed information includes: \u2022 Runner business logic metrics (e.g., the number of currently running jobs) \u2022 Go-specific process metrics (garbage collection stats, goroutines, memstats, etc.) \u2022 general process metrics (memory usage, CPU usage, file descriptor usage, etc.) \u2022 build version information References: 1. https://docs.gitlab.com/runner/monitoring/index.html",
    "function_names": [
      "compute_build_worker_resource_consumption_monitored",
      "compute_build_worker_high_consumption_alert_enabled",
      "compute_build_worker_resource_exhaustion_prevented",
      "compute_build_worker_monitoring_enabled",
      "compute_build_worker_consumption_threshold_set"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/runner/monitoring/index.html"
  },
  {
    "id": "2.3.1",
    "title": "Ensure all build steps are defined as code",
    "assessment": "Manual",
    "description": "Use pipeline as code for build pipelines and their defined steps.",
    "rationale": "Storing pipeline instructions as code in a version control system means automation of the build steps and less room for human error, which could potentially lead to a security breach. Additionally, It creates the ability to revert back to a previous pipeline configuration in order to pinpoint the affected change should a malicious incident occur.",
    "audit": "Verify that all build steps are defined as code and stored in a version control system. \u2022 On the left sidebar, select Code > Repository. \u2022 Check if a .gitlab-ci.yml file is at the root of your repository",
    "remediation": "Convert pipeline instructions into code-based syntax and upload them to the organization's version control platform. \u2022 On the left sidebar, select Code > Repository. \u2022 Above the file list, select the branch you want to commit to. If you\u2019re not sure, leave master or main. Then select the plus icon () and New file: \u2022 For the Filename, type .gitlab-ci.yml. \u2022 Select Commit changes. References: 1. https://docs.gitlab.com/ee/ci/pipelines/",
    "function_names": [
      "build_pipeline_steps_as_code",
      "build_pipeline_code_defined",
      "pipeline_steps_code_defined",
      "build_steps_code_defined",
      "pipeline_build_steps_as_code"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/ci/pipelines/"
  },
  {
    "id": "2.3.2",
    "title": "Ensure steps have clearly defined build stage input and output",
    "assessment": "Manual",
    "description": "Define clear expected input and output for each build stage.",
    "rationale": "In order to have more control over data flow in the build pipeline, clearly define the input and output of the pipeline steps. If anything malicious happens during the build stage, it will be recognized more easily and stand out as an anomaly.",
    "audit": "For each build stage, verify that the expected input and output are clearly defined. \u2022 On the left sidebar, select Code > Repository. \u2022 Review the .gitlab-ci.yml file to check if the build stage job input and output are clearly defined.",
    "remediation": "For each build stage, clearly define what is expected for input and output. \u2022 On the left sidebar, select Code > Repository. \u2022 Ensure the .gitlab-ci.yml file has build stage job input and output clearly defined. References: 1. https://docs.gitlab.com/ee/ci/pipelines/",
    "function_names": [
      "build_pipeline_input_output_defined",
      "build_stage_input_defined",
      "build_stage_output_defined",
      "build_pipeline_stage_input_output_defined",
      "build_stage_input_output_clear"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/ci/pipelines/"
  },
  {
    "id": "2.3.3",
    "title": "Ensure output is written to a separate, secured storage repository",
    "assessment": "Manual",
    "description": "Write pipeline output artifacts to a secured storage repository.",
    "rationale": "To maintain output artifacts securely and reduce the potential surface for attack, store such artifacts separately in secure storage. This separation enforces the Single Responsibility Principle by ensuring the orchestration platform will not be the same as the artifact storage, which reduces the potential harm of an attack. Using the same security considerations as the input (for example, the source code) will protect artifacts stored and will make it harder for a malicious actor to successfully execute an attack.",
    "audit": "For each pipeline that produces output artifacts, ensure that they're written to a secured storage repository. Review where job output artifacts are stored, either locally or in object storage. By default artifacts are stored locally in: \u2022 Linux package (Omnibus): /var/opt/gitlab/gitlab-rails/shared/artifacts \u2022 Self-compiled (source): /home/git/gitlab/shared/artifacts",
    "remediation": "For each pipeline that produces output artifacts, write them to a secured storage repository. One approach is to activate object storage and use an encrypted S3 bucket (or similar). Once the storage is configured, these are the steps to activate it for job artifacts: Linux package (Omnibus): \u2022 Configure the object storage. \u2022 Migrate the artifacts: sudo gitlab-rake gitlab:artifacts:migrate \u2022 Verify that there are no files on disk in the artifacts directory: sudo find /var/opt/gitlab/gitlab-rails/shared/artifacts -type f | grep -v tmp | wc -l Self-compiled (source): \u2022 Configure the object storage. \u2022 Migrate the artifacts: sudo -u git -H bundle exec rake gitlab:artifacts:migrate RAILS_ENV=production \u2022 Verify that there are no files on disk in the artifacts directory: sudo find /home/git/gitlab/shared/artifacts -type f | grep -v tmp | wc -l References: 1. https://docs.gitlab.com/ee/administration/job_artifacts.html?tab=Self- compiled+%28source%29#migrating-to-object-storage",
    "function_names": [
      "cloud_storage_bucket_secure_output_artifacts",
      "pipeline_output_secure_storage_enabled",
      "storage_repository_output_encryption_enabled",
      "pipeline_artifacts_secure_bucket_enabled",
      "cloud_storage_output_access_restricted",
      "pipeline_output_repository_logging_enabled",
      "storage_bucket_output_versioning_enabled",
      "pipeline_artifacts_immutable_storage_enabled"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/administration/job_artifacts.html?tab=Self- compiled+%28source%29#migrating-to-object-storage"
  },
  {
    "id": "2.3.4",
    "title": "Ensure changes to pipeline files are tracked and reviewed",
    "assessment": "Manual",
    "description": "Track and review changes to pipeline files.",
    "rationale": "Pipeline files are sensitive files. They have the ability to access sensitive data and control the build process, thus it is just as important to review changes to pipeline files as it is to verify source code. Malicious actors can potentially add harmful code to these files, which may lead to sensitive data exposure and hijacking of the build environment or artifacts.",
    "audit": "For each pipeline file, ensure changes to it are being tracked and reviewed. \u2022 On the left sidebar, select Code > Repository. \u2022 Check if a .gitlab-ci.yml file is at the root of your repository \u2022 If it exists, all changes will be tracked via Git. \u2022 In the upper-right corner, select History to review the history of the gitlab-ci.yml file",
    "remediation": "For each pipeline file, track changes to it and review them. \u2022 On the left sidebar, select Code > Repository. \u2022 Above the file list, select the branch you want to commit to. If you\u2019re not sure, leave master or main. Then select the plus icon () and New file: \u2022 For the Filename, type .gitlab-ci.yml. \u2022 Select Commit changes.",
    "function_names": [
      "codebuild_project_pipeline_changes_tracked",
      "codebuild_project_pipeline_changes_reviewed",
      "codepipeline_pipeline_changes_tracked",
      "codepipeline_pipeline_changes_reviewed",
      "codecommit_repository_pipeline_changes_tracked",
      "codecommit_repository_pipeline_changes_reviewed",
      "devops_pipeline_changes_tracked",
      "devops_pipeline_changes_reviewed",
      "source_control_pipeline_changes_tracked",
      "source_control_pipeline_changes_reviewed"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "2.3.5",
    "title": "Ensure access to build process triggering is minimized",
    "assessment": "Manual",
    "description": "Restrict access to pipeline triggers.",
    "rationale": "Build pipelines are used for multiple reasons. Some are very sensitive, such as pipelines which deploy to production. In order to protect the environment from malicious acts or human mistakes, such as a developer deploying a bug to production, it is important to apply the Least Privilege principle to pipeline triggering. This principle requires restrictions placed on which users can run which pipeline. It allows for sensitive pipelines to only be run by administrators, who are generally the most trusted and skilled members of the organization.",
    "audit": "For every pipeline in use, verify only the necessary users have permission to trigger it. \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Manage > Members \u2022 At the top of the member list, from the dropdown list, sort by Max role the members have in the group \u2022 Review the members to ensure relevant members are allowed to trigger pipelines in protected environments.",
    "remediation": "For every pipeline in use, grant only the necessary users permission to trigger it. \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Settings > CI/CD. \u2022 Expand Protected environments. \u2022 Select Protect an environment. \u2022 From the Environment list, select the environment you want to protect. \u2022 In the Allowed to deploy list, select the role, users, or groups you want to give deploy access to. Keep in mind that: o There are two roles to choose from: \u25aa Maintainers: Allows access to all of the project\u2019s users with the Maintainer role. \u25aa Developers: Allows access to all of the project\u2019s users with the Maintainer and Developer role. o You can only select groups that are already invited to the project. o Users must have at least the Developer role to appear in the Allowed to deploy list. \u2022 In the Approvers list, select the role, users, or groups you want to give deploy access to. Keep in mind that: o There are two roles to choose from: \u25aa Maintainers: Allows access to all of the project\u2019s users with the Maintainer role. \u25aa Developers: Allows access to all of the project\u2019s users with the Maintainer and Developer role. o You can only select groups that are already invited to the project. o Users must have at least the Developer role to appear in the Approvers list. \u2022 In the Approval rules section: o Ensure that this number is less than or equal to the number of members in the rule. o See Deployment Approvals for more information about this feature. \u2022 Select Protect. References: 1. https://docs.gitlab.com/ee/ci/environments/protected_environments.html",
    "function_names": [
      "codebuild_project_trigger_access_minimized",
      "codebuild_project_trigger_iam_restricted",
      "codebuild_project_trigger_permissions_least_privilege",
      "codebuild_project_trigger_role_limited",
      "codebuild_project_trigger_policy_restrictive"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/ci/environments/protected_environments.html"
  },
  {
    "id": "2.3.6",
    "title": "Ensure pipelines are automatically scanned for misconfigurations",
    "assessment": "Manual",
    "description": "Scan the pipeline for misconfigurations. It is recommended that this be performed automatically.",
    "rationale": "Automatic scans for misconfigurations detect human mistakes and misconfigured tasks. This protects the environment from backdoors caused by such mistakes, which create easier access for attackers. For example, a task that mistakenly configures credentials to persist on the disk makes it easier for an attacker to steal them. This type of incident can be prevented by auto-scanning.",
    "audit": "For each pipeline, verify that it is automatically scanned for misconfigurations.",
    "remediation": "For each pipeline, set automated misconfiguration scanning.",
    "function_names": [
      "codebuild_project_misconfiguration_scan_enabled",
      "codebuild_pipeline_scan_automated",
      "codebuild_pipeline_security_scan_enabled",
      "codebuild_project_scan_on_push_enabled",
      "codebuild_pipeline_scan_on_changes_enabled",
      "codebuild_project_scan_frequency_automated",
      "codebuild_pipeline_scan_before_deploy_enabled",
      "codebuild_project_scan_on_schedule_enabled"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "2.3.7",
    "title": "Ensure pipelines are automatically scanned for vulnerabilities",
    "assessment": "Manual",
    "description": "Scan pipelines for vulnerabilities. It is recommended that this be implemented automatically.",
    "rationale": "Automatic scanning for vulnerabilities detects known vulnerabilities in pipeline instructions and components, allowing faster patching in case one is found. These vulnerabilities can lead to a potentially massive breach if not handled as fast as possible, as attackers might also be aware of such vulnerabilities.",
    "audit": "For each pipeline, verify that it is automatically scanned for vulnerabilities.",
    "remediation": "For each pipeline, set automated vulnerability scanning.",
    "function_names": [
      "codebuild_project_vulnerability_scanning_enabled",
      "codebuild_pipeline_auto_scan_enabled",
      "codepipeline_vulnerability_scanning_enabled",
      "codepipeline_auto_scan_enabled",
      "devops_pipeline_vulnerability_scanning_enabled",
      "devops_pipeline_auto_scan_enabled",
      "ci_cd_pipeline_vulnerability_scanning_enabled",
      "ci_cd_pipeline_auto_scan_enabled"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "2.3.8",
    "title": "Ensure scanners are in place to identify and prevent sensitive data in pipeline files",
    "assessment": "Automated",
    "description": "Detect and prevent sensitive data, such as confidential ID numbers, passwords, etc., in pipelines.",
    "rationale": "Sensitive data in pipeline configuration, such as cloud provider credentials or repository credentials, create vulnerabilities with which malicious actors could steal such information if they gain access to a pipeline. In order to mitigate this, set scanners that will identify and prevent the existence of sensitive data in the pipeline.",
    "audit": "For every pipeline that is in use, verify that scanners are set to identify and prevent the existence of sensitive data within it. \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Build > Pipeline editor. \u2022 Ensure the following lines are present in your gitlab-ci.yml. include: - template: Jobs/Secret-Detection.gitlab-ci.yml",
    "remediation": "For every pipeline that is in use, set scanners that will identify and prevent sensitive data within it. \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Build > Pipeline editor. \u2022 Copy and paste the following to the bottom of the .gitlab-ci.yml file. If an include line already exists, add only the template line below it. include: - template: Jobs/Secret-Detection.gitlab-ci.yml \u2022 Select the Validate tab, then select Validate pipeline. The message Simulation completed successfully indicates the file is valid. \u2022 Select the Edit tab.  \u2022 Optional. In the Commit message text box, customize the commit message. In the Branch text box, enter the name of the default branch. \u2022 Select Commit changes. References: 1. https://docs.gitlab.com/ee/user/application_security/secret_detection/",
    "function_names": [
      "pipeline_scanner_sensitive_data_detection",
      "pipeline_scanner_sensitive_data_prevention",
      "pipeline_file_sensitive_data_blocked",
      "pipeline_file_sensitive_data_monitoring_enabled",
      "pipeline_scanner_sensitive_data_patterns_configured",
      "pipeline_file_sensitive_data_regex_matching_enabled",
      "pipeline_scanner_sensitive_data_alerting_enabled",
      "pipeline_file_sensitive_data_automated_remediation_enabled"
    ],
    "profile_applicability": "\u2022  Level 2",
    "references": "1. https://docs.gitlab.com/ee/user/application_security/secret_detection/"
  },
  {
    "id": "2.4.1",
    "title": "Ensure all artifacts on all releases are signed",
    "assessment": "Manual",
    "description": "Sign all artifacts in all releases with user or organization keys.",
    "rationale": "Signing artifacts is used to validate both their integrity and security. Organizations signal that artifacts may be trusted and they themselves produced them by ensuring that every artifact is properly signed. The presence of this signature also makes potentially malicious activity far more difficult.",
    "audit": "Ensure every artifact in every release is signed.",
    "remediation": "For every artifact in every release, verify that all are properly signed.",
    "function_names": [
      "artifact_release_signed",
      "artifact_release_signed_all",
      "artifact_release_signed_user_key",
      "artifact_release_signed_org_key",
      "artifact_release_signed_all_keys",
      "release_artifact_signature_required",
      "release_artifact_signature_verified",
      "release_artifact_signature_valid"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "2.4.2",
    "title": "Ensure all external dependencies used in the build process are locked",
    "assessment": "Manual",
    "description": "External dependencies may be public packages needed in the pipeline, or perhaps the public image being used for the build worker. Lock these external dependencies in every build pipeline.",
    "rationale": "External dependencies are sources of code that aren't under organizational control. They might be intentionally or unintentionally infected with malicious code or have known vulnerabilities, which could result in sensitive data exposure, data harvesting, or the erosion of trust in an organization. Locking each external dependency to a specific, safe version gives more control and less chance for risk.",
    "audit": "Ensure every external dependency being used in pipelines is locked. \u2022 Go to Code > Repository in your project \u2022 Review the following files at the root of your repository: o Gemfiles o package.jsons o go.sum \u2022 Review the versions of the external dependencies",
    "remediation": "For all external dependencies being used in pipelines, verify they are locked. \u2022 Go to Code > Repository in your project \u2022 Review the following files at the root of your repository: o Gemfiles o package.jsons o go.sum \u2022 Ensure the version of the external dependencies corresponds to your internal policies",
    "function_names": [
      "build_pipeline_dependencies_locked",
      "build_pipeline_external_dependencies_locked",
      "build_worker_image_locked",
      "build_pipeline_public_packages_locked",
      "build_pipeline_dependency_version_locked",
      "build_pipeline_dependency_pinned",
      "build_pipeline_external_dependency_pinned",
      "build_worker_image_pinned",
      "build_pipeline_public_package_pinned",
      "build_pipeline_dependency_locked_all_stages"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "2.4.3",
    "title": "Ensure dependencies are validated before being used",
    "assessment": "Manual",
    "description": "Validate every dependency of the pipeline before use.",
    "rationale": "To ensure that a dependency used in a pipeline is trusted and has not been infected by malicious actor (for example, the codecov incident), validate dependencies before using them. This can be accomplished by comparing the checksum of the dependency to its checksum in a trusted source. If a difference arises, this is a sign that an unknown actor has interfered and may have added malevolent code. If this dependency is used, it will infect the environment, which could end in a massive breach and leave the organization exposed to data leaks, etc.",
    "audit": "For every dependency used in every pipeline, ensure it has been validated. \u2022 On the left sidebar, select Code > Repository. \u2022 Check if a .gitlab-ci.yml file is at the root of your repository \u2022 Verify the following job is included in your .gitlab-ci.yml file: include: - template: Jobs/Dependency-Scanning.gitlab-ci.yml \u2022 Go to Build > Pipelines and confirm that the latest pipeline completed successfully.",
    "remediation": "For every dependency used in every pipeline, validate each one. \u2022 On the left sidebar, select Code > Repository. \u2022 Check if a .gitlab-ci.yml file is at the root of your repository \u2022 Include the following job is included in your .gitlab-ci.yml file:  include: - template: Jobs/Dependency-Scanning.gitlab-ci.yml \u2022 Go to Build > Pipelines and confirm that the latest pipeline completed successfully. In the pipeline, dependency scanning runs and the vulnerabilities are detected automatically. \u2022 Go to Secure > Vulnerability report. \u2022 Select each of the vulnerabilities by selecting the checkbox in each row. \u2022 Review the recommended solution for each vulnerability and investigate further if needed. \u2022 From the Set status dropdown list select the relevant option and select Change status. References: 1. https://docs.gitlab.com/ee/tutorials/dependency_scanning.html",
    "function_names": [
      "pipeline_dependency_validation_enabled",
      "pipeline_dependency_pre_use_validation",
      "pipeline_dependency_security_validation",
      "pipeline_dependency_integrity_validation",
      "pipeline_dependency_trust_validation",
      "pipeline_dependency_verify_before_use",
      "pipeline_dependency_secure_validation",
      "pipeline_dependency_approval_required"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/tutorials/dependency_scanning.html"
  },
  {
    "id": "2.4.4",
    "title": "Ensure the build pipeline creates reproducible artifacts",
    "assessment": "Manual",
    "description": "Verify that the build pipeline creates reproducible artifacts, meaning that an artifact of the build pipeline is the same in every run when given the same input.",
    "rationale": "A reproducible build is a build that produces the same artifact when given the same input data. Ensuring that the build pipeline produces the same artifact when given the same input helps verify that no change has been made to the artifact. This action allows an organization to trust that its artifacts are built only from safe code that has been reviewed and tested and has not been tainted or changed abruptly.",
    "audit": "Ensure that build pipelines create reproducible artifacts. \u2022 On the left sidebar, select Build > Artifacts. \u2022 Review the artifacts associated to your build pipelines",
    "remediation": "Create build pipelines that produce the same artifact given the same input (for example, artifacts that do not rely on timestamps). \u2022 On the left sidebar, select Code > Repository. \u2022 Check if a .gitlab-ci.yml file is at the root of your repository \u2022 To create job artifacts, use the artifacts keyword in your .gitlab-ci.yml file, as in this example: pdf: script: xelatex mycv.tex artifacts: paths: - mycv.pdf In this example, a job named pdf calls the xelatex command to build a PDF file from the LaTeX source file, mycv.tex. The paths keyword determines which files to add to the job artifacts. All paths to files and directories are relative to the repository where the job was created.  References: 1. https://docs.gitlab.com/ee/ci/jobs/job_artifacts.html#create-job-artifacts",
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/ci/jobs/job_artifacts.html#create-job-artifacts"
  },
  {
    "id": "2.4.5",
    "title": "Ensure pipeline steps produce a Software Bill of Materials (SBOM)",
    "assessment": "Manual",
    "description": "SBOM (Software Bill of Materials) is a file that specifies each component of software or a build process. Generate an SBOM after each run of a pipeline.",
    "rationale": "Generating a Software Bill of Materials after each run of a pipeline will validate the integrity and security of that pipeline. Recording every step or component role in the pipeline ensures that no malicious acts have been committed during the pipeline's run.",
    "audit": "For each pipeline, ensure it produces a Software Bill of Materials on every run. \u2022 Check if your gitlab-ci.yml file contains the following: include: - template: Jobs/Dependency-Scanning.gitlab-ci.yml If your project has the following structure: . \u251c\u2500\u2500 ruby-project/ \u2502   \u2514\u2500\u2500 Gemfile.lock \u251c\u2500\u2500 ruby-project-2/ \u2502   \u2514\u2500\u2500 Gemfile.lock \u251c\u2500\u2500 php-project/ \u2502   \u2514\u2500\u2500 composer.lock \u2514\u2500\u2500 go-project/ \u2514\u2500\u2500 go.sum Then the Gemnasium scanner generates the following CycloneDX SBOMs: . \u251c\u2500\u2500 ruby-project/ \u2502   \u251c\u2500\u2500 Gemfile.lock \u2502   \u2514\u2500\u2500 gl-sbom-gem-bundler.cdx.json \u251c\u2500\u2500 ruby-project-2/ \u2502   \u251c\u2500\u2500 Gemfile.lock \u2502   \u2514\u2500\u2500 gl-sbom-gem-bundler.cdx.json \u251c\u2500\u2500 php-project/ \u2502   \u251c\u2500\u2500 composer.lock \u2502   \u2514\u2500\u2500 gl-sbom-packagist-composer.cdx.json \u2514\u2500\u2500 go-project/ \u251c\u2500\u2500 go.sum \u2514\u2500\u2500 gl-sbom-go-go.cdx.json \u2022 Review if these files exists in your environment",
    "remediation": "For each pipeline, configure it to produce a Software Bill of Materials on every run. \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Build > Pipeline editor. \u2022 If no .gitlab-ci.yml file exists, select Configure pipeline, then delete the example content. \u2022 Copy and paste the following to the bottom of the .gitlab-ci.yml file. If an include line already exists, add only the template line below it. include: - template: Jobs/Dependency-Scanning.gitlab-ci.yml \u2022 Select the Validate tab, then select Validate pipeline. The message Simulation completed successfully confirms the file is valid. \u2022 Select the Edit tab. \u2022 Complete the fields. Do not use the default branch for the Branch field. \u2022 Select the Start a new merge request with these changes checkbox, then select Commit changes. \u2022 Complete the fields according to your standard workflow, then select Create merge request. \u2022 Review and edit the merge request according to your standard workflow, then select Merge. The CycloneDX SBOMs are: \u2022 Named gl-sbom--.cdx.json. \u2022 Available as job artifacts of the dependency scanning job. \u2022 Saved in the same directory as the detected lock or build files. References: 1. https://docs.gitlab.com/ee/user/application_security/dependency_scanning/",
    "function_names": [
      "codebuild_project_sbom_produced",
      "codebuild_pipeline_sbom_generated",
      "codebuild_build_sbom_required",
      "codebuild_pipeline_sbom_exported",
      "codebuild_step_sbom_output_enabled",
      "codebuild_build_sbom_artifact_created",
      "codebuild_pipeline_sbom_validation_enabled",
      "codebuild_build_sbom_integrity_verified"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/user/application_security/dependency_scanning/"
  },
  {
    "id": "2.4.6",
    "title": "Ensure pipeline steps sign the Software Bill of Materials (SBOM) produced",
    "assessment": "Manual",
    "description": "SBOM (Software Bill of Materials) is a file that specifies each component of software or a build process. It should be generated after every pipeline run. After it is generated, it must then be signed.",
    "rationale": "Software Bill of Materials (SBOM) is a file used to validate the integrity and security of a build pipeline. Signing it ensures that no one tampered with the file when it was delivered. Such interference can happen if someone tries to hide unusual activity. Validating the SBOM signature can detect this activity and prevent much greater incident.",
    "audit": "For each pipeline, ensure it signs the Software Bill of Materials it produces on every run.",
    "remediation": "For each pipeline, configure it to sign its produced Software Bill of Materials on every run.",
    "function_names": [
      "codebuild_pipeline_sbom_signed",
      "codebuild_pipeline_sbom_signing_enabled",
      "codebuild_pipeline_sbom_generated_and_signed",
      "codebuild_pipeline_sbom_integrity_verified",
      "codebuild_pipeline_sbom_signature_required"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "3.1.1",
    "title": "Ensure third-party artifacts and open-source libraries are verified",
    "assessment": "Manual",
    "description": "Ensure third-party artifacts and open-source libraries in use are trusted and verified.",
    "rationale": "Verify third-party artifacts used in code are trusted and have not been infected by a malicious actor before use. This can be accomplished, for example, by comparing the checksum of the dependency to its checksum in a trusted source. If a difference arises, this may be a sign that someone interfered and added malicious code. If this dependency is used, it will infect the environment and could end in a massive breach, leaving the organization exposed to data leaks and more.",
    "audit": "Ensure third-party artifacts and open-source libraries are verified.",
    "remediation": "Set third-party artifacts and open-source libraries to be verified.",
    "function_names": [
      "artifact_library_trusted_sources",
      "artifact_library_signature_verified",
      "artifact_library_vulnerability_scanned",
      "artifact_library_license_compliant",
      "artifact_library_dependency_verified",
      "artifact_library_repository_trusted",
      "artifact_library_hash_validated",
      "artifact_library_sbom_available",
      "artifact_library_origin_verified",
      "artifact_library_integrity_checked"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "3.1.2",
    "title": "Ensure Software Bill of Materials (SBOM) is required from all third-party suppliers",
    "assessment": "Manual",
    "description": "A Software Bill Of Materials (SBOM) is a file that specifies each component of software or a build process. Require an SBOM from every third-party provider.",
    "rationale": "A Software Bill of Materials (SBOM) for every third-party artifact helps to ensure an artifact is safe to use and fully compliant. This file lists all important metadata, especially all the dependencies of an artifact, and allows for verification of each dependency. If one of the dependencies/artifacts are attacked or has a new vulnerability (for example, the \"SolarWinds\" or even \"log4j\" attacks), it is easier to detect what has been affected by this incident because dependencies in use are listed in the SBOM file.",
    "audit": "For every third-party dependency in use, ensure it has a Software Bill of Materials.",
    "remediation": "For every third-party dependency in use, require a Software Bill of Materials from its supplier.",
    "function_names": [
      "supply_chain_sbom_required",
      "third_party_supplier_sbom_required",
      "software_supply_chain_sbom_required",
      "third_party_component_sbom_required",
      "supplier_software_sbom_required",
      "supply_chain_component_sbom_required",
      "third_party_dependency_sbom_required",
      "supplier_dependency_sbom_required"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "3.1.3",
    "title": "Ensure signed metadata of the build process is required and verified",
    "assessment": "Manual",
    "description": "Require and verify signed metadata of the build process for all dependencies in use.",
    "rationale": "The metadata of a build process lists every action that took place during an artifact build. It is used to ensure that an artifact has not been compromised during the build, that no malicious code was injected into it, and that no nefarious dependencies were added during the build phase. This creates trust between user and vendor that the software supplied is exactly the software that was promised. Signing this metadata adds a checksum to ensure there have been no revisions since its creation, as this checksum changes when the metadata is altered. Verification of proper metadata signature with Certificate Authority confirms that the signature was produced by a trusted entity.",
    "audit": "For each artifact used, ensure it was supplied with verified and signed metadata of its build process. The signature should be the organizational signature and should be verifiable by common Certificate Authority servers.",
    "remediation": "For each artifact in use, require and verify signed metadata of the build process.",
    "function_names": [
      "build_process_metadata_signed_required",
      "build_process_metadata_verification_enabled",
      "dependency_metadata_signature_required",
      "dependency_metadata_verification_enabled",
      "build_dependency_signed_metadata_required",
      "build_dependency_metadata_verification_enabled"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "3.1.4",
    "title": "Ensure dependencies are monitored between open-source components",
    "assessment": "Manual",
    "description": "Monitor, or ask software suppliers to monitor, dependencies between open-source components in use.",
    "rationale": "Monitoring dependencies between open-source components helps to detect if software has fallen victim to attack on a common open-source component. Swift detection can aid in quick application of a fix. It also helps find potential compliance problems with components usage. Some dependencies might not be compatible with the organization's policies, and other dependencies might have a license that is not compatible with how the organization uses this specific dependency. If dependencies are monitored, such situations can be detected and mitigated sooner, potentially deterring malicious attacks.",
    "audit": "For each project, ensure that dependency scanning and container scanning are enabled in order to monitor dependencies. 1. On GitLab, navigate to the main page of the repository. 2. Review the CI pipeline configuration to verify that Dependency Scanning and that Container Scanning have been configured to run on this project.",
    "remediation": "For every repository that is in use, set a dependency scanning and container scanning tools to detect, prevent, and monitor vulnerabilities in project packages and container images by performing the following: 1. On GitLab, navigate to the main page of the repository. 2. Configure Dependency Scanning and Container Scanning to run on this project References: 1. https://docs.gitlab.com/ee/user/application_security/dependency_scanning/#confi guration 2. https://docs.gitlab.com/ee/user/application_security/container_scanning/#configur ation",
    "function_names": [
      "dependency_monitoring_enabled",
      "open_source_component_dependencies_monitored",
      "software_supplier_dependency_monitoring_required",
      "open_source_dependency_tracking_enabled",
      "third_party_dependency_monitoring_active"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/user/application_security/dependency_scanning/#confi guration 2. https://docs.gitlab.com/ee/user/application_security/container_scanning/#configur ation"
  },
  {
    "id": "3.1.5",
    "title": "Ensure trusted package managers and repositories are defined and prioritized",
    "assessment": "Manual",
    "description": "Prioritize trusted package registries over others when pulling a package.",
    "rationale": "When pulling a package by name, the package manager might look for it in several package registries, some of which may be untrusted or badly configured. If the package is pulled from such a registry, there is a higher likelihood that it could prove malicious. In order to avoid this, configure packages to be pulled from trusted package registries.",
    "audit": "For each package registry in use, ensure it is trusted. The GitLab package registry is enabled by default.",
    "remediation": "For each package to be downloaded, configure it to be downloaded from a trusted source. To view your GitLab package registry and its contents, click on \"Deploy\" --> \"Package Registry.\"",
    "function_names": [
      "compute_package_manager_trusted_repositories_prioritized",
      "compute_package_manager_trusted_sources_defined",
      "compute_package_manager_untrusted_sources_restricted",
      "compute_package_manager_approved_repositories_enabled",
      "compute_package_manager_secure_sources_prioritized"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "3.1.6",
    "title": "Ensure a signed Software Bill of Materials (SBOM) of the code is supplied",
    "assessment": "Manual",
    "description": "A Software Bill of Materials (SBOM) is a file that specifies each component of software or a build process. When using a dependency, demand its SBOM and ensure it is signed for validation purposes.",
    "rationale": "A Software Bill of Materials (SBOM) creates trust between its provider and its users by ensuring that the software supplied is the software described, without any potential interference in between. Signing an SBOM creates a checksum for it, which will change if the SBOM's content was changed. With that checksum, a software user can be certain nothing had happened to it during the supply chain, engendering trust in the software. When there is no such trust in the software, the risk surface is increased because one cannot know if the software is potentially vulnerable. Demanding a signed SBOM and validating it decreases that risk.",
    "audit": "For every artifact supplied, ensure it has a validated, signed Software Bill of Materials. To view the SBOMs associated with your projects, Navigate to Secure --> Dependency list You may export the SBOM in .json format.",
    "remediation": "For every artifact supplied, require and verify a signed Software Bill of Materials from its supplier. 1. To create an SBOM, you must run a dependency scan. 2. Enable dependency scanning, and an SBOM will be automatically generated for your project.",
    "function_names": [
      "compute_image_sbom_signed",
      "container_image_sbom_signed",
      "artifact_registry_sbom_signed",
      "build_pipeline_sbom_signed",
      "deployment_package_sbom_signed",
      "dependency_manager_sbom_signed",
      "software_repository_sbom_signed",
      "build_artifact_sbom_signed",
      "code_repository_sbom_signed",
      "deployment_artifact_sbom_signed"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "3.1.7",
    "title": "Ensure dependencies are pinned to a specific, verified version",
    "assessment": "Manual",
    "description": "Pin dependencies to a specific version. Avoid using the \"latest\" tag or broad version.",
    "rationale": "When using a wildcard version of a package, or the \"latest\" tag, the risk of encountering a new, potentially malicious package increases. The \"latest\" tag pulls the last package pushed to the registry. This means that if an attacker pushes a new, malicious package successfully to the registry, the next user who pulls the \"latest\" will pull it and risk attack. This same rule applies to a wildcard version - assuming one is using version v1.*, it will install the latest version of the major version 1, meaning that if an attacker can push a malicious package with that same version, those using it will be subject to possible attack. By using a secure, verified version, use is restricted to this version only and no other may be pulled, decreasing the risk for any malicious package.",
    "audit": "For every dependency in use, ensure it is pinned to a specific version.",
    "remediation": "For every dependency in use, pin to a specific version.",
    "function_names": [
      "compute_image_version_pinned",
      "container_image_version_pinned",
      "package_dependency_version_pinned",
      "function_runtime_version_pinned",
      "template_dependency_version_pinned",
      "infrastructure_module_version_pinned",
      "artifact_dependency_version_pinned",
      "deployment_dependency_version_pinned"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "3.1.8",
    "title": "Ensure all packages used are more than 60 days old",
    "assessment": "Manual",
    "description": "Use packages that are more than 60 days old.",
    "rationale": "Third-party packages are a major risk since an organization cannot control their source code, and there is always the possibility these packages could be malicious. It is therefore good practice to remain cautious with any third-party or open-source package, especially new ones, until they can be verified that they are safe to use. Avoiding a new package allows the organization to fully examine it, its maintainer, and its behavior, and gives enough time to determine whether or not to use it. Impact: Developers may not use packages that are less than 60 days old.",
    "audit": "For every package used, ensure it is more than 60 days old.",
    "remediation": "If a package used is less than 60 days old, stop using it and find another solution.",
    "function_names": [
      "compute_package_age_over_60d",
      "compute_dependency_min_age_60d",
      "compute_software_package_stable_age",
      "compute_image_package_age_compliance",
      "compute_container_image_package_age_over_60d"
    ],
    "profile_applicability": "\u2022  Level 2",
    "impact": "Developers may not use packages that are less than 60 days old."
  },
  {
    "id": "3.2.1",
    "title": "Ensure an organization-wide dependency usage policy is enforced",
    "assessment": "Manual",
    "description": "Enforce a policy for dependency usage across the organization. For example, disallow the use of packages less than 60 days old.",
    "rationale": "Enforcing a policy for dependency usage in an organization helps to manage dependencies across the organization and ensure that all usage is compliant with security policy. If, for example, the policy limits the package managers that can be used, enforcing it will make sure that every dependency is installed only from these package managers, and limit the risk of installing from any untrusted source.",
    "audit": "Verify that a policy for dependency usage is enforced across the organization.",
    "remediation": "Enforce policies for dependency usage across the organization.",
    "function_names": [
      "organization_dependency_policy_enforced",
      "organization_dependency_policy_min_age_60d",
      "organization_dependency_usage_restricted",
      "organization_package_policy_enforced",
      "organization_dependency_policy_all_projects",
      "organization_dependency_policy_version_restricted",
      "organization_package_usage_compliant",
      "organization_dependency_policy_age_restricted"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "3.2.2",
    "title": "Ensure packages are automatically scanned for known vulnerabilities",
    "assessment": "Manual",
    "description": "Automatically scan every package for vulnerabilities.",
    "rationale": "Automatic scanning for vulnerabilities detects known vulnerabilities in packages and dependencies in use, allowing faster patching when one is found. Such vulnerabilities can lead to a massive breach if not handled as fast as possible, as attackers will also know about those vulnerabilities and swiftly try to take advantage of them. Scanning packages regularly for vulnerabilities can also verify usage compliance with the organization's security policy.",
    "audit": "Once Dependency Scanning is enabled for your project, continuous scanning of packages for dependency vulnerabilities is enabled.",
    "remediation": "Enable Dependency scanning in order to automatically scan packages for vulnerabilities. To enable the analyzer, either: \u2022 Enable Auto DevOps, which includes dependency scanning. \u2022 Edit the .gitlab-ci.yml file manually. Use this method if your .gitlab-ci.yml file is complex. \u2022 Use a preconfigured merge request. \u2022 Create a scan execution policy that enforces dependency scanning. References: 1. https://docs.gitlab.com/ee/user/application_security/continuous_vulnerability_sca nning/ 2. https://docs.gitlab.com/ee/user/application_security/dependency_scanning/index. html#enabling-the-analyzer",
    "function_names": [
      "compute_package_vulnerability_scanning_enabled",
      "compute_package_auto_scan_enabled",
      "compute_package_vulnerability_monitoring_active",
      "compute_package_security_scan_enabled",
      "compute_package_vulnerability_check_active"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/user/application_security/continuous_vulnerability_sca nning/ 2. https://docs.gitlab.com/ee/user/application_security/dependency_scanning/index. html#enabling-the-analyzer"
  },
  {
    "id": "3.2.3",
    "title": "Ensure packages are automatically scanned for license implications",
    "assessment": "Manual",
    "description": "A software license is a document that provides legal conditions and guidelines for the use and distribution of software, usually defined by the author. It is recommended to scan for any legal implications automatically.",
    "rationale": "When using packages with software licenses, especially commercial ones which tend to be the strictest, it is important to verify that the use of the package meets the conditions of the license. If the use of the package violates the licensing agreement, it exposes the organization to possible lawsuits. Scanning used packages for such license implications leads to faster detection and quicker fixes of such violations, and also reduces the risk for a lawsuit.",
    "audit": "Ensure license implication rules are configured and are scanned automatically. Once Dependency Scanning is enabled for your project, continuous license scanning is enabled.",
    "remediation": "Enable Dependency scanning in order to automatically scan packages for license implications. To enable the analyzer, either: \u2022 Enable Auto DevOps, which includes dependency scanning. \u2022 Edit the .gitlab-ci.yml file manually. Use this method if your .gitlab-ci.yml file is complex. \u2022 Use a preconfigured merge request. \u2022 Create a scan execution policy that enforces dependency scanning. References: 1. https://docs.gitlab.com/ee/user/compliance/license_scanning_of_cyclonedx_files/ index.html 2. https://docs.gitlab.com/ee/user/application_security/dependency_scanning/index. html#enabling-the-analyzer",
    "function_names": [
      "compute_image_license_scanning_enabled",
      "compute_package_license_scanning_enabled",
      "compute_instance_license_scanning_enabled",
      "compute_software_license_scanning_enabled",
      "compute_artifact_license_scanning_enabled",
      "compute_repository_license_scanning_enabled",
      "compute_container_license_scanning_enabled",
      "compute_vm_license_scanning_enabled"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/user/compliance/license_scanning_of_cyclonedx_files/ index.html 2. https://docs.gitlab.com/ee/user/application_security/dependency_scanning/index. html#enabling-the-analyzer"
  },
  {
    "id": "3.2.4",
    "title": "Ensure packages are automatically scanned for ownership change",
    "assessment": "Manual",
    "description": "Scan every package automatically for ownership change.",
    "rationale": "A change in package ownership is not a regular action. In some cases it can lead to a massive problem (for example, the \"event-stream\" incident). Open-source contributors are not always trusted, since by its very nature everyone can contribute. This means malicious actors can become contributors as well. Package maintainers might transfer their ownership to someone they do not know if maintaining the package is too much for them, in some cases without the other user's knowledge. This has led to known security breaches in the past. It is best to be aware of such activity as soon as it happens and to carefully examine the situation before continuing using the package in order to determine its safety.",
    "audit": "Ensure automatic scanning of packages for ownership change is set.",
    "remediation": "Set automatic scanning of packages for ownership change. References: 1. https://blog.npmjs.org/post/182828408610/the-security-risks-of-changing- package-owners.html 2. https://blog.npmjs.org/post/180565383195/details-about-the-event-stream- incident",
    "function_names": [
      "package_ownership_change_scanning_enabled",
      "package_ownership_change_monitoring_enabled",
      "package_ownership_change_detection_enabled",
      "package_ownership_change_scan_automated",
      "package_ownership_change_scan_continuous",
      "package_ownership_change_scan_scheduled",
      "package_ownership_change_scan_active",
      "package_ownership_change_scan_real_time",
      "package_ownership_change_scan_enabled_all_packages",
      "package_ownership_change_scan_enabled_by_default"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://blog.npmjs.org/post/182828408610/the-security-risks-of-changing- package-owners.html 2. https://blog.npmjs.org/post/180565383195/details-about-the-event-stream- incident"
  },
  {
    "id": "4.1.1",
    "title": "Ensure all artifacts are signed by the build pipeline itself",
    "assessment": "Manual",
    "description": "Configure the build pipeline to sign every artifact it produces and verify that each artifact has the appropriate signature.",
    "rationale": "A cryptographic signature can be used to verify artifact authenticity. The signature created with a certain key is unique and not reversible, thus making it unique to the author. This means that an attacker tampering with a signed artifact will be noticed immediately using a simple verification step because the signature will change. Signing artifacts by the build pipeline that produces them ensures the integrity of those artifacts.",
    "audit": "Verify that the build pipeline signs every new artifact it produces and all artifacts are signed. There are many different signing tools or options each have there own method or commands to verify that the code or package created is signed.",
    "remediation": "Sign every artifact produced with the build pipeline that created it. Configure the build pipeline to sign each artifact. Default Value: Artifacts are not signed by Default.",
    "function_names": [
      "build_pipeline_artifact_signed",
      "build_pipeline_signature_verification_enabled",
      "build_pipeline_artifact_signature_required",
      "build_pipeline_artifact_integrity_verified",
      "build_pipeline_signature_validation_enabled"
    ],
    "profile_applicability": "\u2022  Level 2"
  },
  {
    "id": "4.1.2",
    "title": "Ensure artifacts are encrypted before distribution",
    "assessment": "Manual",
    "description": "Encrypt artifacts before they are distributed and ensure only trusted platforms have decryption capabilities.",
    "rationale": "Build artifacts might contain sensitive data such as production configurations. In order to protect them and decrease the risk for breach, it is recommended to encrypt them before delivery. Encryption makes data unreadable, so even if attackers gain access to these artifacts, they won't be able to harvest sensitive data from them without the decryption key.",
    "audit": "Ensure every artifact is encrypted before it is delivered.",
    "remediation": "Encrypt every artifact before distribution. Default Value: Artifacts do not get encrypted by default.",
    "function_names": [
      "artifact_distribution_encryption_enabled",
      "artifact_distribution_trusted_platforms_only",
      "artifact_distribution_decryption_restricted",
      "artifact_distribution_encryption_before_distribution",
      "artifact_distribution_trusted_decryption_capabilities"
    ],
    "profile_applicability": "\u2022  Level 2"
  },
  {
    "id": "4.1.3",
    "title": "Ensure only authorized platforms have decryption capabilities of artifacts",
    "assessment": "Manual",
    "description": "Grant decryption capabilities of artifacts only to trusted and authorized platforms.",
    "rationale": "Build artifacts might contain sensitive data such as production configuration. To protect them and decrease the risk of a breach, it is recommended to encrypt them before delivery. This will make them unreadable for every unauthorized user who doesn't have the decryption key. By implementing this, the decryption capabilities become overly sensitive in order to prevent a data leak or theft. Ensuring that only trusted and authorized platforms can decrypt the organization's packages decreases the possibility for an attacker to gain access to the critical data in artifacts.",
    "audit": "Ensure only trusted and authorized platforms have decryption capabilities of the organization's artifacts.",
    "remediation": "Grant decryption capabilities of the organization's artifacts only for trusted and authorized platforms.",
    "function_names": [
      "artifact_decryption_authorized_platforms_only",
      "artifact_decryption_platform_restricted",
      "artifact_decryption_trusted_platforms_only",
      "artifact_decryption_authorized_entities_only",
      "artifact_decryption_platform_whitelisted",
      "artifact_decryption_access_restricted",
      "artifact_decryption_platform_authorized",
      "artifact_decryption_trusted_entities_only"
    ],
    "profile_applicability": "\u2022  Level 2"
  },
  {
    "id": "4.2.1",
    "title": "Ensure the authority to certify artifacts is limited",
    "assessment": "Manual",
    "description": "Software certification is used to verify the safety of certain software usage and to establish trust between the supplier and the consumer. Any artifact can be certified. Limit the authority to certify different artifacts.",
    "rationale": "Artifact certification is a powerful tool in establishing trust. Clients use a software certificate to verify that the artifact is safe to use according to their security policies. Because of this, certifying artifacts is considered sensitive. If an artifact is for debugging or internal use, or if it were compromised, the organization would not want certification. An attacker gaining access to both certificate authority and the artifact registry might also be able to certify its own artifact and cause a major breach. To prevent these issues, limit which artifacts can be certified by which platform so there will be minimal access to certification.",
    "audit": "Ensure only certain artifacts can be certified by certain parties.",
    "remediation": "Limit which artifact can be certified by which authority.",
    "function_names": [
      "iam_role_certify_artifacts_restricted",
      "iam_policy_certify_artifacts_limited",
      "artifact_certification_authority_restricted",
      "artifact_certification_permissions_limited",
      "artifact_certification_scope_restricted",
      "artifact_certification_role_restricted",
      "artifact_certification_policy_limited",
      "artifact_certification_privileges_restricted"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "4.2.2",
    "title": "Ensure number of permitted users who may upload new artifacts is minimized",
    "assessment": "Manual",
    "description": "Minimize ability to upload artifacts to the lowest number of trusted users possible.",
    "rationale": "Artifacts might contain sensitive data. Even the simplest mistake can also lead to trust issues with customers and harm the integrity of the product. To decrease these risks, allow only trusted and qualified users to upload new artifacts. Those users are less likely to make mistakes. Having the lowest number of such users possible will also decrease the risk of hacked user accounts, which could lead to a massive breach or artifact compromising.",
    "audit": "Ensure only trusted and qualified users can upload new artifacts, and that their number is the lowest possible. \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Manage > Members. \u2022 At the top of the member list, from the dropdown list, select Max role the members have in the group and descending order. \u2022 If there are minimum number of members with Owner/Maintainer role in the list, you are compliant.",
    "remediation": "Allow only trusted and qualified users to upload new artifacts and limit them in number. \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Manage > Members. \u2022 At the top of the member list, from the dropdown list, select Max role the members have in the group and descending order. \u2022 Next to the project member you want to remove, select Remove member.",
    "function_names": [
      "iam_user_artifact_upload_restricted",
      "iam_user_artifact_upload_minimized",
      "iam_role_artifact_upload_restricted",
      "iam_policy_artifact_upload_minimized",
      "artifact_repository_upload_permissions_restricted",
      "artifact_repository_upload_users_minimized",
      "artifact_repository_upload_roles_restricted",
      "artifact_repository_upload_access_limited"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "4.2.3",
    "title": "Ensure user access to the package registry utilizes Multi- Factor Authentication (MFA)",
    "assessment": "Manual",
    "description": "Enforce Multi-Factor Authentication (MFA) for user access to the package registry.",
    "rationale": "By default, every user authenticates to the system by password only. If a user's password is compromised, the user account and all its related packages are in danger of data theft and malicious builds. It is therefore recommended that each user enables Multi-Factor Authentication. This additional step guarantees that the account stays secure even if the user's password is compromised, as it adds another layer of authentication.",
    "audit": "For each package registry in use, verify that Multi-Factor Authentication is enforced and is the only way to authenticate. \u2022 On the left sidebar, at the bottom, select Admin Area. \u2022 Select Settings > General. \u2022 Expand Sign-in restrictions: \u2022 Check if Enforce two-factor authentication is enabled. If so, you are compliant.",
    "remediation": "For each package registry in use, enforce Multi-Factor Authentication as the only way to authenticate. \u2022 On the left sidebar, at the bottom, select Admin Area. \u2022 Select Settings > General. \u2022 Expand Sign-in restrictions: \u2022 Select Enforce two-factor authentication to enable this feature.",
    "function_names": [
      "package_registry_user_mfa_enabled",
      "package_registry_access_mfa_required",
      "package_registry_user_auth_mfa_enforced",
      "package_registry_mfa_auth_required",
      "package_registry_user_mfa_auth_enabled"
    ],
    "profile_applicability": "\u2022  Level 2"
  },
  {
    "id": "4.2.4",
    "title": "Ensure user management of the package registry is not local",
    "assessment": "Manual",
    "description": "Manage users and their access to the package registry with an external authentication server and not with the package registry itself.",
    "rationale": "Some package registries offer a tool for user management, aside from the main Lightweight Directory Access Protocol (LDAP) or Active Directory (AD) server of the organization. That tool usually offers simple authentication and role-based permissions, which might not be granular enough. Having multiple user management tools in the organization could result in confusion and privilege escalation, as there will be more to manage. To avoid a situation where users escalate their privileges because someone missed them, manage user access to the package registry via the main authentication server and not locally on the package registry.",
    "audit": "For each package registry, verify that its user access is not managed locally, but instead with the main authentication server of the organization.",
    "remediation": "For each package registry, use the main authentication server of the organization for user management and do not manage locally.",
    "function_names": [
      "package_registry_user_external_authentication_required",
      "package_registry_user_local_auth_disabled",
      "package_registry_user_centralized_auth_enabled",
      "package_registry_user_no_local_management",
      "package_registry_user_external_identity_provider_required"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "4.2.5",
    "title": "Ensure anonymous access to artifacts is revoked",
    "assessment": "Manual",
    "description": "For GitLab projects anonymous access is not available. Verify that all that require access controls are Private or Internal.",
    "rationale": "Disable the option to view artifacts as an anonymous user in order to protect private artifacts from being exposed. Impact: Only logged and authorized users will be able to access artifacts.",
    "audit": "Reviewing a project's visibility for artifacts: \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Settings > General. \u2022 Expand Visibility, project features, permissions. \u2022 From the Project visibility dropdown list, review the current selection.",
    "remediation": "Changing a project's visibility for artifacts: \u2022 On the left sidebar, select Search or go to and find your project. \u2022 Select Settings > General. \u2022 Expand Visibility, project features, permissions. \u2022 From the Project visibility dropdown list, select an option. The visibility setting for a project must be at least as restrictive as the visibility of its parent group. \u2022 Select Save changes. References: 1. https://docs.gitlab.com/ee/user/public_access.html",
    "function_names": [
      "gitlab_project_anonymous_access_revoked",
      "gitlab_project_access_control_private",
      "gitlab_project_access_control_internal",
      "gitlab_project_no_public_access",
      "gitlab_repository_anonymous_access_disabled"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Only logged and authorized users will be able to access artifacts.",
    "references": "1. https://docs.gitlab.com/ee/user/public_access.html"
  },
  {
    "id": "4.2.6",
    "title": "Ensure minimum number of administrators are set for the package registry",
    "assessment": "Manual",
    "description": "Ensure the package registry has a minimum number of administrators.",
    "rationale": "Package registry admins have the ability to add/remove users, repositories, packages. Due to the permissive access granted to an admin, it is highly recommended to keep the number of administrator accounts as minimal as possible. Impact: Administrator privileges are required to provide and maintain a secure and stable platform but allowing extraneous administrator accounts can create a vulnerability.",
    "audit": "Verify that your package registry has only the minimum number of administrators. For each project that you administer on GitLab, you can see every team or person with access to the project. Project-level permissions determine actions such as downloading, pushing, or deleting packages.",
    "remediation": "Set the minimum number of administrators in your package registry. To accomplish this: For each project that you administer on GitLab, you can see an overview of every team or person with access to the repository. Provide access to the appropriate people or teams. References: 1. https://docs.gitlab.com/ee/user/packages/package_registry",
    "function_names": [
      "package_registry_administrator_min_count",
      "package_registry_admin_minimum_count",
      "package_registry_administrator_limit",
      "package_registry_admin_count_compliance",
      "package_registry_administrator_minimum",
      "package_registry_admin_min_count",
      "package_registry_administrator_count_limit",
      "package_registry_admin_minimum_required"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Administrator privileges are required to provide and maintain a secure and stable platform but allowing extraneous administrator accounts can create a vulnerability.",
    "references": "1. https://docs.gitlab.com/ee/user/packages/package_registry"
  },
  {
    "id": "4.3.1",
    "title": "Ensure all signed artifacts are validated upon uploading the package registry",
    "assessment": "Manual",
    "description": "Validate artifact signatures before uploading to the package registry.",
    "rationale": "Cryptographic signature is a tool to verify artifact authenticity. Every artifact is supposed to be signed by its creator in order to confirm that it was not compromised before reaching the client. Validating an artifact signature before delivering it is another level of protection which ensures the signature has not been changed, meaning no one tried or succeeded in tampering with the artifact. This creates trust between the supplier and the client.",
    "audit": "Ensure every artifact in the package registry has been validated with its signature. 1. On the left sidebar, select Search or go to and find your project. o To review commits for a project, select Code > Commits. o To review commits for a merge request, select Code > Merge requests, then select your merge request. 2. Select Commits. 3. Identify the commit you want to review. Signed commits show either a Verified or Unverified badge, depending on the verification status of the signature. Unsigned commits do not display a badge.",
    "remediation": "Validate every artifact with its signature before uploading it to the package registry. It is recommended to do so automatically. Default Value: Artifacts are not scanned by default. References: 1. https://docs.gitlab.com/ee/user/project/repository/signed_commits/",
    "function_names": [
      "package_registry_artifact_signature_validated",
      "package_registry_upload_signature_validation_enabled",
      "package_registry_signed_artifact_validation_required",
      "package_registry_upload_signature_check_enabled",
      "package_registry_artifact_integrity_validation_enabled"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/user/project/repository/signed_commits/"
  },
  {
    "id": "4.3.2",
    "title": "Ensure all versions of an existing artifact have their signatures validated",
    "assessment": "Manual",
    "description": "Validate the signature of all versions of an existing artifact.",
    "rationale": "In order to be certain a version of an existing and trusted artifact is not malicious or delivered by someone looking to interfere with the supply chain, it is a good practice to validate the signatures of each version. Doing so decreases the risk of using a compromised artifact, which might lead to a breach.",
    "audit": "For each artifact, ensure that all of its versions are signed and validated before it is uploaded or used. Ensure every artifact in the package registry has been validated with its signature. Ensure every artifact in the package registry has been validated with its signature. 1. On the left sidebar, select Search or go to and find your project. o To review commits for a project, select Code > Commits. o To review commits for a merge request, select Code > Merge requests, then select your merge request. 2. Select Commits. 3. Identify the commit you want to review. Signed commits show either a Verified or Unverified badge, depending on the verification status of the signature. Unsigned commits do not display a badge.",
    "remediation": "For each artifact, sign and validate each version before uploading or using the artifact. References: 1. https://docs.gitlab.com/ee/user/project/repository/signed_commits/",
    "function_names": [
      "artifact_version_signature_validated",
      "artifact_version_signature_validated_all_versions",
      "artifact_signature_validation_enabled",
      "artifact_all_versions_signature_validated",
      "artifact_signature_validation_required"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/user/project/repository/signed_commits/"
  },
  {
    "id": "4.3.3",
    "title": "Ensure changes in package registry configuration are audited",
    "assessment": "Manual",
    "description": "Audit changes of the package registry configuration.",
    "rationale": "The package registry is a crucial component in the software supply chain. It stores artifacts with potentially sensitive data that will eventually be deployed and used in production. Every change made to the package registry configuration must be examined carefully to ensure no exposure of the registry's sensitive data. This examination also ensures no malicious actors have performed modifications to a stored artifact. Auditing the configuration and its changes helps in decreasing such risks.",
    "audit": "Verify that all changes to the packages registry configuration are audited.",
    "remediation": "Audit the changes to the package registry configuration. References: 1. https://docs.gitlab.com/ee/administration/audit_event_types.html",
    "function_names": [
      "cloudtrail_trail_package_registry_changes_audited",
      "cloudtrail_trail_configuration_changes_audited",
      "cloudtrail_trail_package_registry_logging_enabled",
      "cloudtrail_trail_configuration_logging_enabled",
      "cloudtrail_trail_package_registry_monitoring_enabled",
      "cloudtrail_trail_configuration_monitoring_enabled",
      "cloudtrail_trail_package_registry_event_selectors_enabled",
      "cloudtrail_trail_configuration_event_selectors_enabled"
    ],
    "profile_applicability": "\u2022  Level 1",
    "references": "1. https://docs.gitlab.com/ee/administration/audit_event_types.html"
  },
  {
    "id": "4.3.4",
    "title": "Ensure webhooks of the repository are secured",
    "assessment": "Manual",
    "description": "Use secured webhooks to reduce the possibility of malicious payloads.",
    "rationale": "Webhooks are used for triggering an HTTP request based on an action made in the platform. Typically, package registries feature webhooks when a package receives an update. Since webhooks are an HTTP POST request, they can be malformed if not secured over SSL. To prevent a potential hack and compromise of the webhook or to the registry or web server excepting the request, use only secured webhooks. Impact: Reduces the payloads that the web hook can listen for and recieve.",
    "audit": "",
    "remediation": "For each webhook in use, change it to secured (over HTTPS).",
    "function_names": [
      "repository_webhook_https_enabled",
      "repository_webhook_secret_configured",
      "repository_webhook_ip_restricted",
      "repository_webhook_signature_verified",
      "repository_webhook_tls_enabled",
      "repository_webhook_auth_required",
      "repository_webhook_payload_encrypted",
      "repository_webhook_rate_limited"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Reduces the payloads that the web hook can listen for and recieve."
  },
  {
    "id": "4.4.1",
    "title": "Ensure artifacts contain information about their origin",
    "assessment": "Manual",
    "description": "When delivering artifacts, ensure they have information about their origin. This may be done by providing a Software Bill of Manufacture (SBOM) or some metadata files.",
    "rationale": "Information about artifact origin can be used for verification purposes. Having this kind of information allows the user to decide if the organization supplying the artifact is trusted. In a case of potential vulnerability or version update, this can be used to verify that the organization issuing it is the actual origin and not someone else. If users need to report problems with the artifact, they will have an address to contact as well.",
    "audit": "For each artifact, ensure it has information about its origin.",
    "remediation": "For each artifact supplied, supply information about its origin. For each artifact in use, ask for information about its origin.",
    "function_names": [
      "artifact_origin_information_required",
      "artifact_sbom_metadata_present",
      "artifact_origin_metadata_included",
      "artifact_origin_tracking_enabled",
      "artifact_sbom_validation_required",
      "artifact_metadata_origin_defined",
      "artifact_origin_transparency_enforced",
      "artifact_sbom_origin_verified"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "5.1.1",
    "title": "Ensure deployment configuration files are separated from source code",
    "assessment": "Manual",
    "description": "Deployment configurations are often stored in a version control system. Separate deployment configuration files from source code repositories.",
    "rationale": "Deployment configuration manifests are often stored in version control systems. Storing them in dedicated repositories, separately from source code repositories, has several benefits. First, it adds order to both maintenance and version control history. This makes it easier to track code or manifest changes, as well as spot any malicious code or misconfigurations. Second, it helps achieve the Least Privilege principle. Because access can be configured differently for each repository, fewer users will have access to this configuration, which is typically sensitive.",
    "audit": "Ensure each deployment configuration file is stored separately from source code.",
    "remediation": "Store each deployment configuration file in a dedicated repository separately from source code.",
    "function_names": [
      "deployment_config_files_separated_from_source_code",
      "deployment_config_repository_separated",
      "source_code_repository_no_deployment_configs",
      "deployment_config_files_external_to_source",
      "deployment_config_storage_isolated_from_source"
    ],
    "profile_applicability": "\u2022  Level 2"
  },
  {
    "id": "5.1.2",
    "title": "Ensure changes in deployment configuration are audited",
    "assessment": "Manual",
    "description": "Audit and track changes made in deployment configuration.",
    "rationale": "Deployment configuration is sensitive in nature. The tiniest mistake can lead to downtime or bugs in production, which consequently may have a direct effect on both product integrity and customer trust. Misconfigurations might also be used by malicious actors to attack the production platform. Because of this, every change in the configuration needs a review and possible \"revert\" in case of a mistake or malicious change. Auditing every change and tracking them helps detect and fix such incidents more quickly.",
    "audit": "For each deployment configuration, ensure changes made to it are audited and tracked.",
    "remediation": "For each deployment configuration, track and audit changes made to it.",
    "function_names": [
      "cloudtrail_trail_deployment_changes_audited",
      "cloudtrail_trail_configuration_changes_audited",
      "cloudtrail_trail_deployment_modifications_audited",
      "cloudtrail_trail_configuration_modifications_audited",
      "cloudtrail_trail_deployment_changes_logged",
      "cloudtrail_trail_configuration_changes_logged",
      "cloudtrail_trail_deployment_modifications_logged",
      "cloudtrail_trail_configuration_modifications_logged",
      "cloudtrail_trail_deployment_changes_tracked",
      "cloudtrail_trail_configuration_changes_tracked"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "5.1.3",
    "title": "Ensure scanners are in place to identify and prevent sensitive data in deployment configuration",
    "assessment": "Manual",
    "description": "Detect and prevent sensitive data \u2013 such as confidential ID numbers, passwords, etc. \u2013 in deployment configurations.",
    "rationale": "Sensitive data in deployment configurations might create a major incident if an attacker gains access to it, as this can cause data loss and theft. It is important to keep sensitive data safe and to not expose it in the configuration. In order to prevent a possible exposure, set scanners that will identify and prevent such data in deployment configurations.",
    "audit": "For each deployment configuration file, verify that scanners are set to identify and prevent the existence of sensitive data within it.",
    "remediation": "For each deployment configuration file, set scanners to identify and prevent sensitive data within it.",
    "function_names": [
      "compute_deployment_config_sensitive_data_scanning_enabled",
      "compute_deployment_config_sensitive_data_prevention_enabled",
      "compute_deployment_config_secrets_detection_enabled",
      "compute_deployment_config_secrets_blocking_enabled",
      "compute_deployment_config_sensitive_data_monitoring_enabled",
      "compute_deployment_config_sensitive_data_protection_enabled",
      "compute_deployment_config_secrets_scanning_active",
      "compute_deployment_config_secrets_prevention_active"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "5.1.4",
    "title": "Limit access to deployment configurations",
    "assessment": "Manual",
    "description": "Restrict access to the deployment configuration to trusted and qualified users only.",
    "rationale": "Deployment configurations are sensitive in nature. The tiniest mistake can lead to downtime or bugs in production, which can have a direct effect on the product's integrity and customer trust. Misconfigurations might also be used by malicious actors to attack the production platform. To avoid such harm as much as possible, ensure only trusted and qualified users have access to such configurations. This will also reduce the number of accounts that might affect the environment in case of an attack. Impact: Reducing the number of users who have access to the deployment configuration means those users would lose their ability to make direct changes to that configuration.",
    "audit": "Verify each deployment configuration is accessible only to known and authorized users.",
    "remediation": "Restrict access to the deployment configuration to trusted and qualified users.",
    "function_names": [
      "iam_deployment_config_access_restricted",
      "iam_deployment_config_trusted_users_only",
      "iam_deployment_config_least_privilege",
      "iam_deployment_config_qualified_users_only",
      "iam_deployment_config_minimal_access",
      "iam_deployment_config_secure_permissions",
      "iam_deployment_config_authorized_users_only",
      "iam_deployment_config_restricted_roles"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Reducing the number of users who have access to the deployment configuration means those users would lose their ability to make direct changes to that configuration."
  },
  {
    "id": "5.1.5",
    "title": "Scan Infrastructure as Code (IaC)",
    "assessment": "Manual",
    "description": "Detect and prevent misconfigurations or insecure instructions in Infrastructure as Code (IaC) files, such as Terraform files.",
    "rationale": "Infrastructure as Code (IaC) files are used for production environment and application deployment. These are sensitive parts of the software supply chain because they are always in touch with customers, and thus might affect their opinion of or trust in the product. Attackers often target these environments. Detecting and fixing misconfigurations and/or insecure instructions in IaC files decreases the risk for data leak or data theft. It is important to secure IaC instructions in order to prevent further problems of deployment, exposed assets, or improper configurations, which might ultimately lead to easier ways to attack and steal organization data.",
    "audit": "For every Infrastructure as Code (IaC) instructions file, verify that scanners are set to identify and prevent misconfigurations and insecure instructions.",
    "remediation": "For every Infrastructure as Code (IaC) instructions file, set scanners to identify and prevent misconfigurations and insecure instructions.",
    "function_names": [
      "iac_files_no_hardcoded_secrets",
      "iac_files_encryption_enabled",
      "iac_files_no_admin_privileges",
      "iac_files_no_public_access",
      "iac_files_no_insecure_protocols",
      "iac_files_no_default_credentials",
      "iac_files_no_unrestricted_ingress",
      "iac_files_no_unrestricted_egress",
      "iac_files_no_plaintext_passwords",
      "iac_files_no_insecure_cipher_suites",
      "iac_files_no_unrestricted_iam_roles",
      "iac_files_no_unrestricted_s3_buckets",
      "iac_files_no_unrestricted_rds_instances",
      "iac_files_no_unrestricted_lambda_functions",
      "iac_files_no_unrestricted_api_gateways",
      "iac_files_no_unrestricted_cloudfront_distributions",
      "iac_files_no_unrestricted_eks_clusters",
      "iac_files_no_unrestricted_ecr_repositories",
      "iac_files_no_unrestricted_ec2_instances",
      "iac_files_no_unrestricted_elb_load_balancers"
    ],
    "profile_applicability": "\u2022  Level 2"
  },
  {
    "id": "5.1.6",
    "title": "Ensure deployment configuration manifests are verified",
    "assessment": "Manual",
    "description": "Verify the deployment configuration manifests.",
    "rationale": "To ensure that the configuration manifests used are trusted and have not been infected by malicious actors before arriving at the platform, it is important to verify the manifests. This may be done by comparing the checksum of the manifest file to its checksum in a trusted source. If a difference arises, this is a sign that an unknown actor has interfered and may have added malicious instructions. If this manifest is used, it might harm the environment and application deployment, which could end in a massive breach and leave the organization exposed to data leaks, etc.",
    "audit": "For each deployment configuration manifest in use, ensure it has been verified.",
    "remediation": "Verify each deployment configuration manifest in use.",
    "function_names": [
      "compute_deployment_manifest_verified",
      "compute_deployment_manifest_signed",
      "compute_deployment_manifest_integrity_checked",
      "compute_deployment_manifest_version_controlled",
      "compute_deployment_manifest_immutable",
      "compute_deployment_manifest_approved",
      "compute_deployment_manifest_encrypted",
      "compute_deployment_manifest_access_restricted"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "5.1.7",
    "title": "Ensure deployment configuration manifests are pinned to a specific, verified version",
    "assessment": "Manual",
    "description": "Deployment configuration is often stored in a version control system and is pulled from there. Pin the configuration used to a specific, verified version or commit Secure Hash Algorithm (SHA). Avoid referring configuration without its version tag specified.",
    "rationale": "Deployment configuration manifests are often stored in version control systems and pulled from there either by automation platforms, for example Ansible, or GitOps platforms, such as ArgoCD. When a manifest is pulled from a version control system without tag or commit Secure Hash Algorithm (SHA) specified, it is pulled from the HEAD revision, which is equal to the 'latest' tag, and pulls the last change made. This increases the risk of encountering a new, potentially malicious configuration. If an attacker pushes malicious configuration to the version control system, the next user who pulls the HEAD revision will pull it and risk attack. To avoid that risk, use a version tag of verified version or a commit SHA of a trusted commit, which will ensure this is the only version pulled. Impact: Changes in deployment configuration will not be pulled unless their version tag or commit Secure Hash Algorithm (SHA) is specified. This might slow down the deployment process.",
    "audit": "For every deployment configuration manifest in use, ensure it is pinned to a specific version or commit Secure Hash Algorithm (SHA).",
    "remediation": "For every deployment configuration manifest in use, pin to a specific version or commit Secure Hash Algorithm (SHA).",
    "function_names": [
      "compute_deployment_manifest_version_pinned",
      "compute_deployment_manifest_commit_sha_pinned",
      "compute_deployment_config_version_locked",
      "compute_deployment_config_sha_verified",
      "compute_deployment_manifest_no_floating_tags",
      "compute_deployment_config_version_specified",
      "compute_deployment_manifest_no_latest_tag",
      "compute_deployment_config_commit_hash_pinned"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Changes in deployment configuration will not be pulled unless their version tag or commit Secure Hash Algorithm (SHA) is specified. This might slow down the deployment process."
  },
  {
    "id": "5.2.1",
    "title": "Ensure deployments are automated",
    "assessment": "Manual",
    "description": "Automate deployments of production environment and application.",
    "rationale": "Automating the deployments of both production environment and applications reduces the risk for human mistakes \u2014 such as a wrong configuration or exposure of sensitive data \u2014 because it requires less human interaction or intervention. It also eases redeployment of the environment. It is best to automate with Infrastructure as Code (IaC) because it offers more control over changes made to the environment creation configuration and stores to a version control platform.",
    "audit": "For each deployment process, ensure it is automated.",
    "remediation": "Automate each deployment process of the production environment and application.",
    "function_names": [
      "compute_deployment_automated",
      "compute_deployment_automated_production",
      "compute_environment_automated_deployment",
      "compute_application_automated_deployment",
      "deployment_automation_enabled",
      "deployment_automation_enabled_production",
      "environment_deployment_automated",
      "application_deployment_automated"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "5.2.2",
    "title": "Ensure the deployment environment is reproducible",
    "assessment": "Manual",
    "description": "Verify that the deployment environment \u2013 the orchestrator and the production environment where the application is deployed \u2013 is reproducible. This means that the environment stays the same in each deployment if the configuration has not changed.",
    "rationale": "A reproducible build is a build that produces the same artifact when given the same input data, and in this case the same environment. Ensuring that the same environment is produced when given the same input helps verify that no change has been made to it. This action allows an organization to trust that its deployment environment is built only from safe code and configuration that has been reviewed and tested and has not been tainted or changed abruptly.",
    "audit": "Verify that the deployment/production environment is reproducible.",
    "remediation": "Adjust the process that deploys the deployment/production environment to build the same environment each time when the configuration has not changed.",
    "function_names": [
      "compute_deployment_environment_reproducible",
      "compute_environment_configuration_immutable",
      "compute_environment_configuration_versioned",
      "compute_environment_configuration_consistent",
      "compute_environment_configuration_tracked",
      "compute_environment_configuration_locked",
      "compute_environment_configuration_automated",
      "compute_environment_configuration_standardized",
      "compute_environment_configuration_audited",
      "compute_environment_configuration_documented"
    ],
    "profile_applicability": "\u2022  Level 1"
  },
  {
    "id": "5.2.3",
    "title": "Ensure access to production environment is limited",
    "assessment": "Manual",
    "description": "Restrict access to the production environment to a few trusted and qualified users only.",
    "rationale": "The production environment is an extremely sensitive one. It directly affects the customer experience and trust in a product, which has serious effects on the organization itself. Because of this sensitive nature, it is important to restrict access to the production environment to only a few trusted and qualified users. This will reduce the risk of mistakes such as exposure of secrets or misconfiguration. This restriction also reduces the number of accounts that are vulnerable to hijacking in order to potentially harm the production environment. Impact: Reducing the number of users who have access to the production environment means those users would lose their ability to make direct changes to that environment.",
    "audit": "Verify that the production environment is accessible only to trusted and qualified users.",
    "remediation": "Restrict access to the production environment to trusted and qualified users.",
    "function_names": [
      "iam_user_production_access_restricted",
      "iam_role_production_access_restricted",
      "iam_policy_production_access_restricted",
      "iam_group_production_access_restricted",
      "compute_instance_production_access_restricted",
      "compute_ssh_production_access_restricted",
      "cloudtrail_production_access_logging_enabled",
      "cloudtrail_production_access_monitoring_enabled",
      "vpc_production_access_restricted",
      "vpc_peering_production_access_restricted"
    ],
    "profile_applicability": "\u2022  Level 1",
    "impact": "Reducing the number of users who have access to the production environment means those users would lose their ability to make direct changes to that environment."
  },
  {
    "id": "5.2.4",
    "title": "Ensure default passwords are not used",
    "assessment": "Manual",
    "description": "Do not use default passwords of deployment tools and components.",
    "rationale": "Many deployment tools and components are provided with default passwords for the first login. This password is intended to be used only on the first login and should be changed immediately after. Using the default password substantially increases the attack risk. It is very important to ensure that default passwords are not used in deployment tools and components.",
    "audit": "GitLab\u2019s default root password depends on the installation method, and when the installation occurred: 1. When deploying a GitLab instance using the official AWS AMI, the root password to the instance is the EC2 Instance ID 2. Most installation methods allow a non-default password to be provided as configuration 3. Prior to 14.0 the default password was 5iveL!fe 4. Otherwise the default password is unique and randomly generated. Attempt to log in as root using a suspected default password to audit whether it has changed. For any other external build tools, ensure the password used is not the default one.",
    "remediation": "GitLab\u2019s root password can be changed by an administrator using the UI, the \u201cgitlab:password:reset\u201d rake task, or by using the Rails console. For each build tool with a default password, change to a unique cryptographically secure pseudorandom password.",
    "function_names": [
      "compute_instance_default_password_disabled",
      "database_instance_default_password_disabled",
      "container_registry_default_password_disabled",
      "deployment_tool_default_password_disabled",
      "network_device_default_password_disabled",
      "storage_service_default_password_disabled",
      "security_group_default_password_disabled",
      "load_balancer_default_password_disabled",
      "monitoring_service_default_password_disabled",
      "logging_service_default_password_disabled"
    ],
    "profile_applicability": "\u2022  Level 1"
  }
]